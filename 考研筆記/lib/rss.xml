<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[My obsidian]]></title><description><![CDATA[Obsidian digital garden]]></description><link>http://github.com/dylang/node-rss</link><image><url>lib/media/favicon.png</url><title>My obsidian</title><link></link></image><generator>Webpage HTML Export plugin for Obsidian</generator><lastBuildDate>Tue, 19 Mar 2024 06:25:08 GMT</lastBuildDate><atom:link href="lib/rss.xml" rel="self" type="application/rss+xml"/><pubDate>Tue, 19 Mar 2024 06:23:48 GMT</pubDate><ttl>60</ttl><dc:creator></dc:creator><item><title><![CDATA[Computer System structure]]></title><description><![CDATA[ 
 <br><br><br><br><br><br><img alt="../img/截圖 2022-12-08 下午9.59.08.jpg" src="/lib/media/截圖-2022-12-08-下午9.59.08.jpg" style="width: 200px; max-width: 100%;"><br>
允許多個process in memory，同時進行（一段時間執行多個job）<br>
若有process等待I/O，switch 到其他process -&gt; 不讓process佔用CPU資源
<br>名詞解釋
<br>Multiprogramming degree:待在系統中執行的process數目
<br><br><img alt="../img/截圖 2022-12-08 下午9.59.22.jpg" src="/lib/media/截圖-2022-12-08-下午9.59.22.jpg" style="width: 200px; max-width: 100%;"><br>
又稱multitasking ，It is a logical extension of Multiprogeamming sys<br>
(CPU switch jobs so frequently so that user can interact withneach job while it's running)

<br>response time 要短，對每個user job 公平

<br>技術<br>
<br>CPU schedluing 採用RR排程[ch4]
<br>有swapping 技術，及<a class="internal-link" data-href="../CH8 Virtual Memory/CH8 Virtual Memory.md" href="/考研筆記/作業系統/ch8-virtual-memory/ch8-virtual-memory.html" target="_self" rel="noopener">virtual memory</a> 技術
<br>有spooling 技術，讓每個user有自己 I/O-device 的感覺(同時也有Buffering 技術一併使用)
<br><br>
又稱parallel, Tightly-Coupled system<br>
主要特色：

<br>一部裝置內有多顆processors(or CPUs)，所有CPUs均共享machine 內的所有硬體
<br>通常都由同一個clock控制
<br>通常由一個OS管控所有CPUs
<br>processors之間的溝通大多採 shared memory 方式

<br>Benefits:<br>
<br>Increased througtput :<br>
同時處理多個job
<br>Increased Reliability :<br>
萬一其中一個壞了，有其他的可以頂住
<br>Economy of scale 運算能力規模擴充:<br>
共享bus, momory等其他資源
<br><br>
每一個processor提供的工作能力不同<br>
通常是Master-slave
<br>優點：<br>
<br>容易開發
<br>便於從single-cpu OS修改而得
<br>缺點：<br>
<br>效能較差：master-cpu是buttlenech
<br>可靠度較差：Master-cpu壞了-&gt;停頓選新的Master
<br><br>
每一個Processor之工作能力皆相同，有對等權利、存取資源
<br>優點缺點：<br>
與ASMP相反<br><br>彼此獨立，卻互相協助的一群機器<br>
又叫Loosely-Coupled system<br>
主要特色：

<br>多部Machine 以Network相互串連
<br>每一部machine內的cpu有自己的local momory, Bus, ...etc
<br>各CPU的clock不盡相同
<br>各CPU的OS不盡相同
<br>processors之間的溝通採取"Message Passing"方式[ch6]

<br>構建理由或好處：<br>
<br>throughput 增加
<br>可靠度提昇
<br>Resource sharing -&gt; cost down：因為他支持client-server computinh enviroment
<br>remote communication（遠端通訊需求之滿足）
<br><br>可以分為2種<br>
<br>Hard real-time sys.
<br>Soft real-time sys.
<br><br>
定義："This system must ensure the critical task complete on time!!"<br>
例如：軍事防衛系統、核能安控、汽車燃料控制、居家軟體控制、顯示系統
<br>系統設計考量<br>
<br>任何可能影響處理時間之因素
<br>可能造成處理時間過長 or 不可預期之設備，宜少用或不用（EX:Disk）
<br>降低kernel 的干涉時間
<br>用特殊的OS(or 不用OS)
<br>不會與Time-sharing sys.並存
<br><br>
定義："This system must ensure the real-time process has the highest priority than the others and return this level of priority until it completed!"<br>
例：multimedia system , Virtual Reality, Science simulation
<br>系統設計考量<br>
<br>CPU scheduling 而言：可插隊（preemption）、不提供Aging技術
<br>盡量降低kernel 之dispatch latency
<br>現行的OS皆可支援
<br>可支持virtual memory 之使用
<br>可以與Real-time 並存
<br><br>
mobile device<br>
硬體上的先天限制
<br><br><br>
定義：將一些非急迫性or 週期性之工作累積成堆，再批次送入系統處理，處理過程中不需雨user interaction<br>
例：報稅、下載更新軟體
<br>主要目的：想提高冷門時間之資源利用度<br>
不適合用在user-interactive app &amp; real-tiem app]]></description><link>考研筆記/作業系統/ch1-os基本介紹/ch1-os基本介紹.html</link><guid isPermaLink="false">考研筆記/作業系統/CH1 OS基本介紹/CH1 OS基本介紹.md</guid><pubDate>Wed, 13 Mar 2024 09:47:54 GMT</pubDate><enclosure url="lib/media/截圖-2022-12-08-下午9.59.08.jpg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib/media/截圖-2022-12-08-下午9.59.08.jpg&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[I/O]]></title><description><![CDATA[ 
 <br><br><br>
定義：又叫 Busy-waiting I/O or Programmed I/O
<br>steps:<br>
<br>執行中的process發出I/O request 給OS, 希望OS提供某種I/O服務
<br>OS收到請求，（可能）會先Block process
<br>OS中的I/O subsystem會處理此請求
<br>I/O subsystem 會pass 需求給device driver
<br>device driver會依此請求設定相關I/O-Commands 到device controller
<br>device controller會指揮I/O device運作
<br>此時CPU可能idle，OS可能會將CPU分給其他process用
<br>CPU會不斷地去polling I/O-Device controller上之相關register值，確定是否完工
<br><img src="/lib/media/截圖-2022-12-08-下午11.00.10.jpg"><br>缺點：<br>CPU並未將全部的時間用於process exec.上，而是大部分時間去polling I/O-Deviec controllers<br>
-&gt; CPU利用度不高，且process throughput 偏低<br><br>steps:(1~7同Polling I/O)<br>
8. 當I/O工作完成，I/O-Device Controller 會發出一個"I/O completed"interrupt 通知CPU(OS)對kernel level process<br>
9. OS收到中斷通知後，可能會暫停目前執行的process<br>
10. OS依照Interrupt ID(No)查詢Interrupt vector，找到對應的ISR(服務處理程式)<br>
11. Jump to ISR並執行ISR<br>
12. ISR完成，控制權交回kernel I/O-subsystem，通知process I/O-completed 以及其結果。<br>
13. OS恢復之前中斷的process 或交給CPU scheduler決定<br>
<img src="/lib/media/截圖-2022-12-12-下午11.04.58.jpg"><br>優點：<br>
CPU無須花時間用於polling，而是全心用於Process execution。所以CPU utilization和throughput較高<br>
缺點：<br>
<br>Interrupt之處理需耗費時間(CPU time)<br>
Note:I/O很快的話，pollinh也許比interrupt 還有效率
<br>若Interrupt頻率高-&gt;CPU utiliztion會很差時間都用在處理Interrupt
<br>CPU仍需花時間處理memory之間的Data-transfer
<br><br>
定義：DMA controller負責I/O-Device and memory 之間的Data-transfer工作。解決Interrupt I/O的缺點3
所以（優點）：

<br>CPU有更多時間可以花在process上
<br>適合用"Block"-Transfer oriented I/O-Device, ex: Disk。

缺點：

<br>增加硬體設計之複雜度
<br>因為，DMA會和CPU爭奪memory 和Bus之使用權-&gt;硬體協調設計（通常是DMA高優先）

<br>Cycle stealing(interleaving<br>
CPU 和 DMA爭奪memory的使用權時，通常DMA有較高的優先權，所以CPU可能會被迫暫停。
當週邊設備要求進行主記憶體存取時，它中斷中央處理器， 它用不著儲存中央處理器狀態，並使中央處理器延遲一個記 憶體週期(Memory Cycle)，週邊設備利用這極短的時間 ，至主記憶體內存取一或二個位元組(Bytes)。
<br>CPU怎麼使用DMACPU 將數值寫入DMA能夠access的特殊register中，DMA收到命令後就會開始操作<br>CPU怎麼知道DMA是否結束？DMA完成工作後，會interrupt CPU<br><img src="/lib/media/截圖-2022-12-12-下午11.20.24.jpg"><br><br>
定義：系統中硬體產生的變化
kernel所在的memory area 中會存有一個"Interrupt vector"表，內放各式interrupt ID &amp; ISRs之位址。此外也會存這一些ISRs 的 Binary code
<br><br>OS之處理steps:<br>
<br>OS收到後，若要立即處理-&gt;展停目前執行的process且保存其status
<br>OS查interrupt vector  based on interrupt ID，辨別何種中斷發生且找出ISR之位置
<br>Jump to ISR位置並執行
<br>完成ISR，然後交回kernel控制
<br>恢復之前被中斷的process(或是依照CPU scheduler)
<br><img alt="../img/截圖 2022-12-20 下午4.03.05.jpg" src="/lib/media/截圖-2022-12-20-下午4.03.05.jpg" style="width: 400px; max-width: 100%;"><br><br>[分類一]<br>
<br>External interrupt:CPU之外的元件發出的。I/O-completed, I/O error, machine-check
<br>Internal interrupt:CPU執行process時遇到重大error引起。divide zero
<br>Software interrupt:process執行時，若需OS提供某種服務，會發出此類型的中斷，通知OS <a class="internal-link" data-href="../CH3 OS structure and Development/CH3 OS structure and Development.md#System call ⭐️" href="/考研筆記/作業系統/ch3-os-structure-and-development/ch3-os-structure-and-development.html#System_call_⭐️" target="_self" rel="noopener">CH3 system call</a>
<br>[分類二] 常用這個 <br><br>
<br>Interrupt:硬體產生的中斷
<br>Trap:軟體產生的中斷。catch the arithmatic interrupt, software interrupt
<br>[分類三]<br>
Interrupt之間應該有優先權<br>
<br>Non-maskable-Interrupt:需立即處理
<br>Maskable-interrupt:此中斷發生可以delay或是忽略
<br><br><img src="/lib/media/截圖-2022-12-12-下午11.55.28.jpg"><br>
<img alt="../img/截圖 2022-12-12 下午11.55.36.jpg" src="/lib/media/截圖-2022-12-12-下午11.55.36.jpg" style="width: 250px; max-width: 100%;"><br><br><br><br><img src="/lib/media/截圖-2022-12-12-下午11.56.57.jpg"><br>
<img src="/lib/media/截圖-2022-12-29-下午4.57.15.jpg"><br>dual mode operation is provided by OS or CPUBoth. dual mode同時需要硬體以及軟體的支援。CPU中的mode bit。OS需要定義privilege instructions<br>什麼情況下會讓mode從user mode switch 到kernel mode?system call, interrupt, divides by zero, illegel memory access, ...<br>OS可以run在user mode嗎？不可，這樣就無法達到dual mode的目的<br><br><img src="/lib/media/截圖-2022-12-29-下午4.57.26.jpg"><br><br>使用特權指令<br>
<img src="/lib/media/截圖-2022-12-29-下午4.57.35.jpg"><br><br>register 限制上下界<br><img src="/lib/media/截圖-2022-12-29-下午4.58.19.jpg"><br><br>Max-Time-Quantum<br>
<img src="/lib/media/截圖-2022-12-12-下午11.57.24.jpg">]]></description><link>考研筆記/作業系統/ch2-io運作方式、interrupt介紹、hw-resource-protection/ch2-io運作方式、interrupt介紹、hw-resource-protection.html</link><guid isPermaLink="false">考研筆記/作業系統/CH2 IO運作方式、Interrupt介紹、Hw Resource Protection/CH2 IO運作方式、Interrupt介紹、Hw Resource Protection.md</guid><pubDate>Mon, 04 Mar 2024 08:06:10 GMT</pubDate><enclosure url="lib/media/截圖-2022-12-08-下午11.00.10.jpg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib/media/截圖-2022-12-08-下午11.00.10.jpg&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[System call <a href="?query=tag:%E2%AD%90%EF%B8%8F" class="tag" target="_blank" rel="noopener">#⭐️</a>]]></title><description><![CDATA[<a class="tag" href="?query=tag:⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️</a> <a class="tag" href="?query=tag:⭐️⭐" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐</a> <a class="tag" href="?query=tag:⭐️⭐" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐</a> <a class="tag" href="?query=tag:⭐️⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️⭐️</a> <a class="tag" href="?query=tag:⭐️⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️⭐️</a> <a class="tag" href="?query=tag:⭐️⭐" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐</a> <a class="tag" href="?query=tag:⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️</a> <a class="tag" href="?query=tag:⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️</a> 
 <br><br>
作為user processes 和 kernel 溝通之介面，代表OS可以提供的服務項目<br>
例如：讀取檔案、拷貝、
<br><br>
<br>處理程序控制
<br>檔案的運用
<br>裝置的運用
<br><br>參數放到stack, system call's code放到暫存器, trap kernel, <br>
<br>Push parameters on stack.  
<br>Invoke the system call.  
<br>Put code for system call on register.  
<br>Trap to the kernel  
<br>Since a number is associated with each system call, system call interface invokes/dispatch intended system call in OS kernel and return status of the system call and any return value.  
<br>Increment stack pointer.
<br><img src="/lib/media/截圖-2023-01-22-下午4.05.12.jpg"><br><br><br>優點：<br>
簡單、快速<br>缺點：<br>
不適用在大量參數<br><br>
以memory 中一個Block保存這些參數，然後將Block's address記在register中給OS用
<br>優點：<br>
適用於大量參數<br>缺點：<br>
存取速度慢<br><br>
參數push進，OS再pop以取得
<br>優點：<br>
適用大量參數，且比memory簡單<br>缺點：<br>
stack size大小應該要很大（以免溢出）<br><br><br>「賦予等級」及「確切數字」等實體含義的即為”policy”<br>例：<br>
<br>使用priority 做CPUscheduling -&gt; Mechanism
<br>優先權大小定義-&gt; Policy
<br><br><br><br><br><br>什麼是Microkernel移除kernel中不必要的service並將其移至user-level以sys. library方式提供。(ex: iOS and Android)<br>
起源：CMU(卡內基美隆大學)最早提出此概念，為簡化UNIX發展出MachOS<br>
定義：將kernel 中一些 非必要的服務自 kernel 中移除，改成在user site 以 system software/library 方式提供服務，以便得到一個較小的kernel
一般而言提供：

<br>Process management
<br>Memory management
<br>Process Communication

應用例子：iOS and Android
<br>優點：<br>
<br>更容易擴充microkernel：<br>
很多服務在user site，不需要kernel  大幅配合修改
<br>更容易將OS移植到新的硬體架構
<br>更可靠和安全<br>
若service fail，因為running 在user site ，所以不影響其他process and kerenl。
<br>缺點：<br>
Performance變差：<br>
user site &amp; kernel 之間大量message處理＆傳輸之負擔<br><br>什是Monolithic將子系統整合成一大塊程序放進kernel的簡化架構，可以直接用sys. calls呼叫kernel services.<br>
定義：<br>
與Microkernel 相反。所有的kernel services 皆Run在kernel mode<br>
將子系統整合成一大塊程序放進kernel的簡化架構，可以直接用sys. calls呼叫kernel services.
例(大部分OS)：UNIX, Linux, Windows, Apple OS
<br>優缺<br>
與Microkernel 相反<br><br><br><br>相關名詞：<br>
<br>Host：underlying HW system
<br>Virtual Machine Manager(VMM) or Hypervisor：<br>
Create and Run VM by providing interface that is identical to the host
<br>Guest：<br>
process provided with virtual copy of the host 通常是OS
<br><br><br><br>
<br>OS-like-Software：只提供virtaulization 功能
<br>general-purpose OS 但是是在kernel mode提供VMM
<br><br>
Applications that run on standard OS but provides VMM功能
<br>e.g Virtual Box, Parallel Desktop<br><br><br>好處<br>
<br>作為一個測試發展中的OS的良好負載平台
<br>降低成本
<br>安全
<br>雲端服務&amp;商業

<br>備份
<br>整合sys. 多個sys.在同一台機器
<br>轉移能力
<br>templating


<br>缺點<br>
<br>不好開發
<br>效能比real HW差
<br><br><br>
<br>Public cloud
<br>Private cloud
<br>Hybrid cloud
<br>Software as a service (SaaS):在網路上提供的APP
<br>Platform as a service (PaaS):API功能提供。e.g database server
<br>Intrastructure as a service (IaaS):備份運算
]]></description><link>考研筆記/作業系統/ch3-os-structure-and-development/ch3-os-structure-and-development.html</link><guid isPermaLink="false">考研筆記/作業系統/CH3 OS structure and Development/CH3 OS structure and Development.md</guid><pubDate>Mon, 04 Mar 2024 08:06:28 GMT</pubDate><enclosure url="lib/media/截圖-2023-01-22-下午4.05.12.jpg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib/media/截圖-2023-01-22-下午4.05.12.jpg&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[5 state STD]]></title><description><![CDATA[ 
 <br><br>
<br>New(created)
<br>Ready
<br>Running
<br>Waiting(Block)(Sleeping)
<br>Terminated(exit)(zombie)
]]></description><link>考研筆記/作業系統/ch4-process-management-&amp;-tread-management/5-state-std.html</link><guid isPermaLink="false">考研筆記/作業系統/CH4 Process Management &amp; Tread Management/5 state STD.md</guid><pubDate>Mon, 04 Mar 2024 08:06:54 GMT</pubDate></item><item><title><![CDATA[7個state(5個的延伸)]]></title><description><![CDATA[ 
 <br><br>
<br>New(created)
<br>Ready
<br>Running
<br>Waiting(Block)(Sleeping)
<br>Terminated(exit)(zombie)
<br>suspended/Ready
<br>suspended/Block
]]></description><link>考研筆記/作業系統/ch4-process-management-&amp;-tread-management/7-state(5個的延伸).html</link><guid isPermaLink="false">考研筆記/作業系統/CH4 Process Management &amp; Tread Management/7 state(5個的延伸).md</guid><pubDate>Mon, 04 Mar 2024 08:06:44 GMT</pubDate></item><item><title><![CDATA[未命名 1]]></title><description><![CDATA[ 
 ]]></description><link>考研筆記/作業系統/ch4-process-management-&amp;-tread-management/未命名-1.html</link><guid isPermaLink="false">考研筆記/作業系統/CH4 Process Management &amp; Tread Management/未命名 1.md</guid><pubDate>Wed, 13 Mar 2024 09:16:07 GMT</pubDate></item><item><title><![CDATA[護衛效應]]></title><description><![CDATA[ 
 <br>
多個process 均等待一個長時工作
]]></description><link>考研筆記/作業系統/ch4-process-management-&amp;-tread-management/護衛效應.html</link><guid isPermaLink="false">考研筆記/作業系統/CH4 Process Management &amp; Tread Management/護衛效應.md</guid><pubDate>Wed, 13 Mar 2024 09:17:44 GMT</pubDate></item><item><title><![CDATA[Aging]]></title><description><![CDATA[ 
 <br>process的優先值會隨著 在系統內(ready queue)的時間增加<br>Soft-real time sys. 不準用]]></description><link>考研筆記/作業系統/ch4-process-management-&amp;-tread-management/aging.html</link><guid isPermaLink="false">考研筆記/作業系統/CH4 Process Management &amp; Tread Management/Aging.md</guid><pubDate>Wed, 13 Mar 2024 09:16:03 GMT</pubDate></item><item><title><![CDATA[Process vs Thread]]></title><description><![CDATA[<a class="tag" href="?query=tag:⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️</a> <a class="tag" href="?query=tag:⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️</a> <a class="tag" href="?query=tag:⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️</a> <a class="tag" href="?query=tag:⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️</a> <a class="tag" href="?query=tag:⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️</a> <a class="tag" href="?query=tag:⭐️⭐" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐</a> <a class="tag" href="?query=tag:⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️</a> <a class="tag" href="?query=tag:⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️</a> <a class="tag" href="?query=tag:⭐️⭐" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐</a> 
 <br><br><br><br>Stack<br>
The stack is the memory set aside as scratch space for a thread of execution.<br>
The stack is always reserved in a LIFO (last in first out) order; the most recently reserved block is always the next block to be freed.<br>
無法輕易釋放stack的block（大多都直接改成另一個pointer）
<br>Heap<br>
here's no enforced pattern to the allocation and deallocation of blocks from the heap;<br>
you can allocate a block at any time and free it at any time
<br><br>
<br>kernal thread
<br>user thread
<br><br>
執行中的程式<br>
程式的基本執行實體
組成:

<br>Code section: program code
<br>Data section: 包含globle variables, static variable
<br>Heap: 包含memory dynamically allocated during run time
<br>Program counter, other register

<br><br>
當process被建立，kernel會在kernel memory area 新建一個表格（or Block)，記錄該process之所有相關資訊，稱之PCB
記錄項目(8個)<br>
狀態x2, CPUx2, mem, id, pc, accounting(scheduling 相關)

<br>PID:唯一的
<br>process state
<br>CPU register（包含如stack top pointer, accumulator, index register）
<br>CPU scheduling  info（process 優先權值, PCB pointer）
<br>Memory management info（Base/ Limit register值, page table）
<br>program counter
<br>Accounting info（process使用CPU time 之最大值、目前用了多少cpu time）
<br>I/O status

<br><img src="/lib/media/截圖-2022-12-19-下午8.08.39.jpg"><br><br><br>
定義：又稱"light weight process"<br>
當process內之thread被建立後，每條thread有自己私有的組成內容：

<br>Thread ID
<br>Thread state
<br>Programming Counter
<br>CPU register
<br>Stack
<br>local variable
<br>etc...

<br>好處：<br>
<br>Responsiveness
<br>Resource sharing
<br>Ecnomy
<br>Scalability(可擴展性)：process內每個thread 可在不同CPU內跑-&gt;充分利用multiprocessors 之利益
<br><br>
<br>Many-to many
<br>Many-to-one 效益最好
<br>One-to-one
<br><img src="/lib/media/截圖-2022-12-21-下午2.11.15.jpg"><br><br>(process state diagram)<br>
目的：描Process之life cycle
<br>分成5state和7state，差別在於有無處理memory不足的情況的state<br>
5 state STD<br>
<br>New(created) （process已建立、kernel 已配置PCB，但未配置memory）
<br>Ready
<br>Running
<br>Waiting(Block)(Sleeping)
<br>Terminated(exit)(zombie)
<br>7 state STD<br>
<br>suspended/Ready （較不重要）
<br>suspended/Block
<br><img src="/lib/media/截圖-2023-01-31-下午3.10.36.jpg"><br>
<img src="/lib/media/截圖-2022-12-21-下午1.23.40.jpg"><br><img src="/lib/media/截圖-2022-12-19-下午8.06.18.jpg"><br>
<img src="/lib/media/截圖-2022-12-19-下午8.06.32.jpg"><br>
<img src="/lib/media/截圖-2022-12-19-下午8.06.43.jpg"><br>
<img src="/lib/media/截圖-2023-01-31-下午3.11.05.jpg"><br><br>參與<br>
new -&gt; ready<br>
ready &lt;-&gt; running<br><br><br>
(Job scheduler)
根據multiprogramming's degree, I/O, CPU bound比例<br>
-&gt; 控制哪些process to ready
<br>分析：<br>
<br>執行的頻率不高
<br>可以控制multiprogramming's degree
<br>可以調和I/O Bound 與CPU Bound Processes之適當比例組合
<br>在批次系統中常用。但在time-sharing sys., real-time sys.不用
<br><br>
又稱CPU scheduler, process scheduler<br>
根據優先級-&gt;控制哪些process running
<br>分析：<br>
<br>不能調控multiprogramming's degree, I/O, CPU bound比例
<br>Batch , Time-sharing, Real-time皆要使用
<br>Time-sharing中常用CPU Time clicing(R-R)方法
<br><br>
(Job scheduler)<br>
根據memory space, 優先級<br>
-&gt;控制swap(mem. &amp; disk)
<br><br>
定義：<br>
When CPU switch to another process , the system must save the state of the old process and Load the saved state for the new process via a "Context switch".

<br>Context of process represented in the PCB
<br>是一種負擔
<br>降低Context Switch負擔:

<br>Multiple Register Set:每個process有自己的（private) Register set, C.S時, kernel 只需切換指標
<br>Multithreading



<br><br>
定義：接手排班器出來的process，並管理CPU的控制權<br>
dispatch latency 越小越好
<br>功能：<br>
<br>Context Switch
<br>switch mode to user mode
<br>jump
<br><br><br>
任何process皆可建立processes<br>
目的：要child process執行工作<br>
可分為:

<br>與parent做一樣的事
<br>與parent做不一樣的事

<br><br>
<br>OS
<br>parent 的 subset of 資源
<br>parent 的 all of 資源
<br><br>
<br>並行
<br>等待完成
<br><br>
<br>process完成工作後會發出一個system call 請kernel 終止，收回其資源
<br>process可能異常終止
<br>parent基於以下理由，可能終止child

<br>child已完成
<br>child過度使用資源
<br>parent被終止<br>
有時候OS允許child存活，並由OS or grandparent（以上）提供資源


<br><br><br><br>
建立child process，獨立memory space，資料copy by parent
<br>傳回值：<br>
成功-&gt; 0給child ; child's pid給parent<br>
失敗-&gt; 負數給parent<br><br>
用以終止process。process完成工作會發出此sys. call，請kernel 終止process &amp; release resource

<br>Exit(0)-&gt;正常結束
<br>Exit(-1)-&gt;異常結束

若是child，kernel會通知parent
<br><br>
暫停process直到事件發生
<br><br>
此sys call 用以==載入特定的binary code(or machine code) file ==到memory 中執行
例：生出child後，要他執行「不同於parent的task」，則child可以用此指令。
<br><br>
取得pid
<br><br>
<br>CPU使用率：<br>
{CPU花在process執行的time}/{CPU total time}
<br>產能：<br>
單位時間內完成的 “程序數目”
<br>等待時間：<br>
等待取得CPU 的時間之總和
<br>完成Time(Turnaround)：<br>
process到達 -&gt; 完成 所經過的時長
<br>回應時間：<br>
user輸入data/command -&gt; 產生第一次回應 的時長
<br><br>preemptive
<br>preemptive是指在某一process執行時，有另一process打斷並搶走CPU使用權
<br>小結:<br><br><br>乖乖排隊<br><img src="/lib/media/截圖-2022-12-20-下午8.19.21.jpg"><br>
特性：<br>
<br>簡易
<br>效能差
<br>可能遭遇“<a class="internal-link" data-href="護衛效應.md" href="/考研筆記/作業系統/ch4-process-management-&amp;-tread-management/護衛效應.html" target="_self" rel="noopener">護衛效應</a>”
<br>公平
<br>no <a class="internal-link" data-href="starvation.md" href="/考研筆記/作業系統/ch4-process-management-&amp;-tread-management/starvation.html" target="_self" rel="noopener">starvation</a>
<br>non-preemptive
<br><br>搶走別人正在用的CPU<br>
定義：process在執行時可能因為事件，而被迫放棄CPU，回到ready queue
<br>優點：<br>
<br>完工時間不可預期
<br>context-switch相對多
<br>較有可能race condition
<br>排班效果較佳
<br>缺點：<br>
<br>適合Real-time sys. , Time sharing sys.
<br><br>shortest job first<br>
定義：CPU burst time最小的process優先取得CPU。（若相同則以FCFS為準）<br>
Non-preemptive
<br><img alt="../img/截圖 2022-12-20 下午8.32.35.jpg" src="/lib/media/截圖-2022-12-20-下午8.32.35.jpg" style="width: 450px; max-width: 100%;"><br>
特性：<br>
<br>SJF排班效益最佳 （short job減少的wait time &gt; Long Job 增加的waiting  -&gt; 平均wait time 最小）
<br>不公平
<br>可能有<a class="internal-link" data-href="starvation.md" href="/考研筆記/作業系統/ch4-process-management-&amp;-tread-management/starvation.html" target="_self" rel="noopener">starvation</a> for long-bust time job
<br>不能用在CPU scheduling（因為不知job長短。執行頻率太高間隔時間太短）
<br><br>shortest remaining job first<br>
及preemptive SJF<br>
當process執行時新到達的process之burst time &lt; 正在執行的process之“剩餘”burst time<br>
-&gt;新到達的preempts目前process
<br><img src="/lib/media/截圖-2022-12-20-下午8.42.54.jpg"><br><br>
定義：高優先度的優先取的CPU。（相同則以FCFS）<br>
根據特性，實際上大部分排班規則都屬於Priority
<br>特性：<br>
<br>是一個可參數化之法則，給予不同priority 定義，可產生不同行為之排班<br>
<img src="/lib/media/截圖-2022-12-20-下午8.47.09.jpg">
<br>不公平
<br><a class="internal-link" data-href="starvation.md" href="/考研筆記/作業系統/ch4-process-management-&amp;-tread-management/starvation.html" target="_self" rel="noopener">starvation</a> problem
<br><br>定期換班！！<br>若多個pointers指向同一個PCB，在RR中，該process可以獲得更多使用CPU的時間<br>變化：multiple Quantum time<br><img src="/lib/media/截圖-2022-12-21-下午1.25.15.jpg"><br>
<img src="/lib/media/截圖-2022-12-21-下午1.26.00.jpg"><br><br>多種排班疊再一起<br><img src="/lib/media/截圖-2022-12-21-下午1.27.12.jpg"><br><br>多層排班。但是！process可以使用<a class="internal-link" data-href="Aging.md" href="/考研筆記/作業系統/ch4-process-management-&amp;-tread-management/aging.html" target="_self" rel="noopener">Aging</a>，可以上下層跑<br>
定義：允許Multilevel queue's process moves between queues , &amp; 可採用<a class="internal-link" data-href="Aging.md" href="/考研筆記/作業系統/ch4-process-management-&amp;-tread-management/aging.html" target="_self" rel="noopener">Aging</a>
<br>特性：<br>
<br>可參數化項目眾多
<br>不公平
<br>preemptive
<br>No starvation
<br><br>用RR處理相同優先權的priority scheduling<br>
定義：優先run高優先的process。但是！若是優先度一樣，則使用RR
<br><br><br>
<br>ASMP
<br>SMP
<br><br>
緣由：若process切換到其他的CPU處理，則cache的資料需要轉移-&gt;代價高
所以Affinity 期望process都待在同一個process完成
<br>type of sys. call:Linux 提供<br>
<br>soft affinity:盡量不移轉，但必要時可以轉
<br>hard affinity:絕對不移轉。
<br><br>Meomry stall issue:<br>Solution:<br>
compute cycle &amp; memory cycle 交錯<br>
現今硬體製作"Multithreaded processing Cores"<br>
-&gt;&gt;= 2個hardware threads are assigned to each core<br>
-&gt;若一條hardware thread 發稱memory stall，the core can sitch to another thread and continue process<br><br><br><br><img src="/lib/media/截圖-2022-12-21-下午1.57.11.jpg"><br><br>
採取"Dynamic" priority 且preemptive<br>
規定Deadline越低，優先權越高
<br><img src="/lib/media/截圖-2022-12-21-下午1.57.43.jpg"><br>]]></description><link>考研筆記/作業系統/ch4-process-management-&amp;-tread-management/ch4-process-management-&amp;-thread-management.html</link><guid isPermaLink="false">考研筆記/作業系統/CH4 Process Management &amp; Tread Management/CH4 Process Management &amp; Thread Management.md</guid><pubDate>Mon, 04 Mar 2024 08:06:12 GMT</pubDate><enclosure url="lib/media/截圖-2022-12-19-下午8.08.39.jpg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib/media/截圖-2022-12-19-下午8.08.39.jpg&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[starvation]]></title><description><![CDATA[ 
 <br>
長期無法取得所需資源
<br>解法採用<a class="internal-link" data-href="Aging.md" href="/考研筆記/作業系統/ch4-process-management-&amp;-tread-management/aging.html" target="_self" rel="noopener">Aging</a>技術]]></description><link>考研筆記/作業系統/ch4-process-management-&amp;-tread-management/starvation.html</link><guid isPermaLink="false">考研筆記/作業系統/CH4 Process Management &amp; Tread Management/starvation.md</guid><pubDate>Mon, 04 Mar 2024 08:06:59 GMT</pubDate></item><item><title><![CDATA[Banker Algorithm]]></title><description><![CDATA[ 
 <br><br>若process被否決，則等待一段時間再申請<br>
Check that there is at least one order in which we can schedule the processes, in which there is no deadlock.
<br>概括：依序拿回可以完成的process的資源，直到無法再取回。<br><br>
<br>Request𝒾：P𝒾提出的資源申請量
<br>Allocation：各個process正在持有的資源量
<br>MAX：process全部（從頭到底）所需的資源量
<br>Need：process還需要的資源量 -&gt; Need = MAX-Allocation
<br>Available：目前可取得的資源量
<br><br><img src="/lib/media/截圖-2022-12-22-下午6.01.34.jpg"><br>
<br>Check Request𝒾 &lt;= Need𝒾 ?<br>
（思路：只需要10?
<br>Check Request𝒾 &lt;= Available ?<br>
有充足的資源
<br>計算取得資源後的成果<br>
暫時性分配資源
<br><a class="internal-link" data-href="Safety Algo.md" href="/考研筆記/作業系統/ch5-deadlock/safety-algo.html" target="_self" rel="noopener">Safety Algo</a>.
<br><br><br><img src="/lib/media/banker_q.jpg">]]></description><link>考研筆記/作業系統/ch5-deadlock/banker-algorithm.html</link><guid isPermaLink="false">考研筆記/作業系統/CH5 Deadlock/Banker Algorithm.md</guid><pubDate>Wed, 13 Mar 2024 09:27:23 GMT</pubDate><enclosure url="lib/media/截圖-2022-12-22-下午6.01.34.jpg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib/media/截圖-2022-12-22-下午6.01.34.jpg&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[例子：四個十字路口]]></title><description><![CDATA[ 
 <br><br><br>test直接思考紅綠燈卡死狀況

<br>十字路口一次通過一輛車 -&gt; mutual exclusion
<br>汽車通過時，十字路口被那一台佔用 -&gt; hold and wait
<br>汽車按照順序通過、不可以把其他車撞開 -&gt; no preemption
<br>A等B等C等D等A... -&gt; Circular waiting<br>
“../img/截圖 2022-12-22 下午5.51.54.jpg” could not be found.
<br>
<br>


<br>


<br>


<br>


<br><br><br><br>
定義：系統中存在一組processes彼此行程circular waiting 情況，造成陷入死結之processes皆無法往下執行，使得Throughput, utilization不良之結果。
<br><br><img src="/lib/media/截圖-2022-12-22-下午5.51.39.jpg"><br>
三點結論<br>
<br>No cycle =&gt; No deadlock
<br>有cycle =?&gt; 有deadlock （如果有一種resource的初始數量為0，即便沒有cycle也會Deadlock）
<br>每種Resources皆為單一數量，有cycle =&gt; 有deadlock*
<br><br>Deadlock Free(絕對不會deadlock的最小resource數量)若系統中有n個process，m個res.數量(單一類)，則滿足2條件就保證Deadlock Free

<br>1&lt;=MAX𝒾&lt;=m 資源數量大於總需求
<br>∑ MAX𝒾 &lt; n+m 每個人全部所需小於資源總量加process數量(鴿洞定理)
<br>為什麼即便有辦法處理deadlock，仍然很多系統不願處理(假裝沒看見deadlock)？因為<br>
不論是 prevention, avoidance, detection, recovery 都會造成

<br>resources utilization偏低
<br>throughput 不高

等問題<br>What are the differences between "deadlock prevention" and "deadlock avoidance"<br>
deadlock prevention &amp; deadlock avoidance<br>
優：

<br>保證不會出現deadlock

缺：

<br>對資源的限制很多
<br>可能造成starvation

<br>
deadlock detection &amp; deadlock recovery<br>
優：

<br>資源利用度高、產出量也高

缺：

<br>system有可能進入deadlock
<br>成本高

<br><br><br>
破除四項條件
<br>
<br>破除mutual exclusion<br>
辦不到！！！
<br>破除hold&amp;wait<br>
作法一：process要一次取得所有所需的資源，否則無法取得<br>
作法二：可取得部份資源，但要取得其他資源時，要將先前的資源全部歸還。
<br>破除No preemption<br>
(Easy)改為preemption
<br>破除Circular waiting<br>
Resource ordering (每個process只能依照遞增的序號(每個資源獨有)來申請資源)<br>
<img src="/lib/media/截圖-2022-12-22-下午6.00.08-1.jpg">
<br>若是採用預防的方式，結論：<br>
<br>throughtput降低
<br>裝置率用率降低
<br><br><br>預先算一次需要的資源量即可預防<br>
定義：當某個process提出資源申請時，OS必須執行一個Banker algorithm，用以判斷准許資源後，系統是否處在<a class="internal-link" data-href="Safe state.md" href="/考研筆記/作業系統/ch5-deadlock/safe-state.html" target="_self" rel="noopener">Safe state</a>。若是，准許請求，否則否決此次申請讓process需等待下次再提出申請。
<br>
<br><a class="internal-link" data-href="Safe state.md" href="/考研筆記/作業系統/ch5-deadlock/safe-state.html" target="_self" rel="noopener">Safe state</a>
<br><a class="internal-link" data-href="Unsafe state.md" href="/考研筆記/作業系統/ch5-deadlock/unsafe-state.html" target="_self" rel="noopener">Unsafe state</a>
<br>


<br>結論：<br>
<br>優點：不會進入deadlock
<br>缺點：Banker Algorithm 運算成本高
<br><br><br><br>claim edge: “P𝒾- - - - &gt;R𝒾”:代表P𝒾未來會對R𝒾申請資源<br>
過程（4 steps）<br>
<br>Check 對應的claim是否存在
<br>Check 申請的R𝒾是否avaialble（是：goto 3./否：等待）
<br>試算：claim edge 改成 Allocation
<br>執行Safe Algo. （有cycle:否決/沒cycle:核准）
<br><br>Wait-For Graph**<br>
移掉res.，變成P1等待P2的關係圖(有circle就有deadlock)
<br><br><br>
<br>Process 在deadlock時終止

<br>（法ㄧ）終止所有process: [cost高]過去的成果全白費
<br>（法二）一次中止一個process直到deadlock cycle消失：[cost高]需不斷執行<a class="internal-link" data-href="Detection Algo..md" href="/考研筆記/作業系統/ch5-deadlock/detection-algo..html" target="_self" rel="noopener">Detection Algo.</a>


<br><a class="internal-link" data-href="Resource Preemption.md" href="/考研筆記/作業系統/ch5-deadlock/resource-preemption.html" target="_self" rel="noopener">Resource Preemption</a>
<br>
缺：cost 高，注意<a class="internal-link" data-href="../CH4 Process Management &amp; Tread Management/starvation.md" href="/考研筆記/作業系統/ch4-process-management-&amp;-tread-management/starvation.html" target="_self" rel="noopener">starvation</a>
]]></description><link>考研筆記/作業系統/ch5-deadlock/ch5-deadlock.html</link><guid isPermaLink="false">考研筆記/作業系統/CH5 Deadlock/CH5 Deadlock.md</guid><pubDate>Wed, 13 Mar 2024 09:36:28 GMT</pubDate><enclosure url="lib/media/截圖-2022-12-22-下午5.51.39.jpg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib/media/截圖-2022-12-22-下午5.51.39.jpg&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Circular waiting]]></title><description><![CDATA[ 
 <br>Circular waiting<br>
processes彼此循環等待res.
]]></description><link>考研筆記/作業系統/ch5-deadlock/circular-waiting.html</link><guid isPermaLink="false">考研筆記/作業系統/CH5 Deadlock/Circular waiting.md</guid><pubDate>Wed, 13 Mar 2024 09:27:23 GMT</pubDate></item><item><title><![CDATA[Deadlock Free]]></title><description><![CDATA[ 
 <br><br>若系統中有n個process，m個res.數量(單一類)，則滿足2條件就保證Deadlock Free<br>
<br>1&lt;=MAX𝒾&lt;=m 資源數量大於總需求
<br>∑ MAX𝒾 &lt; n+m 每個人全部所需小於資源總量加process數量(鴿洞定理)
]]></description><link>考研筆記/作業系統/ch5-deadlock/deadlock-free.html</link><guid isPermaLink="false">考研筆記/作業系統/CH5 Deadlock/Deadlock Free.md</guid><pubDate>Wed, 13 Mar 2024 09:36:04 GMT</pubDate></item><item><title><![CDATA[Detection Algo.]]></title><description><![CDATA[ 
 <br><br><br>
<br>process優先權
<br>process已使用的和還需要使用的時間
<br>process已使用的資源
<br>process還需要的資源
<br>多少process將被終止
<br>Process是“互動”還是“批次”
]]></description><link>考研筆記/作業系統/ch5-deadlock/detection-algo..html</link><guid isPermaLink="false">考研筆記/作業系統/CH5 Deadlock/Detection Algo..md</guid><pubDate>Wed, 13 Mar 2024 09:29:14 GMT</pubDate></item><item><title><![CDATA[Hold and wait]]></title><description><![CDATA[ 
 <br>Hold and wait    忠心的資源<br>
process持有res.並等待其他process值有的res.
]]></description><link>考研筆記/作業系統/ch5-deadlock/hold-and-wait.html</link><guid isPermaLink="false">考研筆記/作業系統/CH5 Deadlock/Hold and wait.md</guid><pubDate>Wed, 13 Mar 2024 09:36:09 GMT</pubDate></item><item><title><![CDATA[Mutual exclusion]]></title><description><![CDATA[ 
 <br>Mutual exclusion<br>
此性質之資源在一個時間點，只允許被一個process擁有
]]></description><link>考研筆記/作業系統/ch5-deadlock/mutual-exclusion.html</link><guid isPermaLink="false">考研筆記/作業系統/CH5 Deadlock/Mutual exclusion.md</guid><pubDate>Wed, 13 Mar 2024 09:27:28 GMT</pubDate></item><item><title><![CDATA[No preemption]]></title><description><![CDATA[ 
 <br>No preemption<br>
不能搶奪其他process之res.
<br>OPT]]></description><link>考研筆記/作業系統/ch5-deadlock/no-preemption.html</link><guid isPermaLink="false">考研筆記/作業系統/CH5 Deadlock/No preemption.md</guid><pubDate>Wed, 13 Mar 2024 09:36:10 GMT</pubDate></item><item><title><![CDATA[Resource Preemption]]></title><description><![CDATA[ 
 <br><br>  steps<br>
<br>selecting a victim（要minimize cost)
<br>Roll back（難）:  return to safe state, restart process for that state
]]></description><link>考研筆記/作業系統/ch5-deadlock/resource-preemption.html</link><guid isPermaLink="false">考研筆記/作業系統/CH5 Deadlock/Resource Preemption.md</guid><pubDate>Wed, 13 Mar 2024 09:24:45 GMT</pubDate></item><item><title><![CDATA[Safe state]]></title><description><![CDATA[ 
 <br>定義：只少有一組process的執行序列，這些processes依序分配資源，最終可在未來完工]]></description><link>考研筆記/作業系統/ch5-deadlock/safe-state.html</link><guid isPermaLink="false">考研筆記/作業系統/CH5 Deadlock/Safe state.md</guid><pubDate>Wed, 13 Mar 2024 09:46:34 GMT</pubDate></item><item><title><![CDATA[Safety Algo]]></title><description><![CDATA[ 
 <br><br><br>
<br>Work:可用資源的累計（演算中歸還的資源累計
<br>Finish: 紀錄已完成的process
<br><br>
概括：依序拿回可以完成的process的資源，直到無法再取回
<br><img src="/lib/media/截圖-2022-12-22-下午6.02.09.jpg"><br>
<br>設定初始值
<br>檢查是否有process𝒾可取得Need資源然後完成。有：goto step3，沒有：goto step4
<br>Finish[𝒾] = True, Work+=Need𝒾。goto step2
<br>Check Finish[1..n]。皆為True-&gt;”Safe”，否則”unSafe”
]]></description><link>考研筆記/作業系統/ch5-deadlock/safety-algo.html</link><guid isPermaLink="false">考研筆記/作業系統/CH5 Deadlock/Safety Algo.md</guid><pubDate>Wed, 13 Mar 2024 09:36:53 GMT</pubDate><enclosure url="lib/media/截圖-2022-12-22-下午6.02.09.jpg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib/media/截圖-2022-12-22-下午6.02.09.jpg&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Unsafe state]]></title><description><![CDATA[ 
 <br>Unsafe state != 有deadlock]]></description><link>考研筆記/作業系統/ch5-deadlock/unsafe-state.html</link><guid isPermaLink="false">考研筆記/作業系統/CH5 Deadlock/Unsafe state.md</guid><pubDate>Wed, 13 Mar 2024 09:36:34 GMT</pubDate></item><item><title><![CDATA[兩個process之C.S design]]></title><description><![CDATA[<a class="tag" href="?query=tag:❌" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#❌</a> <a class="tag" href="?query=tag:❌" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#❌</a> <a class="tag" href="?query=tag:✅" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#✅</a> 
 <br><br>
效果：Pi, Pj要一直輪流進入C.S才可運作，否則容易卡住
<br>共享變數宣告int turn;<br>
初值為i or j<br>
意義：ture 值為誰，誰就有資格進入C.S<br>Pi:
repeat {
	while (turn!= i){do no-op;}
	C.S
	turn = j;
	R.S
}until False;
複製<br>Pj:
repeat {
	while (turn!= j){do no-op;}
	C.S
	turn = i;
	R.S
}until False;
複製<br>分析：<br>
<br>Mutual exclusion :OK
<br>Progess違反(i)
<br>Bounded waiting : OK
<br><br>
Ａ會讓B用完在給自己用。彼此會互相禮讓，導致沒人能進C.S
<br>共享變數宣告Flag[i..j] of Boolean;<br>
初值皆為false<br>
意義：True：有意願/False：沒有意願<br>Pi:
repeat {
	flag[i] = True;//表明意願
	while (flag[j]){do no-op;}//若對方想進，我等
	C.S
	flag[i] = False
	R.S
}until False;
複製<br>Pj:
repeat {
	flag[j] = True
	while (flag[i]){do no-op;}
	C.S
	flag[j] = False;
	R.S
}until False;
複製<br>分析：<br>
<br>Bounded waiting : OK
<br>Progress違反：<br>
若兩個process同時都有意願進入C.S，則產生Deadlock
<br>Mutual exclusion :OK
<br>
<br><br>
Algo1 + Algo2

<br>同時，權杖（turn）在自己身上=&gt; run C.S
<br>若有人有意願則有機會進入，但不會是上一個執行過的（因為會把trun交給別人）
<br>Turn 只是用於爭奪優先

<br>共享變數宣告Flag[i..j] of Boolean;<br>
初值皆為false<br>
意義：True：有意願/False：沒有意願<br>
int turn;<br>
初值為i or j<br>
意義：ture 值為誰，誰就有資格進入C.S<br>Pi:
repeat {
	flag[i] = True;//表明意願
	turn = j;//禮讓對方
	while (flag[j] &amp;&amp; turn == j){do no-op;}//若對方想進且權杖在對方身上=&gt;等
	C.S
	flag[i] = False;//表明無意
	R.S
}until False;
複製<br>
Pj:
repeat {
	flag[j] = True;
	turn = i;
	while (flag[i] &amp;&amp; turn == i){do no-op;}
	C.S
	flag[j] = False;
	R.S
}until False;
複製<br>分析：<br>
<br>Mutual exclusion :OK<br>
若雙方想進入C.S，執行到while時，表示雙方皆分別執行過「turn = j」,「turn = i」（差別只是先後順序有別而已）。
<br>Progress：OK

<br>(i) 假設Pi不想進C.S（flag[i] == False, turn == i）<br>
若此時Pj 想進C.S，因為Ｐi不想進-&gt;Pj可進入
<br>(ii) 若Pi, Pj都想進入C.S，由於權杖(turn)必定會在其中一人身上-&gt;必有一位可進入C.S


<br>Bounded waiting : OK<br>
假設雙方皆想進C.S<br>
另turn = i，Pi先進<br>
若Pi離開後又立刻想要進入C.S，則**Pi必定會將turn交給Pj<br>
=&gt;不會讓Pj <a class="internal-link" data-href="../CH4 Process Management &amp; Tread Management/starvation.md" href="/考研筆記/作業系統/ch4-process-management-&amp;-tread-management/starvation.html" target="_self" rel="noopener">starvation</a>
<br>缺點上述程式雖符合C.S. design 之正確性，但peterson's solution在現代電腦架構中，不保證正確。<br>
ex:為了improve sys. performance，processors and/or compiler may reorder read and write operations that have no dependencies，然而，這種reordering of instructions may suffer inconsistency or unexpected result。<br>
compiler 可能對調(reordering)沒有相關性的程式碼以達到最佳化-&gt;對peterson's algo是致命的<br>
所以我們應該要合理的使用其他同步處理方法（硬體...)]]></description><link>考研筆記/作業系統/ch6-process-synchronization/兩個process之c.s-design.html</link><guid isPermaLink="false">考研筆記/作業系統/Ch6  Process Synchronization/兩個process之C.S design.md</guid><pubDate>Mon, 04 Mar 2024 08:07:15 GMT</pubDate></item><item><title><![CDATA[acquire]]></title><description><![CDATA[ 
 <br>acquire(Available){
	while(!Available);
	Available = false
}
複製]]></description><link>考研筆記/作業系統/ch6-process-synchronization/acquire.html</link><guid isPermaLink="false">考研筆記/作業系統/Ch6  Process Synchronization/acquire.md</guid><pubDate>Wed, 13 Mar 2024 09:22:47 GMT</pubDate></item><item><title><![CDATA[Atomic value]]></title><description><![CDATA[ 
 <br>Atomic value<br>只要指定的變數不會Race condition就好<br>
定義：<br>
provides atomic operations on basic data types such as integers and booleans.<br>
用途：<br>
例如Data Race on a single variable while it is begin updated
Quote通常CAS指令is not used directly to provide mutual exclusion. Rather, it is used as a basic building Block for construction other tools. That solve critical-section problem<br>
e.g其中一個tool like atomic variable
<br>使用CAS指令製作variable之例子<br>//檢查v&amp;temp的值是否相同
void increment(atomic_int *v){
	int temp;
	do{
		temp= *v;
	}while(temp!= CAS(v, temp, temp+1)
}
複製<br>若發生data race，CAS的結果會使得再跑一次回圈，使得temp重新讀取v的值(也就是其他process的結果使用data後的)，所以不會有複寫data的問題]]></description><link>考研筆記/作業系統/ch6-process-synchronization/atomic-value.html</link><guid isPermaLink="false">考研筆記/作業系統/Ch6  Process Synchronization/Atomic value.md</guid><pubDate>Wed, 13 Mar 2024 09:20:15 GMT</pubDate></item><item><title><![CDATA[Binary Semaphore]]></title><description><![CDATA[ 
 <br>
定義：

<br>號誌值只有0 或1兩種
<br>不可為負
<br>無法統計出有多少Processes卡在wait

<br><a class="internal-link" data-href="wait.md" href="/考研筆記/作業系統/ch6-process-synchronization/wait.html" target="_self" rel="noopener">wait</a><br>
<a class="internal-link" data-href="signal.md" href="/考研筆記/作業系統/ch6-process-synchronization/signal.html" target="_self" rel="noopener">signal</a>]]></description><link>考研筆記/作業系統/ch6-process-synchronization/binary-semaphore.html</link><guid isPermaLink="false">考研筆記/作業系統/Ch6  Process Synchronization/Binary Semaphore.md</guid><pubDate>Mon, 04 Mar 2024 08:07:49 GMT</pubDate></item><item><title><![CDATA[Bounded capacity]]></title><description><![CDATA[ 
 <br>
若Queue滿，sender才被迫wait
]]></description><link>考研筆記/作業系統/ch6-process-synchronization/bounded-capacity.html</link><guid isPermaLink="false">考研筆記/作業系統/Ch6  Process Synchronization/Bounded capacity.md</guid><pubDate>Mon, 04 Mar 2024 08:07:50 GMT</pubDate></item><item><title><![CDATA[Process Communication 兩大方式]]></title><description><![CDATA[<a class="tag" href="?query=tag:⭐️⭐️⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️⭐️⭐️</a> 
 <br><br>Interprocess Communication (IPC)<br><br>
定義：<br>
Processes之間，透過向OS申請一個shared memory space ，在這space 上可宣告一些shared memory,processes 可藉由write/read這些共想變數，達到溝通
<br>特點:<br>
<br>OS不需提供額外支援在溝通，只提供shared memory 
<br>Programmer 責任重大，亦即撰寫額外控制碼來確保”No” <a class="internal-link" data-href="Race condition.md" href="/考研筆記/作業系統/ch6-process-synchronization/race-condition.html" target="_self" rel="noopener">Race condition</a>
<br>適用於大量的資訊溝通
<br>通訊速度快
<br>不需kernel 介入
<br>需要少量的sys. call(用於create shared memory  space)
<br>不適於分散式系統
<br><br>
定義：兩個processes溝通要遵守以下規定

<br>建立雙方的communication link
<br>Message 可互相傳輸
<br>溝通完，釋放communication link

<br>特點（與shared memory 相反）<br>
<br>OS提供額外支援（建立、回收link ; 傳送、接受message）
<br>Programmer無啥負擔
<br>適用於少量資訊溝通
<br>通訊速度慢（需要用kernel)
<br>較適合分散式系統
<br><br><a class="internal-link" data-href="Race condition.md" href="/考研筆記/作業系統/ch6-process-synchronization/race-condition.html" target="_self" rel="noopener">Race condition</a><br><br><br>我在用的時候，其他人不准搶走我的CPU!<br>
定義：process 執行共享變數存取前，先disable interrupt，完成存取後，才enable interrupt，如此，可保證process在存取共享變數期間cpu不會被preempted，故可防治
<br>優<br>
The critical section problem could be solved in simply in a single-core environment if we could prevent interrupt form occurring while a shared variable was being modified.<br>
<br>Simple
<br>適用於uniprocesser(單cpu)
<br>缺<br>
<br>
不適合用於Multiprocessors之環境

<br>若我們只disable a core 之interrupt，無法防止其他core interrupt.&nbsp; 所以只能disable所有cpu之中斷，啊disable 其餘cpu，導致效能就差
<br>傳遞訊息需大量時間


<br>
風險高一般只開放給OS的開發者，防治kernel data’s race condition
Hint
<br>若放任user process可以disable interrupt, 則對其極度信任，不能讓其為所欲為（不enable interrupt -&gt;CPU never return）  

  Kernel 的data structure 也有race condition 的問題

<br>Non-preemptive kernal: 不會有race condition 的議題。
<br>Preemptive kernal: more responsive, more suitable for real-time programming.但是OS developers 需對kernal data structure 提供防止race condition 之機制


<br><br>工作台一次只能一個人用<br>
定義：在每個C.S前後，programmer必須撰寫額外code,稱Entry section（進入區）及Exit section（離開區）

<br>Reminder section定義： 除了C.S以外之code區間，process不會存取共享變數
<br>Critical section 定義：在此code 區間process會存取共享變數

<br>優<br>
適用於Muliprocesser<br><br>
定義：<br>
在entry section 設計當中經常遇到利用此技術來迫使process waiting，無法往下執行。
<br>P𝒾  
if (條件式）then  
{  
	add Pi to waiting Queue;  
	Block(Pi); // sys.call 
	Pi自running-&gt;wait  
}  
Pj
if (送達） then  
{  
	remove Pi from waiting Queue  
	Wakeup(Pi);  
}
複製<br>Hint此技巧利用決定是否要將process switch到waiting Queue，來避免不需要的loop等待<br>Hint沒有範例程式碼ＱＱ<br>
此技巧是利用迴圈（loop） 相關敘述來完成。<br>
例：while…do “no operation”<br>
若條件式保持true-&gt;保持迴圈-&gt;等待效果  <br>優缺：與spinlock 相反<br><br><br><br>一次一個process在C.S中<br>
定義：任何時間點，全部的（每個process中）C.S中，最多只有一個可以在其區間內活動
<br><br>不會被迫停止<br>
定義：

<br>不想進入C.S之process,不可阻礙或參與其他想進的process。<br>
「不要無故阻礙別人」
<br>若一堆process想進入C.S，必須在有限的時間決定誰可進入。「不可造成所有process接近不了」<br>
「no deadlock」

<br><br>process排C.S的隊不可以排過久<br>
定義：process提出欲進入C.S之申請後，需在有限時間內進入C.S。若有n個process想進入，任一process最多等n-1次就可進入    要公平，no <a class="internal-link" data-href="../CH4 Process Management &amp; Tread Management/starvation.md" href="/考研筆記/作業系統/ch4-process-management-&amp;-tread-management/starvation.html" target="_self" rel="noopener">starvation</a>
<br><br><br>
定義：沒有依靠Hardware and OS支持，存粹程式設計
<br>
<br>
<a class="internal-link" data-href="兩個process之C.S design.md" href="/考研筆記/作業系統/ch6-process-synchronization/兩個process之c.s-design.html" target="_self" rel="noopener">兩個process之C.S design</a>

<br>
ｎ個process之C.S design

<br>Algo4: Peterson's n個processes solution
<br>Bakery's Algo.


<br>缺點：都必須配合Hardware才能，否則compiler可能會竄改順序導致錯誤<br><br>
<br><a class="internal-link" data-href="Memory barrier(or memory Fence).md" href="/考研筆記/作業系統/ch6-process-synchronization/memory-barrier(or-memory-fence).html" target="_self" rel="noopener">Memory barrier(or memory Fence)</a> 確保順序正確
<br><a class="internal-link" data-href="Hardware instructions.md" href="/考研筆記/作業系統/ch6-process-synchronization/hardware-instructions.html" target="_self" rel="noopener">Hardware instructions</a> 不可被中斷的機器指令，保證“atomiclly” executed.
<br><a class="internal-link" data-href="Atomic value.md" href="/考研筆記/作業系統/ch6-process-synchronization/atomic-value.html" target="_self" rel="noopener">Atomic value</a> 
<br><br><br><br><br><br><br><br><br>基本上就是一個類別(Class)<br>
定義<br>
用一種用於解決synchronization problem 之Abstract Data type.<br>
=&gt;類比於"class"
組成：

<br>shared variables
<br>a set of functions
<br>initialization code

struct monitor monitor-name  
{ 
  shared variables 宣告;  
	function P1(參數){...body...}  
	...  
	function Pn(參數){...body...}  
	initialization code(){...}  
 }
複製
特性

<br>在Monitor內所宣告的共享變數只可以被Monitor內的functions 直接存取，但外界不可
<br>本身以保障mutual exclusion 性質

優點：

<br>Monitor內之共享變數值不會race condition(than semephore)
<br>programmer不需去煩惱共享變數之R.C &amp; 同步問題，只需專心處理sync. problem

<br><br>
定義：<br>
在Monitor內，提供此特殊型態，及Condition type的變數，提供給programmer 解sync. problem之用途
<br>每個condition有兩個operation<br>
(Condition x;)<br>
<br><a class="internal-link" data-href="x.wait.md" href="/考研筆記/作業系統/ch6-process-synchronization/x.wait.html" target="_self" rel="noopener">x.wait</a>「沒位子了！排隊吧！」
<br><a class="internal-link" data-href="x.signal.md" href="/考研筆記/作業系統/ch6-process-synchronization/x.signal.html" target="_self" rel="noopener">x.signal</a> 「下一位！請進」！
<br>Note:"Not active"<br>
<br>process呼叫的function已執行完畢（離開Monitor）
<br>process執行x.wait()被block
<br><br><a class="internal-link" data-href="Monitor應用例子.md" href="/考研筆記/作業系統/ch6-process-synchronization/monitor應用例子.html" target="_self" rel="noopener">Monitor應用例子</a><br><br>
先前condition 變數的waiting Queue is FIFO Queue，但在許多場合中，我們需要priority queue(優先權高先移除），才有Conditional wait
<br>宣告 Condition x;<br>
使用x.wait(C);//C表示process的priority number<br><br>
緣由：<br>
若P執行了x.signal,此運作會讓Q resources execution 。<br>
此時P &amp;Q are active in the monitor但這會違反monitor的保障。所以，不可能。<br>
故只能允許其中一個active<br>
選P還是Q先active分出monitor種類
<br><br><br>
P wait Q until Q finihed or Q is blocked again.
<br>會多一個"救命恩人"的queue，當P signal的時候，暫存Ｐ<br>優點<br>
<br>保證Q一定可以立即恢復執行。
<br>more powerful than type[3]。
<br><br>
Q wait P until P finished or P is blocked.
<br>缺點：不保證Q不會被拯救出來<br>
（因為允許P繼續往下，很有可能改變了Q可以被恢復執行的條件。）<br><br>
P exits monitor, let Q resume execution 直到Q finished or blocked ，P才進入monitor 。<br>
(P先離開 置於monitor 的 entry queue 的第一個位置）
<br>例子：C/PASCAL語言<br>
<img src="/lib/media/b7d02ba1-895a-4a0b-b762-8f43df2159c4.png"><br>優點：保證Ｑ一定可以立即恢復執行<br>
缺點：Not powerful than Type1 （理由：在P一進一出monitor期間）<br><br>P暫時儲存的Queue一個在外(monitor外的entry queue)，一個在內(monitor內的Hoare queue)<br><br>（以Hoare Monitor為例）<br>
需求<br>
<br>如何保障Monitor之mutual exclusion
<br>Hoare monitor性質
<br>實作Condition type變數之<a class="internal-link" data-href="x.wait.md" href="/考研筆記/作業系統/ch6-process-synchronization/x.wait.html" target="_self" rel="noopener">x.wait</a>及<a class="internal-link" data-href="x.signal.md" href="/考研筆記/作業系統/ch6-process-synchronization/x.signal.html" target="_self" rel="noopener">x.signal</a>
<br>所需之共享變數<br>
<br>Semephore mutex = 1;
<br>monitor的互斥閥
<br>Semephore next = 0;<br>
卡救命恩人
<br>int next-count = 0;<br>
統計救命恩人個數，確認還有沒有救命恩人
<br>Semephore x-sem = 0;<br>
用以卡Q
<br>int x-count = 0;<br>
統計Q的個數
<br>製作碼<br>Code保障互斥
//保障互斥
function P1(){
	wait(mutex);
	// Body //
	if(next-count &gt; 0){
		signal(next);
	}else{
		siganl(mutex);
	}
}
複製
Condition 變數
x.wait:
x-count = x-count +1;
if(next-count &gt; 0){
	signal(next);
}else{
	signal(mutex);
}
wait(x-sem);
x-count = x-count - 1;
複製
x.signal:
if(x-count &gt; 0){
	next-count = next-count + 1;
	signal(x-sem);
	wait(next);
	// P 被救
	next-count = next-count - 1;
}
複製<br>證明Monitor與semephore解決同步問題的能力是相當的Ans:因為monitor與semephore是可以相互來製作的。<br>
以<a class="internal-link" data-href="#Type1(Hoare monitor)" href="/#Type1(Hoare_monitor)" target="_self" rel="noopener">Hoare monitor</a>為例<br>
基本上就是一個類別(Class)<br><br>用Message-Passing<br>
解決<a class="internal-link" data-href="Producer-Consumer Problem.md" href="/考研筆記/作業系統/ch6-process-synchronization/producer-consumer-problem.html" target="_self" rel="noopener">Producer-Consumer Problem</a><br><br><br>Direct(Asymmetric)  送方指名送訊息，收方不指名<br><br>
表達出synchronization mode
<br>法一：<br>
使用<a class="internal-link" data-href="Link capacity.md" href="/考研筆記/作業系統/ch6-process-synchronization/link-capacity.html" target="_self" rel="noopener">Link capacity</a><br>
法二:：<br>
使用Blocking/Non-Blocking之send recevie<br>
<br>Blocking Send 送方要等回信
<br>nonBlocking Send 一直送，不用等回信
<br>Blocking Receive 等信送來再做
<br>nonBlocking Receive 不用等信
]]></description><link>考研筆記/作業系統/ch6-process-synchronization/ch6-process-synchronization.html</link><guid isPermaLink="false">考研筆記/作業系統/Ch6  Process Synchronization/Ch6  Process Synchronization.md</guid><pubDate>Sun, 17 Mar 2024 10:53:25 GMT</pubDate><enclosure url="lib/media/b7d02ba1-895a-4a0b-b762-8f43df2159c4.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib/media/b7d02ba1-895a-4a0b-b762-8f43df2159c4.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Compare-and-Swap]]></title><description><![CDATA[<a class="tag" href="?query=tag:❌" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#❌</a> <a class="tag" href="?query=tag:✅" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#✅</a> 
 <br>(Test-and-Set做修改)<br>
定義：
int Compare_and_swap(int *value, int expected, int new_value){  
	int temp = *value;  
	if(*value == expected)  
		*value = new_value;  
	return temp;  
}  
複製
<br><br>
如果value == expected 則value改為new_value<br>
否則不動<br>
一律傳回*value舊值<br><br>while(true){
	while(compare_and_swap(&amp;Lock, 0, 1) != 𝜙 );
	C.S.
	Lock=𝜙
	R.S.
}
複製<br>分析：<br>
<br>Mutual exclusion :OK
<br>Progress：ＯＫ
<br>Bounded waiting 違反<br>
若Pi離開C.S後又想進入C.S，Pi有可能先於其他processes再度進入C.S<br>
=&gt;<a class="internal-link" data-href="../CH4 Process Management &amp; Tread Management/starvation.md" href="/考研筆記/作業系統/ch4-process-management-&amp;-tread-management/starvation.html" target="_self" rel="noopener">starvation</a>
<br><br><a class="internal-link" data-href="Test-and-Set.md#Algo2 ✅" href="/考研筆記/作業系統/ch6-process-synchronization/test-and-set.html#Algo2_✅" target="_self" rel="noopener">Test-and-Set的Algo2換成用compare-and-swap</a>]]></description><link>考研筆記/作業系統/ch6-process-synchronization/compare-and-swap.html</link><guid isPermaLink="false">考研筆記/作業系統/Ch6  Process Synchronization/Compare-and-Swap.md</guid><pubDate>Mon, 04 Mar 2024 08:07:51 GMT</pubDate></item><item><title><![CDATA[Counting Semaphore]]></title><description><![CDATA[ 
 <br>
定義：

<br>號誌值不限0, 1
<br>可以是負值
<br>且若值為 -N代表有N個processes卡在wait中

<br><br>共享變數宣告：<br>
<br>int C;
<br>Binary-Semaphore S1 = 1;<br>
對C做互斥存取，防止C的data race
<br>Binary-Semaphore S2 = 𝜙<br>
卡住process用，if C &lt; 0
<br><img src="/lib/media/截圖-2022-12-25-下午8.32.44.jpg">]]></description><link>考研筆記/作業系統/ch6-process-synchronization/counting-semaphore.html</link><guid isPermaLink="false">考研筆記/作業系統/Ch6  Process Synchronization/Counting Semaphore.md</guid><pubDate>Mon, 04 Mar 2024 08:07:25 GMT</pubDate><enclosure url="lib/media/截圖-2022-12-25-下午8.32.44.jpg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib/media/截圖-2022-12-25-下午8.32.44.jpg&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Hardware instructions]]></title><description><![CDATA[ 
 <br>不可被中斷的機器指令，保證“atomiclly” executed.<br>
<br><a class="internal-link" data-href="Test-and-Set.md" href="/考研筆記/作業系統/ch6-process-synchronization/test-and-set.html" target="_self" rel="noopener">Test-and-Set</a>
<br><a class="internal-link" data-href="Compare-and-Swap.md" href="/考研筆記/作業系統/ch6-process-synchronization/compare-and-swap.html" target="_self" rel="noopener">Compare-and-Swap</a>
]]></description><link>考研筆記/作業系統/ch6-process-synchronization/hardware-instructions.html</link><guid isPermaLink="false">考研筆記/作業系統/Ch6  Process Synchronization/Hardware instructions.md</guid><pubDate>Mon, 04 Mar 2024 08:07:07 GMT</pubDate></item><item><title><![CDATA[Link capacity]]></title><description><![CDATA[ 
 <br>
定義：<br>
在每一條Communication link 皆附屬有一個messages Queue, 除了正在傳輸的訊息之外，其他sender送出之messages皆放在此Queue中  
<br>這個Queue的大小即為Link Capacity<br>收方 必等<br>
「一律規定：要收到message後才可往下執行。」<br>送方<br>
由Link Capacity決定sync mode<br>
<br><a class="internal-link" data-href="Zero capacity.md" href="/考研筆記/作業系統/ch6-process-synchronization/zero-capacity.html" target="_self" rel="noopener">Zero capacity</a> 送方要等回覆
<br><a class="internal-link" data-href="Bounded capacity.md" href="/考研筆記/作業系統/ch6-process-synchronization/bounded-capacity.html" target="_self" rel="noopener">Bounded capacity</a> 送到對方信箱已滿
<br><a class="internal-link" data-href="unBounded capacity.md" href="/考研筆記/作業系統/ch6-process-synchronization/unbounded-capacity.html" target="_self" rel="noopener">unBounded capacity</a> 送就對了
]]></description><link>考研筆記/作業系統/ch6-process-synchronization/link-capacity.html</link><guid isPermaLink="false">考研筆記/作業系統/Ch6  Process Synchronization/Link capacity.md</guid><pubDate>Wed, 13 Mar 2024 09:19:54 GMT</pubDate></item><item><title><![CDATA[Liveness]]></title><description><![CDATA[ 
 <br>
process may have to wait indefinitely while trying to acquire a synchronization tool such as a <a class="internal-link" data-href="mutex lock.md" href="/考研筆記/作業系統/ch6-process-synchronization/mutex-lock.html" target="_self" rel="noopener">mutex lock</a> or semaphore waiting indefinitely violates the progress and bounded-waiting crteria  
所以 Liveness: refers to a set of properties that a system must satisfy to ensure processes make progress 而indefinite waiting is an example of a "Liveness failure"  
<br>例2(deadlock)	wait(mutex);
	C.S
	wait(mutex);
複製<br>例3 (可能形成deadlock)S1 = 1, S2  = 1
Pi(){
	wait(S1)
	wait(S2)
	...
	signal(S1)
	signal(S2)
}

Pj(){
	wait(S2)
	wait(S1)
	...
	signal(S2)
	signal(S1)
}
複製<br>例：上述之deadlock case&nbsp;<br>
例：starvation 也是失敗之例]]></description><link>考研筆記/作業系統/ch6-process-synchronization/liveness.html</link><guid isPermaLink="false">考研筆記/作業系統/Ch6  Process Synchronization/Liveness.md</guid><pubDate>Wed, 13 Mar 2024 09:22:11 GMT</pubDate></item><item><title><![CDATA[Memory barrier(or memory Fence)]]></title><description><![CDATA[ 
 <br><br>確保順序，內容改變必須讓其他processors知道<br>
很多硬體提供一種指令強迫(force)任何memory, 內容改變必須讓其他processors知道, 此指令叫"memory barriers/fence"

<br>在後續的operation load前，要確保前面的operation is completed
<br>typically only used by kernel developer 

<br>
<br><a class="internal-link" data-href="Strongly ordered.md" href="/考研筆記/作業系統/ch6-process-synchronization/strongly-ordered.html" target="_self" rel="noopener">Strongly ordered</a>
<br><a class="internal-link" data-href="Weakly ordered.md" href="/考研筆記/作業系統/ch6-process-synchronization/weakly-ordered.html" target="_self" rel="noopener">Weakly ordered</a>
<br>應用例子<br>
memorybarrier前的operation一定要保持在memorybarrier前
<br>//thread1
//保證flag value is loaded before 'x'
while (!flag){
	memory_barrier();
	print(x);
}
複製<br>//thread2:
//保證x的assignment 先於flag assignment
x=100;
memory_barrier();
flag = true
複製]]></description><link>考研筆記/作業系統/ch6-process-synchronization/memory-barrier(or-memory-fence).html</link><guid isPermaLink="false">考研筆記/作業系統/Ch6  Process Synchronization/Memory barrier(or memory Fence).md</guid><pubDate>Mon, 04 Mar 2024 08:06:41 GMT</pubDate></item><item><title><![CDATA[解決Dining-philosophers problem]]></title><description><![CDATA[ 
 <br><br>Monitor Dining-ph{
	enum{thinking, hungry,
	eating}state[5];
	Condition self[5];

	void pickup(int i){
		state[i] = hungry;
		test(i);
		if(state[i] != eating) self[i].wait;
	}
	void test{
		if(state[(i+4)%5] != eating &amp;&amp; state[i] == hungry &amp;&amp; state[(i+1)%5]!= eating){
		// 我可以吃飯
			state[i] = eating;
			self[i].signal;
		}
	}
	void putdown(int i){
		state[i]= thinking;
		test((i+4)%5);
		test((i+1)%5);
	}
	initialization_code(){
		for(int i = 𝜙; i&lt; 5; i++){
			state[i] = thinking;
		}
	}
}
複製<br>使用方式：<br>//宣告一個共享變數<br>
Dining-ph dp;<br>
while<br> //Pi code如下  
while(true){  
	 hungry now;  
	 dp.pickup(I);  
	 eating now;  
	 dp.putdown(I);  
	 thinking now;  
}
複製<br><br>Monitor ResourceAllocation{
	Boolean busy;
	Condition x;
	void Acquire(int time){
		if(busy)
			x.wait(time);
		busy =true;
	}
	void Release(){
		busy = false;
		x.signal
	}
	initialization_code(){
		busy = false;
	}
}
複製<br>使用方式：<br>ResourceAllocation R;

time = t
…
R.Acquire(t);
//使用resource now
R.Release();
…
複製<br>此處的monitor內之x的waiting Queue 及monitor的entry queue 皆是priority queue（time越小priority越高）<br><br>Monitor Fileread{
	int sum;
	Condition x;
	void RFile(int I){
		while(sum+I &gt;=n)
			x.wait;
		sum = sum +I;
	}
	void Left(int i){
		sum = sum - i;
		x.signal;
	}
	initialization_code(){
		sum = 0;
	}
}
複製<br>宣告<br>Fileread FR;

Pi code:
…
FR.RFile(i);
reading this file;
FR.Left(i);
…
複製<br>有一個read-only file 可被多個processes讀取但規定：<br>
正在存取的這些processes.ID加總必須&lt;n才可讀取，否則wait<br>
Process.ID小的優先權大]]></description><link>考研筆記/作業系統/ch6-process-synchronization/monitor應用例子.html</link><guid isPermaLink="false">考研筆記/作業系統/Ch6  Process Synchronization/Monitor應用例子.md</guid><pubDate>Wed, 13 Mar 2024 09:20:47 GMT</pubDate></item><item><title><![CDATA[mutex lock]]></title><description><![CDATA[ 
 <br>用於c.s design<br>
~~利用busy waiting 實作的高階軟體工具 -&gt; ~~<br>
OS提供一個higher-level software tool給Application programer 使用

<br>起因：之前hardware-based solutions to the c.s. problem 太複雜，且inaccesible to Application programmers
<br>OS designers建立一個 high-level Software tools to solve the c.s. problem 其中最簡單的一種是mutex lock


提供兩個 atomic functions:<br>
Available 是共享變數，初值為true

<br><a class="internal-link" data-href="acquire.md" href="/考研筆記/作業系統/ch6-process-synchronization/acquire.html" target="_self" rel="noopener">acquire</a>
<br><a class="internal-link" data-href="release.md" href="/考研筆記/作業系統/ch6-process-synchronization/release.html" target="_self" rel="noopener">release</a>

一個上鎖，一個歸還鑰匙（開鎖）
<br>缺點<br>
因為是busy waiting -&gt;可能會浪費cpu time<br>
此種busy waiting 之mutex lock 也叫spin lock，但也有好處，即no context switch is required&nbsp; when a process must wait on a lock]]></description><link>考研筆記/作業系統/ch6-process-synchronization/mutex-lock.html</link><guid isPermaLink="false">考研筆記/作業系統/Ch6  Process Synchronization/mutex lock.md</guid><pubDate>Wed, 13 Mar 2024 09:21:36 GMT</pubDate></item><item><title><![CDATA[non-busy waiting semaphore]]></title><description><![CDATA[ 
 <br>放到ready queue<br>
不用互斥所&amp;用Block, wakeup替代互斥所 的<a class="internal-link" data-href="Counting Semaphore.md" href="/考研筆記/作業系統/ch6-process-synchronization/counting-semaphore.html" target="_self" rel="noopener">Counting Semaphore</a><br>
將semaphore變成一個struct type 如下：  
<br>struct semaphore{  
	int value;  
	Queue Q;  
};
複製<br><img src="/lib/media/截圖-2022-12-25-下午8.40.53.jpg"><br>down 到製作層次<br>
<br>看不到B. waiting<br>
-&gt; 但不適用於multiprocessors且風險高
<br>C.S desgin:<br>
Entry code中皆是B. waiting<br>
-&gt; 沒有辦法避免B. waiting
]]></description><link>考研筆記/作業系統/ch6-process-synchronization/non-busy-waiting-semaphore.html</link><guid isPermaLink="false">考研筆記/作業系統/Ch6  Process Synchronization/non-busy waiting semaphore.md</guid><pubDate>Mon, 04 Mar 2024 08:06:50 GMT</pubDate><enclosure url="lib/media/截圖-2022-12-25-下午8.40.53.jpg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib/media/截圖-2022-12-25-下午8.40.53.jpg&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[原始程式]]></title><description><![CDATA[<a class="tag" href="?query=tag:⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️</a> 
 <br>
描述：

<br>Producer: 生產資訊給別人使用之processes
<br>Consumer:消耗/使用 生產者產出之資訊的process

在shared memory 溝通方式下，雙方會共用一個buffer
Bounded Buffer

<br>當buffer沒有空格，則Producer被迫wait
<br>當buffer沒有資料，則Consumer被迫wait

unBounded Buffer

<br>Producer不會被迫等待
<br>if no data ,consumer wait

<br><br>
共享變數：<br>
Buffer[0..n-1]<br>
in, out = 0<br>
count = 0
Producer: count ++<br>
Consumer:count --<br>
但count可能有race condition問題
<br>Producer<br>//Producer
while(true){
	"produce an item in nextp"
	while(count == N)
		{}; //producer wait
	buffer[in] = nextp;
	in = (in+1)%N;
	count ++;
}
複製<br>Consumer<br>//Consumer
while(true){
	while(count == 0)
		{};  //buffer 內沒有資料
	nextc = buffer[out];
	out = (out+1)%n;
	count--; //item 數少1
	"consume the item"
}
複製<br><br>先測同步，再測互斥<br>
共享變數：<br>
<br>Buffer[0..n-1]
<br>in, out = 0
<br>semaphore mutex = 1;<br>
作為buffer, in, out之互斥控制用，防止race condition
<br>semaphore empty = n<br>
代表buffer內空格數(需不需要produce item)，當empty = 0表示無空間（滿），卡住Producer之用
<br>semaphore full = 0<br>
代表Buffer內item數，當full = 0表示無item可取用-&gt;卡Consumer之用
<br>Producer<br>//Producer
while(true){
	"produce an item in nextp"
	wait(empty);//是否坐滿位子
	wait(mutex);//搶奪buffer的使用權
	"add nextp into Buffer"
	signal(mutex):
	signal(full);  // item已填入buffer，可救/供給Consumer
}
複製<br>Consumer<br>while(true){
	wait(full);//等待資源
	wait(mutex);//搶奪buffer（才可以使用）
	"retrieve an item in nextc from buffer"
	signal(mutex);
	signal(empty);// 消耗掉item，讓producer有空間可以製作
	"consume the nextc"
}
複製<br>若將Producer or Consumer其中一個（或雙方）process，將前面兩個wait對調，依舊正確嗎？Why?錯：可能產生Deadlock。一人搶走mutex，等待資源/空間，另一人在等著使用mutex，以填入/拿出data<br><br>滿足同步條件之用<br>
<br>empty
<br>full
<br>防止共享data之race condition（要mutual exclusion之用）<br>
<br>Buffer
]]></description><link>考研筆記/作業系統/ch6-process-synchronization/producer-consumer-problem.html</link><guid isPermaLink="false">考研筆記/作業系統/Ch6  Process Synchronization/Producer-Consumer Problem.md</guid><pubDate>Mon, 04 Mar 2024 08:06:51 GMT</pubDate></item><item><title><![CDATA[Race condition]]></title><description><![CDATA[ 
 <br>Race condition<br>
定義：若多個process使用shared variable 溝通，若未對這些共享變數之read/write提供任何synchronization 控制機制，則共享變數之最終值可能會因processes之間的交錯執行順序不同而有不同的結果值，此一Data in consistency 之問題， 稱之
<br>例：假設C是共享變數，初值=5]]></description><link>考研筆記/作業系統/ch6-process-synchronization/race-condition.html</link><guid isPermaLink="false">考研筆記/作業系統/Ch6  Process Synchronization/Race condition.md</guid><pubDate>Wed, 13 Mar 2024 09:22:36 GMT</pubDate></item><item><title><![CDATA[First <a href="?query=tag:%E2%AD%90%EF%B8%8F%E2%AD%90%EF%B8%8F%E2%AD%90%EF%B8%8F%E2%AD%90%EF%B8%8F%E2%AD%90%EF%B8%8F" class="tag" target="_blank" rel="noopener">#⭐️⭐️⭐️⭐️⭐️</a>]]></title><description><![CDATA[<a class="tag" href="?query=tag:⭐️⭐️⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️⭐️⭐️</a> <a class="tag" href="?query=tag:⭐️⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️⭐️</a> 
 <br>

<br>reader:只會reading共享data之process
<br>writer:會更新/寫入共享data值之process

基本的同步條件

<br>writer &amp;reader之間要互斥
<br>writer &amp; writer之間要互斥
<br>reader 之間不用互斥

<br><br>reader 有利<br>
對reader有利，writer不利<br>
-&gt;writer可能starvation
if有reader is reading, 又來了一個reader，則下一個reader也進去reading，直到沒有reader，writer才能進去
<br><br>
reader(第一個）一進去就先卡writer
<br>共享變數：<br>
<br>semaphore wrt = 1;<br>
作為R/W及W/W互斥控制用，此外兼作
<br>int readcnt = 0<br>
統計目前reader個數
<br>semaphore mutex = 1;<br>
對readcnt存取之互斥控制，防止他race condition
<br>Writer<br>...
wait(wrt);
執行writing;
signal(wrt)
...
複製<br>Reader<br>
<br>readcnt++(要先<a class="internal-link" data-href="mutex lock.md" href="/考研筆記/作業系統/ch6-process-synchronization/mutex-lock.html" target="_self" rel="noopener">mutex lock</a>)
<br>檢查是否是第一個，是的話wait(wrt)
<br>...
wait(mutex);
readcnt = readcnt + 1;
if(readcnt == 1){    //成立表示你是第一個reader
	wait(wrt);   
	//若是有wrt，則會卡在這裡等當下的wrt完成，在設立阻擋
}
signal(mutex);
"執行Reading"
wait(mutex)
readcnt = readcnt - 1
if(readcnt == 0){   //自己是最後一個reader才能釋放
	signal(wrt)
}
signal(mutex)
...
複製<br><br>writer有利<br>
對writer有利，reader不利<br>
-&gt;reader可能starvation
writer優先於reader（即使reader比較早進來等）
<br><br>

<br>+1
<br>築牆（不讓reader進入）
<br>w/w互斥，然後執行
<br>if沒有writer了，解除阻擋

<br>共享變數：<br>
<br>int readcnt = 0<br>
統計目前reader個數
<br>semaphore mutex = 1;<br>
對readcnt存取之互斥控制，防止他race condition
<br>semaphore wrt = 1;<br>
作為R/W及W/W互斥控制
<br>int wrtcnt = 0;<br>
統計writer個數<br>
writer到 -&gt; 加1, writer走 -&gt; -1
<br>semaphore y = 1;<br>
對wrtcnt之互斥控制防止race.
<br>semaphore rsem = 1;<br>
對Reader不利之阻擋
<br>semaphore z = 1;（可有可無）<br>
reader之入口控制<br>
目的：多卡一關，delay reader's speed
<br>Reader<br>wait(z);
wait(rsem);   //可否通過對reader不利之阻擋
wait(mutex);
readcnt = readcnt + 1;
if(readcnt == 1)
	wait(wrt);
signal(mutex);
signal(rsem);
signal(z);
"執行reading"
wait(mutex);
readcnt = readcnt - 1;
if(readcnt == 0)
	signal(wrt);
signal(mutex);
複製<br>Writer<br>
注意y的位置<br>wait(y);
wrtcnt = wrtcnt + 1;
if(wrtcnt == 1){
	wait(rsem)  //築起對reader不利之阻擋
}
signal(y);
wait(wrt);   // w/w互斥
"執行writing"
wait(y);
wrtcnt = wrtcnt - 1;
if(wrtcnt == 0){  //沒有writer，解除阻擋
	signal(rsem);
}
signal(wrt);
signal(y);
複製]]></description><link>考研筆記/作業系統/ch6-process-synchronization/reader,writer-problem.html</link><guid isPermaLink="false">考研筆記/作業系統/Ch6  Process Synchronization/Reader,Writer problem.md</guid><pubDate>Mon, 04 Mar 2024 08:07:08 GMT</pubDate></item><item><title><![CDATA[release]]></title><description><![CDATA[ 
 <br>release(Available){
	Available = true;
}
複製]]></description><link>考研筆記/作業系統/ch6-process-synchronization/release.html</link><guid isPermaLink="false">考研筆記/作業系統/Ch6  Process Synchronization/release.md</guid><pubDate>Wed, 13 Mar 2024 09:22:50 GMT</pubDate></item><item><title><![CDATA[Semaphore]]></title><description><![CDATA[ 
 <br>Semaphore(號誌）<br>
定義：<br>
synchronization tool that provides more sophisticated way(than <a class="internal-link" data-href="mutex lock.md" href="/考研筆記/作業系統/ch6-process-synchronization/mutex-lock.html" target="_self" rel="noopener">mutex lock</a>) for process synchronize their activities.
-&gt;semaphore 是一個data type，若S為semaphore type 變數，則S是一個integer，且在S上會提供2個"atomic" operations :&nbsp;

<br><a class="internal-link" data-href="wait.md" href="/考研筆記/作業系統/ch6-process-synchronization/wait.html" target="_self" rel="noopener">wait</a>(S)
<br><a class="internal-link" data-href="signal.md" href="/考研筆記/作業系統/ch6-process-synchronization/signal.html" target="_self" rel="noopener">signal</a>(S)

<br><br>共享變數宣告。semaphore mutex = 1;(初值)<br>
P𝒾程式如下<br>while(True){
	wait(mutex);
	C.S.
	signal(mutex);
	R.S.
}
複製<br><br>何為sync? 互相協作時，因為某事件發生/未發生，而被迫停頓<br>
一群cooperating processes/Threads 在執行中，弱process因為某事件發生/不發生 而被迫wait，等其他processes do something 才可往下執行
<br>simple problem<br>
Pi中的A必須在Pj中的B先執行完成此要求
<br>//Pi
A;
signal(S);
//------
//Pj
wait(S);
B;
複製<br><br>
導致違反mutual exclusion 或形成deadlock
<br>例1 (違反互斥)	semaphore mutex = 1;
	signal(mutex)
	C.S.
	wait(mutex)
	R.S.
複製<br>例2(deadlock)	wait(mutex);
	C.S
	wait(mutex);
複製<br>例3 (可能形成deadlock)S1 = 1, S2  = 1
Pi(){
	wait(S1)
	wait(S2)
	...
	signal(S1)
	signal(S2)
}

Pj(){
	wait(S2)
	wait(S1)
	...
	signal(S2)
	signal(S1)
}
複製<br><a class="internal-link" data-href="Liveness.md" href="/考研筆記/作業系統/ch6-process-synchronization/liveness.html" target="_self" rel="noopener">Liveness</a><br><br><br><br><br><br><a class="internal-link" data-href="Ch6  Process Synchronization.md#Race condition 兩大策略" href="/考研筆記/作業系統/ch6-process-synchronization/ch6-process-synchronization.html#Race_condition_兩大策略" target="_self" rel="noopener">Race condition 兩大策略</a><br>
分析<br><br>Algo1signal(S):  
    "Disable interrupt"  
    S.value = S.value+1;  
    if(S.value &lt;= 0)then{  
		remove process P from S.Q  
		Wakeup(P); // sys. call 用以將Ｐ移到ready state  
    }  
    "Enable interrupt"
    
wait(S):  
    "Disable interrupt"S.value = S.value-1;  
    if(S.value &lt; 0)then{  
		add process P into S.Q  
		Block(P); // sys. call 用以將Ｐ移到wait state  
    }else{  
		"Enable interrupt"
	}
複製<br>Algo2signal(S):  
	"Disable interrupt"  
    S = S +1  
    "Enable interrupt"
wait(S):  
    "Disable interrupt"  
    while(S&lt;= 0){  
		"Enable interrupt"  
		"Disable interrupt"  
    }  
    S = S-1;  
	"Enable interrupt**
複製<br>結論：<br>
non-busy waiting並不能完全避免busy waiting
<br>down 到製作層次<br>
<br>看不到B. waiting<br>
-&gt; 但不適用於multiprocessors且風險高
<br>C.S desgin:<br>
Entry code中皆是B. waiting<br>
-&gt; 沒有辦法避免B. waiting
]]></description><link>考研筆記/作業系統/ch6-process-synchronization/semaphore.html</link><guid isPermaLink="false">考研筆記/作業系統/Ch6  Process Synchronization/Semaphore.md</guid><pubDate>Wed, 13 Mar 2024 09:21:51 GMT</pubDate></item><item><title><![CDATA[signal]]></title><description><![CDATA[ 
 <br>//V(S)
signal(S){
	S = S+ 1
}
複製]]></description><link>考研筆記/作業系統/ch6-process-synchronization/signal.html</link><guid isPermaLink="false">考研筆記/作業系統/Ch6  Process Synchronization/signal.md</guid><pubDate>Wed, 13 Mar 2024 09:23:06 GMT</pubDate></item><item><title><![CDATA[Strongly ordered]]></title><description><![CDATA[ 
 <br><br>
定義：<br>
對於memory修改on one processor is immediately visible to all other processors
]]></description><link>考研筆記/作業系統/ch6-process-synchronization/strongly-ordered.html</link><guid isPermaLink="false">考研筆記/作業系統/Ch6  Process Synchronization/Strongly ordered.md</guid><pubDate>Mon, 04 Mar 2024 08:07:57 GMT</pubDate></item><item><title><![CDATA[Test-and-Set]]></title><description><![CDATA[<a class="tag" href="?query=tag:❌" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#❌</a> <a class="tag" href="?query=tag:✅" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#✅</a> 
 <br><br>是privilege instruction<br>傳回target舊值，target設為true<br>boolean test_and_set(boolean *target){  
	boolean rv = *target;  
	*target = true;  
	return rv;  
}
複製<br><br>while(true){
	while(test_and_set(&amp;Lock)){ };
	C.S
	Lock = False;
	R.S.
}
複製<br>分析：<br>
<br>Mutual exclusion :OK
<br>Progress：ＯＫ
<br>Bounded waiting 違反<br>
若Pi離開C.S後又想進入C.S，Pi有可能先於其他processes再度進入C.S<br>
=&gt;<a class="internal-link" data-href="../CH4 Process Management &amp; Tread Management/starvation.md" href="/考研筆記/作業系統/ch4-process-management-&amp;-tread-management/starvation.html" target="_self" rel="noopener">starvation</a>
<br><br>
思路：<br>
先搶test-and-set 先進，隨機、公平<br>
自己進入C.S後改為沒有需求<br>
找下一位（不是自己 -&gt; 避免<a class="internal-link" data-href="../CH4 Process Management &amp; Tread Management/starvation.md" href="/考研筆記/作業系統/ch4-process-management-&amp;-tread-management/starvation.html" target="_self" rel="noopener">Starvation</a> -&gt; 避免Bounded waiting<br>
改變下一位的wait值，若沒其他人且自己有需求，拿回鑰匙
<br>do{
	waiting[i] = True
	key = True;
	while(waiting[i] and key){
		key= Test-and-set(&amp;Lock);
	}
	waiting[i] = False //避免第一個進入的process造成progress
	//...
	C.S.
	...//
	//找到下一個(並非隨機，是往下選）想進入C.S的process
	j = (i+ 1)% n;
	while(j!= i and !waiting[j]){
		j =(j+1)%n
	}
	//若有人想進，給他。否則再把鑰匙給自己
	if(j == i)then Lock = False;
	else waiting[j] = False; //-&gt;Pj離開while進入C.S
	R.S
}
複製<br>EX:移除<br>思考。移除“waiting[i] = False;” C.S. 會正確嗎不正確！！
第一個進入C.S的process可能會被誤認為「想進入」<br>
已違反Progress。無故佔用資源＆Deadlock(Lock是True)<br>分析：<br>
<br>Mutual exclusion :OK
說明Pi要進入C.S要滿足兩條件之一

<br>case1: Key == False<br>
代表是第一個搶到Test-and-set執行之process，才能將key改為false，否則key仍為True<br>
=&gt; 唯一性
<br>case2: waiting[i] == False<br>
Pi自己不會將自己的waiting[i]改成false before進入C.S，只有仰賴從C.S離開的Process才有資格改別人的waiting，且C.S只有一個process<br>
=&gt;唯一性


<br>Progress：ＯＫ
說明(i)若Pi不想進入-&gt;waiting[i] = false-&gt;不會爭奪test-and-set的執行<br>
(ii)若多個Process想進入c.s則在有限的時間內必有一個Process之key或waiting[i]被改為false而進入c.s<br>
-&gt; no deadlock

<br>Bounded waiting :OK
說明
<br>若P0~Pn-1皆想進入C.S。<br>
假設P0進入c.s，Lock=True-&gt;其他人不能進入c.s
<br>當P0離開後，一定會改變下一個（其他）想進入c.s的Process之waiting[i]為False.-&gt;P1進入
<br>以此類推，每個Process最多等n-1個就能進入c.s<br>
=&gt;no <a class="internal-link" data-href="../CH4 Process Management &amp; Tread Management/starvation.md" href="/考研筆記/作業系統/ch4-process-management-&amp;-tread-management/starvation.html" target="_self" rel="noopener">starvation</a>


<br>複製]]></description><link>考研筆記/作業系統/ch6-process-synchronization/test-and-set.html</link><guid isPermaLink="false">考研筆記/作業系統/Ch6  Process Synchronization/Test-and-Set.md</guid><pubDate>Wed, 13 Mar 2024 09:20:16 GMT</pubDate></item><item><title><![CDATA[正確solution]]></title><description><![CDATA[ 
 <br>
描述：

<br>有5位哲學家P0~P4吃晚餐，坐在圓桌，坐一圈
<br>兩兩哲學家之間放”一根“筷子
<br>哲學家必須取得左右兩塊子才能吃飯
<br>吃完放下筷子，進入thinking

<br>錯誤solutionP𝒾（第i號哲學家）
while(true){
	hungry now;
	wait(chopstick[i]);
	wait(chopstick[(i+1) % 5;]);
	eat now;
	signal(chopstick[i]);
	signal(chopstick[(i+1) % 5;]);
	think now;
}
複製
此soluton有誤因為可能發生deadlock，如果每位哲學家只取得左邊的筷子，則沒有一位可以拿到右邊的筷子<br><br><br>限制同一時間拿筷子的人數<br>說明若有5位哲學家，則至多允許4個哲學家上餐桌<br>
定理：

<br>m = 5（根） MAX𝒾 =2
<br>條件

<br>&nbsp;1 &lt;= MAX𝒾 &lt;= m
<br>&nbsp;MAX𝒾總和&lt; n+ m



控制總人數要&lt;n<br>//P𝒾（第i號哲學家）
semaphore No = 4
wait(No);
hungry now;
wait(chopstick[i]);
wait(chopstick[(i+1) % 5]);
eat now;
signal(chopstick[i]);
signal(chopstick[(i+1) % 5]);
signal(No);
think now;

複製<br><br>一次拿一雙筷子<br>說明規定“除非可以同時拿到兩隻筷子，才允許持有，否則不可持有任何筷子”。<br>
-&gt;破hold-and-wait<br><br>偶數先拿右，奇數先拿左<br>說明規定：”偶數號折學家，先取左邊的快子，再取右筷；奇數好相反“<br>
-&gt;破除circular waiting]]></description><link>考研筆記/作業系統/ch6-process-synchronization/the-dinning-philosophers-problem.html</link><guid isPermaLink="false">考研筆記/作業系統/Ch6  Process Synchronization/The Dinning-philosophers problem.md</guid><pubDate>Mon, 04 Mar 2024 08:06:40 GMT</pubDate></item><item><title><![CDATA[The sleeping Barber problem "理髮師睡覺問題"]]></title><description><![CDATA[ 
 <br>solution（程式）<br>
Barber<br>
while(true){<br>
wait(customer);<br>
wait(mutex);<br>
waiting = waiting - 1;<br>
signal(Barber); //表示我有空了，叫醒客人<br>
signal(mutex);<br>
"理髮"<br>
}<br>
務必先測同步再測互斥<br>
Customer<br>
wait(mutex);<br>
if(waiting &lt; n ){<br>
waiting = waiting + 1;<br>
signal(mutex);<br>
signal(customer);<br>
wait(Barber);  //理髮師在忙的話就會卡在這<br>
“被理髮中()”<br>
}else{   //滿座，不入店內<br>
signal(mutex);<br>
}]]></description><link>考研筆記/作業系統/ch6-process-synchronization/the-sleeping-barber-problem-&quot;理髮師睡覺問題&quot;.html</link><guid isPermaLink="false">考研筆記/作業系統/Ch6  Process Synchronization/The sleeping Barber problem &quot;理髮師睡覺問題&quot;.md</guid><pubDate>Sat, 02 Mar 2024 14:15:01 GMT</pubDate></item><item><title><![CDATA[The sleeping Barber problem 理髮師睡覺問題]]></title><description><![CDATA[ 
 <br>solution（程式）<br>
Barber<br>
while(true){<br>
wait(customer);<br>
wait(mutex);<br>
waiting = waiting - 1;<br>
signal(Barber); //表示我有空了，叫醒客人<br>
signal(mutex);<br>
"理髮"<br>
}<br>
務必先測同步再測互斥<br>
Customer<br>
wait(mutex);<br>
if(waiting &lt; n ){<br>
waiting = waiting + 1;<br>
signal(mutex);<br>
signal(customer);<br>
wait(Barber);  //理髮師在忙的話就會卡在這<br>
“被理髮中()”<br>
}else{   //滿座，不入店內<br>
signal(mutex);<br>
}]]></description><link>考研筆記/作業系統/ch6-process-synchronization/the-sleeping-barber-problem-理髮師睡覺問題.html</link><guid isPermaLink="false">考研筆記/作業系統/Ch6  Process Synchronization/The sleeping Barber problem 理髮師睡覺問題.md</guid><pubDate>Sun, 17 Mar 2024 11:08:22 GMT</pubDate></item><item><title><![CDATA[unBounded capacity]]></title><description><![CDATA[ 
 <br>
sender 無需被迫wait
]]></description><link>考研筆記/作業系統/ch6-process-synchronization/unbounded-capacity.html</link><guid isPermaLink="false">考研筆記/作業系統/Ch6  Process Synchronization/unBounded capacity.md</guid><pubDate>Mon, 04 Mar 2024 08:07:27 GMT</pubDate></item><item><title><![CDATA[wait]]></title><description><![CDATA[ 
 <br>//P(S)
wait(S){
	while(S&lt;= 0){};
	S = S- 1;
}
複製]]></description><link>考研筆記/作業系統/ch6-process-synchronization/wait.html</link><guid isPermaLink="false">考研筆記/作業系統/Ch6  Process Synchronization/wait.md</guid><pubDate>Wed, 13 Mar 2024 09:24:26 GMT</pubDate></item><item><title><![CDATA[Weakly ordered]]></title><description><![CDATA[ 
 <br><br>
may not be immediately visible to other processors
]]></description><link>考研筆記/作業系統/ch6-process-synchronization/weakly-ordered.html</link><guid isPermaLink="false">考研筆記/作業系統/Ch6  Process Synchronization/Weakly ordered.md</guid><pubDate>Wed, 13 Mar 2024 09:22:38 GMT</pubDate></item><item><title><![CDATA[x.signal]]></title><description><![CDATA[ 
 <br>「下一位！請進」！<br>
定義：如果先前有process卡在x的waiting queue中，則此process會自queue取得一process並執行它（沒有process則無作用）
]]></description><link>考研筆記/作業系統/ch6-process-synchronization/x.signal.html</link><guid isPermaLink="false">考研筆記/作業系統/Ch6  Process Synchronization/x.signal.md</guid><pubDate>Wed, 13 Mar 2024 09:22:14 GMT</pubDate></item><item><title><![CDATA[x.wait]]></title><description><![CDATA[ 
 <br>「沒位子了！排隊吧！」<br>
定義：執行此operation的process會被暫停且將他置入x所屬的Waiting Queue 中(FIFO)
]]></description><link>考研筆記/作業系統/ch6-process-synchronization/x.wait.html</link><guid isPermaLink="false">考研筆記/作業系統/Ch6  Process Synchronization/x.wait.md</guid><pubDate>Wed, 13 Mar 2024 09:23:12 GMT</pubDate></item><item><title><![CDATA[Zero capacity]]></title><description><![CDATA[ 
 <br>
送方送出訊息後，一定要等到收方收到訊息才可往下執行。<br>
此mode又叫「rendezvous」[法文]
]]></description><link>考研筆記/作業系統/ch6-process-synchronization/zero-capacity.html</link><guid isPermaLink="false">考研筆記/作業系統/Ch6  Process Synchronization/Zero capacity.md</guid><pubDate>Wed, 13 Mar 2024 09:19:55 GMT</pubDate></item><item><title><![CDATA[Best-Fit]]></title><description><![CDATA[ 
 <br>
必須檢視所有的holes找出可以放入process的最小hole
]]></description><link>考研筆記/作業系統/ch7-memory-management/best-fit.html</link><guid isPermaLink="false">考研筆記/作業系統/CH7 Memory Management/Best-Fit.md</guid><pubDate>Wed, 13 Mar 2024 09:25:40 GMT</pubDate></item><item><title><![CDATA[Binding]]></title><description><![CDATA[<a class="tag" href="?query=tag:⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️</a> 
 <br>Binding <a href=".?query=tag:⭐️" class="tag" target="_blank" rel="noopener">#⭐️</a><br>
定義：決定Process執行在Memory的起始位置
<br>時間點（由誰做）<br>
<br>Compiling Time: compiler負責。若知道執行位置-&gt;absolute code，若不知道未來執行位置-&gt;Relocatable code
<br>Loading Time：<a class="internal-link" data-href="Linking loader.md" href="/考研筆記/作業系統/ch7-memory-management/linking-loader.html" target="_self" rel="noopener">Linking loader</a>負責
<br>Execution Time(<a class="internal-link" data-href="Dynamic Binding.md" href="/考研筆記/作業系統/ch7-memory-management/dynamic-binding.html" target="_self" rel="noopener">Dynamic Binding</a>):拖到(delay)執行時期，由OS動態決定。
]]></description><link>考研筆記/作業系統/ch7-memory-management/binding.html</link><guid isPermaLink="false">考研筆記/作業系統/CH7 Memory Management/Binding.md</guid><pubDate>Wed, 13 Mar 2024 09:27:31 GMT</pubDate></item><item><title><![CDATA[<a class="internal-link" data-href="Binding.md" href="考研筆記/作業系統/ch7-memory-management/binding.html" target="_self" rel="noopener">Binding</a> <a href="?query=tag:%E2%AD%90%EF%B8%8F" class="tag" target="_blank" rel="noopener">#⭐️</a>]]></title><description><![CDATA[<a class="tag" href="?query=tag:⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️</a> <a class="tag" href="?query=tag:⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️</a> <a class="tag" href="?query=tag:⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️</a> <a class="tag" href="?query=tag:⭐️⭐" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐</a> <a class="tag" href="?query=tag:⭐️⭐️⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️⭐️⭐️</a> <a class="tag" href="?query=tag:⭐️⭐️⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️⭐️⭐️</a> <a class="tag" href="?query=tag:⭐️⭐️⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️⭐️⭐️</a> <a class="tag" href="?query=tag:⭐️⭐️⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️⭐️⭐️</a> <a class="tag" href="?query=tag:⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️</a> 
 <br>Hintmemory和Disk之間的銜接方式

<br>Binding
<br>loading
<br>linking （執行時間才會需要載入）

memory 

<br>contiguous allocation management

問題

<br>內/外碎

page management

<br>logical -&gt; physical
<br>page table種類
<br>page table size太大問題

segment<br><br><br><br><br>

<br>process 載入到memory中執行, 他必須佔用一塊“連續的”Memory space
<br>此process佔用的space也叫Partition
<br>通常Partition size是變動的，也叫"variable partition"
<br>Partition 的數目即是Processes數目，也就是Multiprogramming Degree
<br>Processes多次的配置予釋放後，會有一些空間是free稱為hole

<br>
<br><a class="internal-link" data-href="First Fit.md" href="/考研筆記/作業系統/ch7-memory-management/first-fit.html" target="_self" rel="noopener">First Fit</a>
<br><a class="internal-link" data-href="Best-Fit.md" href="/考研筆記/作業系統/ch7-memory-management/best-fit.html" target="_self" rel="noopener">Best-Fit</a>
<br>Worst-Fit
<br>上述這些Contiguius Allocation methods 均遭遇一個共通問題，即<a class="internal-link" data-href="External Fragmentation(外部碎裂).md" href="/考研筆記/作業系統/ch7-memory-management/external-fragmentation(外部碎裂).html" target="_self" rel="noopener">External Fragmentation(外部碎裂)</a><br><br>分為：<br>
<br><a class="internal-link" data-href="External Fragmentation(外部碎裂).md" href="/考研筆記/作業系統/ch7-memory-management/external-fragmentation(外部碎裂).html" target="_self" rel="noopener">External Fragmentation(外部碎裂)</a> <a href=".?query=tag:⭐️⭐️⭐️⭐️⭐️" class="tag" target="_blank" rel="noopener">#⭐️⭐️⭐️⭐️⭐️</a>
<br><a class="internal-link" data-href="Internal Fragmentation (內部碎裂).md" href="/考研筆記/作業系統/ch7-memory-management/internal-fragmentation-(內部碎裂).html" target="_self" rel="noopener">Internal Fragmentation (內部碎裂)</a> <a href=".?query=tag:⭐️⭐️⭐️⭐️⭐️" class="tag" target="_blank" rel="noopener">#⭐️⭐️⭐️⭐️⭐️</a>
<br><br><br>兩種方式<br>
<br><a class="internal-link" data-href="Compaction 技術.md" href="/考研筆記/作業系統/ch7-memory-management/compaction-技術.html" target="_self" rel="noopener">Compaction 技術</a> 移動執行中的process使其聚集形成一個連續的hole
<br><a class="internal-link" data-href="page.md" href="/考研筆記/作業系統/ch7-memory-management/page.html" target="_self" rel="noopener">page</a> 等分切割記憶體，process依照需求拿幾塊用-&gt;(不容易高好吃完n*page_size容量)
<br><br><br>硬體才是提升paging效能的關鍵技術<br><a class="internal-link" data-href="page.md" href="/考研筆記/作業系統/ch7-memory-management/page.html" target="_self" rel="noopener">page</a><br><br>
CPU產生的logical address為單一量，自動拆解成[P|d]<br>
其中<br>
P: page No.;<br>
d: page offset;
<br>
MMU依P查詢Page table取得此page所在的frame No:f<br>
Then, [f|d]即為physical address. =&gt;f*{page size}+ d
<br><br><br>優點：<br>
<br>速度快(不用Memory Access)
<br>缺點：<br>
<br>不適用在大型的process;
<br>增加context switch Time （if register較多。在C.S.要一起跟著換）。
<br><br>

<br>PTBR(Page  Table Base Register):紀錄Page table 在memory 之起始位址。
<br>PTLR(Page Table Length Register):紀錄page table size

NOTE:In PCB只記這兩個register即可
<br>優點：<br>
<br>適用於大型的process
<br>C.S Time較省（than[法ㄧ]）
<br>缺點：<br>
<br>額外多一次Memory Access
<br><br>(Translation-Lookaside-Buffer)或叫Associative registers<br>
保存page table 中經常被存取的page No.及其frame No.

<br>MMU會依P先到TLB search，若TLB Hit直接取得 f ，若TLB miss ，則MMU必須到memory去查詢page table取得 f&nbsp;
<br>之後，也會更新TLB不上miss的page No. 及 frame No.
<br>若TLB entry are full 則可以選擇一些entry 替換（LRU policy)

<br><img src="/lib/media/截圖-2022-12-27-上午11.01.56.jpg"><br>硬體
<br>Some TLBs 允許某些entries to be wire down ，代表這些entries 不可以被移出TLB。一般而言，TLB entries for key kernel code are wired down
<br>有些TLB會多儲存Address-space identifier(ASID)(紀錄Process ID) in each TLB entry. 就可以存放多個process的TLB內容
<br><br>page table entry 數量
= page table使用的空間/page table entry size 
= process使用的frame數`
複製<br>[型一]：使用TLB之EMAT求算<br>[型二]：Logical address 與physical address length(Bit 數) 計算“../../img/截圖 2022-12-27 上午11.04.57.jpg” could not be found.<br>[型三]：page table size相關計算page size= 8KB<br>
process size =1MB<br>
page table entry size = 4bytes<br>
求此process之page table size?

需要1MB/8KB = 2^7個pages<br>
所以有2^7個entry<br>
page table size = 2^7 \* 4B<br>[型四]：<a class="internal-link" data-href="#page table size 太大解法" href="/#page_table_size_太大解法" target="_self" rel="noopener">page table size 太大之解法的延伸運算</a><br>其他考題“../../img/截圖 2022-12-28 下午5.38.44.jpg” could not be found.<br>
“../../img/截圖 2022-12-28 下午5.39.03.jpg” could not be found.<br>
“../../img/截圖 2022-12-28 下午5.39.21.jpg” could not be found.<br><br><br><br>page table分層 -&gt; 載入table總量減少、慢<br>
不要一次將整個page table 抓到memory 中，而是將page table切成幾個小的pieces<br>
process執行時，載入部分的所需之page table內容，以有效降低所需的memory size<br>
例：2-level page table
<br>第一層page table找第一層page table<br>
第二層指到physical address<br><img src="/lib/media/截圖-2022-12-27-下午2.38.22.jpg"><br>
優點：<br>
縮減所需要之space<br>
缺點：<br>
Memory Access次數增加，EMAT更長<br><br>
將page table 視為hash table，具有相同的hash address 之page no. 及 frame no.會包裝成一個record，置入entry 中之link list&nbsp;<br>
NOTE:及每個entry採用chain方式處理overflow
<br>將來MMU logical&nbsp; address轉physical address過程如下<br><img src="/lib/media/截圖-2022-12-27-下午2.40.20.jpg"><br><br>What is Inverted page tableA global page table maintained by OS for all process<br>
In inverted page table, the number of entries is equal to the number of frames in the main memory<br>How Inverted page table convert a logical address to a physical address?search the page number and pid in inverted page table and get it's index. The index is the frame number in memory. 後續在加上offset及為physical address
壞處：太慢、無法共享<br>
好處：避免page table size過大<br>記錄每個frame(頁匡)所屬的process<br>
以physical Memory 為紀錄對象(非以process為對象) 若有n個frames則此表有n個entries （frame數量成為page table 的高度）<br>
每個entry紀錄 &lt;Process ID, Page No.&gt; 表示頁框被某個process之某page佔用，或是free（空白）
<br>
<br>整個系統keep一份表格
<br>ex: PA 的 page table a 的位址<br>search page對應的p的index即是frame的physical address前半<br><img src="/lib/media/截圖-2022-12-27-下午2.43.01.jpg"><br>例題“../../img/截圖 2022-12-27 下午2.46.01.jpg” could not be found.<br>優點<br>
<br>整個系統只有保持這一個表格(不是一個process一個table) -&gt; 解決page table size太大問題
<br>缺點<br>
<br>linear search 耗時
<br>喪失了memory sharing公用：因為PID不同，在memory 中共佔2份空間=&gt;無法共用
<br><br>

<br>physical memory 視為一個連續的可用空間
<br>logical memory視為一組segment 之集合, 且各段大小不一定相同

「segment 段」的觀點採取"logical" viewpoint
配置方式<br>
段與段可以是非連續性配置<br>
但就單一段而言、必須是連續性配置
<br>Logical Address轉physical Address<br>
<br>CPU產生出之Logical Address為兩個量［s|d]
<br>MMU 根據s查分段表，曲得該段的limit and base
<br>先check d&lt;limit?
<br>成立：physical address= base+d
<br><img src="/lib/media/截圖-2022-12-27-下午3.01.07.jpg"><br>
<br>支援memory sharing 及 memory protection
<br>支援<a class="internal-link" data-href="Dynamic loading.md" href="/考研筆記/作業系統/ch7-memory-management/dynamic-loading.html" target="_self" rel="noopener">dynamic loading</a>, linking and virtual memory
<br><img src="/lib/media/截圖-2022-12-27-下午3.00.37.jpg"><br>優點：<br>
<br>沒有internal fragmentation
<br>缺點<br>
<br>有外碎
<br>需要有extra HW support(分段表、MMU
<br>EMAT更久（有check d&lt;limit?)
<br><br>
動機：<br>
想要保有segment 採用logical viewpoint 之好處但又要解外部碎裂<br>
觀念：<br>
段再分頁，phy. memory = a set frames
]]></description><link>考研筆記/作業系統/ch7-memory-management/ch7-memory-management.html</link><guid isPermaLink="false">考研筆記/作業系統/CH7 Memory Management/CH7 Memory Management.md</guid><pubDate>Wed, 13 Mar 2024 09:22:35 GMT</pubDate><enclosure url="lib/media/截圖-2022-12-27-上午11.01.56.jpg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib/media/截圖-2022-12-27-上午11.01.56.jpg&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Compaction 技術]]></title><description><![CDATA[ 
 <br>Compaction 技術<br>
移動執行中的process使其在memeory 連續<br>
OS藉由移動「執行中的process」使得原本非連續的holes, 得以聚集形成一個連續的hole
<br>優點<br>
<br>解決外部碎裂
<br>缺點<br>
<br>不易制定optilam compaction plicy
<br>process必須是<a class="internal-link" data-href="Dynamic Binding.md" href="/考研筆記/作業系統/ch7-memory-management/dynamic-binding.html" target="_self" rel="noopener">Dynamic Binding</a>才可支持
]]></description><link>考研筆記/作業系統/ch7-memory-management/compaction-技術.html</link><guid isPermaLink="false">考研筆記/作業系統/CH7 Memory Management/Compaction 技術.md</guid><pubDate>Wed, 13 Mar 2024 09:23:08 GMT</pubDate></item><item><title><![CDATA[Dynamic Binding]]></title><description><![CDATA[ 
 <br><br>
定義<br>
程式執行之memory 起始位置delay到execution time 才動態的決定<br>
-&gt;process執行時，OS可以任意移動process的位址，且仍可正確執行
<br>優點<br>
<br>增加OS對memory管理彈性度
<br>有助於compaction的實施
<br>缺點<br>
<br>Process執行時間較長 叫沒有效率
<br>需要extra hardware support
<br>Hardware support<br>
由MMU（硬體單元）將邏輯位置轉到實際位置]]></description><link>考研筆記/作業系統/ch7-memory-management/dynamic-binding.html</link><guid isPermaLink="false">考研筆記/作業系統/CH7 Memory Management/Dynamic Binding.md</guid><pubDate>Wed, 13 Mar 2024 09:22:04 GMT</pubDate></item><item><title><![CDATA[Dynamic linking]]></title><description><![CDATA[<a class="tag" href="?query=tag:⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️</a> 
 <br>Dynamic linking <a href=".?query=tag:⭐️" class="tag" target="_blank" rel="noopener">#⭐️</a><br>又稱shared library<br>
類似<a class="internal-link" data-href="Dynamic loading.md" href="/考研筆記/作業系統/ch7-memory-management/dynamic-loading.html" target="_self" rel="noopener">Dynamic loading</a>，差在於保留在memory 的多為link而已<br>
定義 :<br>
在execution time時，若module被真正呼叫到，才將他載入，並與其他object code進行linking
需OS額外的support<br>
( 如果要access其他processes 之外部符號，則必須透過OS來完成）
<br>好處<br>
<br>縮減了obj. Code 之space
<br>節省memory space
<br>Library可以共用  又稱shared library
<br>有助於library更新（原本的程式碼不需更動）
]]></description><link>考研筆記/作業系統/ch7-memory-management/dynamic-linking.html</link><guid isPermaLink="false">考研筆記/作業系統/CH7 Memory Management/Dynamic linking.md</guid><pubDate>Wed, 13 Mar 2024 09:22:04 GMT</pubDate></item><item><title><![CDATA[Dynamic loading]]></title><description><![CDATA[<a class="tag" href="?query=tag:⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️</a> 
 <br>Dynamic loading <a href=".?query=tag:⭐️" class="tag" target="_blank" rel="noopener">#⭐️</a><br>
目的：節省記憶體空間<br>
呼叫程序時，會先檢查memory內有沒有此程序，沒有才會load近來
<br>不需要OS額外的支援（這是programmer or loader的責任）<br>缺點：<br>
process執行時間較久、較不具效率。尤其還牽扯到I/O.]]></description><link>考研筆記/作業系統/ch7-memory-management/dynamic-loading.html</link><guid isPermaLink="false">考研筆記/作業系統/CH7 Memory Management/Dynamic loading.md</guid><pubDate>Wed, 13 Mar 2024 09:22:04 GMT</pubDate></item><item><title><![CDATA[External Fragmentation(外部碎裂)]]></title><description><![CDATA[ 
 <br>External Fragmentation(外部碎裂)<br>
定義：<br>
在Contiguous Allocation 要求下，若所有holes size皆無法滿足process size 需求，但這些free holes 之total size卻&gt;=process size，然而因為這些holes並不連續，故無法配置給此process行程memory space 浪費。
<br>memory 中的holes無法有效利用造成的。<br>
通常外碎較為嚴重]]></description><link>考研筆記/作業系統/ch7-memory-management/external-fragmentation(外部碎裂).html</link><guid isPermaLink="false">考研筆記/作業系統/CH7 Memory Management/External Fragmentation(外部碎裂).md</guid><pubDate>Wed, 13 Mar 2024 09:15:31 GMT</pubDate></item><item><title><![CDATA[First Fit]]></title><description><![CDATA[ 
 <br>
從AV-List 中第一個hole開始尋找，直到找到第一個夠大的hole
]]></description><link>考研筆記/作業系統/ch7-memory-management/first-fit.html</link><guid isPermaLink="false">考研筆記/作業系統/CH7 Memory Management/First Fit.md</guid><pubDate>Wed, 13 Mar 2024 09:25:12 GMT</pubDate></item><item><title><![CDATA[Internal Fragmentation (內部碎裂)]]></title><description><![CDATA[ 
 <br>Internal Fragmentation (內部碎裂)<br>
定義：<br>
配置給Process之Memory space超過process size需求，兩者所產生的差值空間，此process使用不到，且其他processes也無法使用<br>
=&gt; 配給太多
<br>memory 分配的size大於process size，多出來的空間無法利用]]></description><link>考研筆記/作業系統/ch7-memory-management/internal-fragmentation-(內部碎裂).html</link><guid isPermaLink="false">考研筆記/作業系統/CH7 Memory Management/Internal Fragmentation (內部碎裂).md</guid><pubDate>Mon, 04 Mar 2024 08:07:00 GMT</pubDate></item><item><title><![CDATA[Linking loader]]></title><description><![CDATA[ 
 <br>產生可重新定位的程式碼(Relocatable object code)<br>
<br>Allocation:向OS 要求一個起始位置base on size
<br>Loading: 將obj. code 中 Text records 載入memory&nbsp;
<br>Linking修正：將sin obj. code 載入到記憶體, 得到起始位置。
<br>Relocation修正：針對當下和未來的起始位置做修正
]]></description><link>考研筆記/作業系統/ch7-memory-management/linking-loader.html</link><guid isPermaLink="false">考研筆記/作業系統/CH7 Memory Management/Linking loader.md</guid><pubDate>Wed, 13 Mar 2024 09:22:40 GMT</pubDate></item><item><title><![CDATA[page]]></title><description><![CDATA[ 
 <br>page<br>實際記憶體以固定size切分 -&gt; 一塊就是一個frame<br>
邏輯記憶體以固定大小切分 -&gt; 一塊就是一個page<br>

<br>採用非連續性配置策略
<br>"physical" memory(i.e. RAM)：是為（切成）一組frame(頁框)之集合，且各frame size均相同  NOTE:由硬體決定frame size，非ＯＳ
<br>"Logical" Memory：視為一組Page頁面集合且page size = Frame size  NOTE:Page 採用physical viewpoint
<br>配置方式：<br>
令Process 大小 = n 個pages，則OS必須在physical Memory 中找到n個free frame(不一定要連續)<br>
所以！OS必須對每一個Process建立他們的Page Table(分頁表)，記錄各個page被放置的frame No.<br>
NOTE:Page Table is kept in kernel的PCB中"memory management info."

<br>優點<br>
<br>解決<a class="internal-link" data-href="External Fragmentation(外部碎裂).md" href="/考研筆記/作業系統/ch7-memory-management/external-fragmentation(外部碎裂).html" target="_self" rel="noopener">外部碎裂</a>
<br>支持Memory sharing &amp; memory Protection之實施
<br>支持<a class="internal-link" data-href="Dynamic loading.md" href="/考研筆記/作業系統/ch7-memory-management/dynamic-loading.html" target="_self" rel="noopener">Dynamic loading</a> linking&amp; Virtual memory實施
<br>缺點<br>
<br>有<a class="internal-link" data-href="Internal Fragmentation (內部碎裂).md" href="/考研筆記/作業系統/ch7-memory-management/internal-fragmentation-(內部碎裂).html" target="_self" rel="noopener">內部碎裂</a>
<br>需要額外硬體支援（MMU）
<br>Effective Memory Access Time(<a class="internal-link" data-href="../CH8 Virtual Memory/CH8 Virtual Memory.md#EMAT計算 ⭐️⭐️⭐️⭐️" href="/考研筆記/作業系統/ch8-virtual-memory/ch8-virtual-memory.html#EMAT計算_⭐️⭐️⭐️⭐️" target="_self" rel="noopener">EMAT</a>)會較久
<br>Increase context switch time
]]></description><link>考研筆記/作業系統/ch7-memory-management/page.html</link><guid isPermaLink="false">考研筆記/作業系統/CH7 Memory Management/page.md</guid><pubDate>Wed, 13 Mar 2024 09:36:11 GMT</pubDate></item><item><title><![CDATA[Additional Reference Bit]]></title><description><![CDATA[ 
 <br>~~當時該page有被access，register最左邊補 1 ~~<br>
定義：<br>
每個page 會有一個欄位(Register)保存最近幾次的ref. bit 值，每隔一段時間system會做...

<br>每個page's register 右移一位，空出最左（最高）位元
<br>copy page 的ref. bit 到register之最高位元
<br>ref. bit reset 為0

將來，要==挑選register值最小的page ==為victim page。<br>
若多個register值相同，則以FIFO為準
越近被access，register值越大
]]></description><link>考研筆記/作業系統/ch8-virtual-memory/additional-reference-bit.html</link><guid isPermaLink="false">考研筆記/作業系統/CH8 Virtual Memory/Additional Reference Bit.md</guid><pubDate>Mon, 04 Mar 2024 08:08:38 GMT</pubDate></item><item><title><![CDATA[Additional Reference Bit Usage]]></title><description><![CDATA[ 
 <br><br>
<br>每個page會有一個register  紀錄最近幾次Ref. Bit之值。
<br>系統每隔一段時間會執行下列工作

<br>每一個頁面的暫存器均右移一位（最右（低）的位元捨棄，空出最左（高））
<br>Copy page 的Ref. Bit值到register 之最左位元
<br>Reset their ref. Bit 為0


<br>將來OS若要select victim , OS會選擇register值最小的page ，若有多個page 具有相同值，則採FIFO<br>
NOTE:所有的LRU近似法則皆可能退回成FIFO
<br><img alt="../img/image 3.jpg" src="/lib/media/image-3.jpg">]]></description><link>考研筆記/作業系統/ch8-virtual-memory/additional-reference-bit-usage.html</link><guid isPermaLink="false">考研筆記/作業系統/CH8 Virtual Memory/Additional Reference Bit Usage.md</guid><pubDate>Wed, 13 Mar 2024 09:15:47 GMT</pubDate><enclosure url="lib/media/image-3.jpg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib/media/image-3.jpg&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Belady Anomaly]]></title><description><![CDATA[ 
 <br><br>
定義：分配給process的頁匡(frame)數增加，照理page fault ratio 應當下降，但是其page fault ratio竟然不降反增之異常現象
<br><br>給page 參考：1,2,3,4,1,2,5,1,2,3,4,5<br>
建議記下此題目<br>
圖示<br><br>
定義：n個frames所包含的pages set，必定是(n+1)的frames所包含的pages set之子集合，此性質稱之：具有stack property 之法則，絕不會發生Belady Anomaly
<br>
OPT及LRU法則具有stack property<br>
所以他們不會發生Belady Anomaly
]]></description><link>考研筆記/作業系統/ch8-virtual-memory/belady-anomaly.html</link><guid isPermaLink="false">考研筆記/作業系統/CH8 Virtual Memory/Belady Anomaly.md</guid><pubDate>Wed, 13 Mar 2024 09:24:32 GMT</pubDate></item><item><title><![CDATA[Ch8 Virtual Memory]]></title><description><![CDATA[<a class="tag" href="?query=tag:⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️</a> <a class="tag" href="?query=tag:⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️</a> <a class="tag" href="?query=tag:⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️</a> <a class="tag" href="?query=tag:⭐️⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️⭐️</a> <a class="tag" href="?query=tag:⭐️⭐️⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️⭐️⭐️</a> <a class="tag" href="?query=tag:⭐️⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️⭐️</a> <a class="tag" href="?query=tag:⭐️⭐" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐</a> <a class="tag" href="?query=tag:⭐️⭐️⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️⭐️⭐️</a> <a class="tag" href="?query=tag:⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️</a> <a class="tag" href="?query=tag:⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️</a> <a class="tag" href="?query=tag:⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️</a> <a class="tag" href="?query=tag:⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️</a> 
 <br>Hintpage table發生的事情

<br>size不夠-&gt; VMemory
<br>page fault!!處理
<br>EMAT
<br>速度？
<br><br><br>
允許process size 在超過physical memory free space size 之下，仍能執行。
<br>logical memory size 不會受到physical memory size 之限制<br>
觀念：即是"Partial" loading process部分內容, process 即可執行(even 不載入也可執行）

<br>早期：<a class="internal-link" data-href="../CH7 Memory Management/Dynamic loading.md" href="/考研筆記/作業系統/ch7-memory-management/dynamic-loading.html" target="_self" rel="noopener">dynamic loading</a>（ＯＳ無額外支持）
<br>現代：OS提供VM特性

其他附帶好處

<br>若process只載入一部分即可執行

-&gt;同時間內可載入的process數量變多<br>
-&gt;CPU utilization 相對高<br>
NOTE:Thrash 情況除外<br>
2. less I/O Time(因為量少)<br>
3. Memory utilization相對較高<br>
4. programmer無須煩惱 process size太大的問題，只需專心把程式寫正確<br>
5. Copy-on-write技術
<br><br>需要有一個機制區分哪些pages不再memory中<br>
定義：架構在前面的<a class="internal-link" data-href="../CH7 Memory Management/page.md" href="/考研筆記/作業系統/ch7-memory-management/page.html" target="_self" rel="noopener">Page Memory  Management</a> 基礎。差別：process執行之前，無須事先載入所有的Pages，而是載入部分所需（demand）之Pages即可執行
若是資料結構具有locality，則Demand paging效果較好
NOTE:也可以不載入任何page即可執行，此為pure demand paging。<br>
若事先載入猜測的pages叫做<a class="internal-link" data-href="prepaging.md" href="/考研筆記/作業系統/ch8-virtual-memory/prepaging.html" target="_self" rel="noopener">prepaging</a>
<br>NOTE:[CH7] valid &amp; invalid paged<br>圖示：<br><img src="/lib/media/截圖-2022-09-14-下午2.40.59.jpg"><br><br>
兩次I/O time
<br>Steps:<br>
<br>MMU 送出一個中段通知OS
<br>OS收到中斷後，暫停目前process之執行且保存此process之status(eg. p.c. registers value...etc)
<br>OS依此存取位址判斷是否是合法存取。<br>
若非法則終止此process。<br>
合法則判定是page fault引起
<br>Then, OS去Memory中找尋可用頁匡，若沒有，則需執行，以空出一個free frame
<br>Then, OS再到Disk確認lost page所在位置，啟動Disk I/O運作<a class="internal-link" data-href="Page Replacement.md" href="/考研筆記/作業系統/ch8-virtual-memory/page-replacement.html" target="_self" rel="noopener">Page Replacement</a>載入lost page 到free frame。
<br>Then, OS修改page table標示錯lost page的frame No.並將Invalid改為Valid值
<br>OS恢復原本中斷前之process之執行
<br><img alt="../img/714FFDCB-0BEE-4E15-98A9-D80DCB2E49CB.jpeg" src="/lib/media/714ffdcb-0bee-4e15-98a9-d80dcb2e49cb.jpeg" style="width: 400px; max-width: 100%;"><br>NOTE: p.245是more steps<br><br>平均memory access處理時間<br>
單位是時間<br>
= (1-p){Memory Access Time} + P  {Page fault 處理時間} 其中P : page fault ratio<br>
={memory access時間}*{memory access 頻率}+ {Page fault處理時間}*{Page fault 頻率}
<br>ExampleMemory access time: 100ns
page fault processing time: 5ms
複製

(1)若page faultratio = 20%<br>
求EMAT?<br>
Ans:(1-0.2)100ns+0.25ms = 80ns + 1ms = 1000080ns

(2)若EMAT不超過10𝜇s 則page fault應&lt; ?<br>
Ans:<br>
(1-p)100ns+p5ms &lt; 10𝜇s<br>
100 - 100p + 5000000p &lt; 10000<br>
499900p &lt; 9900<br>
=&gt; p&lt; 99/4999 ~= 1/500<br>
小結：提及VM效能，即是要降低EMAT，而關鍵點：要降低page fault ratio
<br><br>
<br>Page Replacement法則之選擇
<br>Frame 數分配多寡之影響
<br>Page size影響
<br>program structures影響
<br><br>
概念：利用locality 來預測一段時間內所需的frame數量，藉此降低thrashing 的機率
<br>解釋Working Set 是如何處理Thrashing 問題的？利用Working set 確認process總共所需的frame數量，若此數字高於physical frames number，就降低multiprogramming degree。<br><br><br><a class="internal-link" data-href="Page Replacement.md" href="/考研筆記/作業系統/ch8-virtual-memory/page-replacement.html" target="_self" rel="noopener">Page Replacement</a><br>NOTE:在所有replacement法則中，沒有最差的<br>
<br><a class="internal-link" data-href="FIFO.md" href="/考研筆記/作業系統/ch8-virtual-memory/fifo.html" target="_self" rel="noopener">FIFO</a>
<br><a class="internal-link" data-href="OPT.md" href="/考研筆記/作業系統/ch8-virtual-memory/opt.html" target="_self" rel="noopener">OPT</a>  看向未來
<br><a class="internal-link" data-href="LRU.md" href="/考研筆記/作業系統/ch8-virtual-memory/lru.html" target="_self" rel="noopener">LRU</a>    過去（包含pages外的）很久沒使用的
<br>LRU近似

<br><a class="internal-link" data-href="Additional Reference Bit.md" href="/考研筆記/作業系統/ch8-virtual-memory/additional-reference-bit.html" target="_self" rel="noopener">Additional Reference Bit</a> Usage
<br><a class="internal-link" data-href="Second chance.md" href="/考研筆記/作業系統/ch8-virtual-memory/second-chance.html" target="_self" rel="noopener">Second chance</a>(or clock)  依據值R.bit
<br><a class="internal-link" data-href="Enhanced Second chance.md" href="/考研筆記/作業系統/ch8-virtual-memory/enhanced-second-chance.html" target="_self" rel="noopener">Enhanced Second chance</a> 兩個依據值R.bit&amp;M.bit


<br>**Counting Algo..
<br>
定義：以page的累計參考次數作為選擇victim page的依據（值相同也是以FIFO為準）
<br>
<br>LFU：過去參考次數最少為victim page pages中過去使用次數最少的
<br>MFU：過去參考次數最多為victim page  pages中過去使用次數最多的的
<br>分析：<br>
<br>page fault ratio相當高
<br>製做成本高，需硬體支持
<br>有<a class="internal-link" data-href="Belady Anomaly.md" href="/考研筆記/作業系統/ch8-virtual-memory/belady-anomaly.html" target="_self" rel="noopener">Belady Anomaly</a>
<br><br>舉例<br>
<img alt="../img/截圖 2022-09-24 下午3.41.17.jpg" src="/lib/media/截圖-2022-09-24-下午3.41.17.jpg" style="width: 450px; max-width: 100%;"><br><br><a class="internal-link" data-href="Modification Bit.md" href="/考研筆記/作業系統/ch8-virtual-memory/modification-bit.html" target="_self" rel="noopener">Modification Bit</a><br>
<a class="internal-link" data-href="Belady Anomaly.md" href="/考研筆記/作業系統/ch8-virtual-memory/belady-anomaly.html" target="_self" rel="noopener">Belady Anomaly</a><br><br>
<br>一般而言，process分配的頁匡數增加-&gt;page fault ratio應下降
<br>OS再分配process 頁匡數時，需滿足 最多&amp;最少數目限制(由HW決定，非OS)

<br>最多數目：phy. memory size
<br>最少數目：需能讓 CPU機器指令 順利完成，週期中 可能之最多memory access數，否則無法完成。（需讓機器指令一次存取完整）


<br>在滿足最少&amp;最多數目區間才是OS可以決定的範圍
<br><br>What is Thrashing?process花在page fault 的時間遠大於正常處理時間，造成CPU利用率急速下降，I/O Disk異常忙碌。<br>
原因：<br>
process分配到的frame不夠而造成page fault<br>
OS分配page給此process後可能會造成另一個process page fault 不斷這樣惡性循環<br>
定義：若某些Process分配到的頁匡數不足，則process經常page fault 且page replacement，若OS採用<a class="internal-link" data-href="Global replacement policy.md" href="/考研筆記/作業系統/ch8-virtual-memory/global-replacement-policy.html" target="_self" rel="noopener">Global replacement policy</a>，則可能會誤選其他processes之page為victim page.，造成其他processes page fault.，同理。<br>
=&gt;大家搶成一團，都在page fault，都在等待pages I/O完成<br>
=&gt; ready queue空了，CPU utilization下降，sys.引入更多process。<br>
=&gt;如此循環下去會呈現：

<br>CPU utilization 急速下降
<br>paging Disk 異常忙碌
<br>page fault time 遠大於 正常執行時間

稱之Thrashing
<br><img alt="../img/截圖 2022-09-24 下午4.55.27.jpg" src="/lib/media/截圖-2022-09-24-下午4.55.27.jpg" style="width: 300px; max-width: 100%;"><br><br>[法一]<br>
當Thrashing已發生=&gt;降低Multiprogramming degree<br>
[法二]<br>
利用 <a class="internal-link" data-href="page fault frequence control.md" href="/考研筆記/作業系統/ch8-virtual-memory/page-fault-frequence-control.html" target="_self" rel="noopener">page fault frequence control</a> 機制，來防止Thrashing 控制頁匡數<br>
[法三]<br>
利用 <a class="internal-link" data-href="Working Set Model.md" href="/考研筆記/作業系統/ch8-virtual-memory/working-set-model.html" target="_self" rel="noopener">Working Set Model</a> 技術預估processes在不同執行時期需要的頁匡<br>
[法四]<br>
<br>增加main memory size
<br>規定不能使用global 
<br>Question下列cases，若增加Multiprogramming degree是否可以提高CPU利用度?what actions will you do?<br>
CPU utilization/ paging Disk<br>
A. 3%/90%<br>
B. 87%/10%<br>
C. 3%/10%<br>
ANS:<br>
A. 明顯在Thrashing。應該要降低degree<br>
B. 幫助有限。不要動，幫助有限<br>
C. 都很空閒，要增加M.Degree<br>p.296. 66<br><br>若page size 越小則<br>
<br>Page fault ratio: 增加
<br>Page Table size: 變大
<br>I/O次數: 增加
<br>內部碎裂: 輕微
<br>I/O Transfer time: 較小
<br><a class="internal-link" data-href="Locality Model.md" href="/考研筆記/作業系統/ch8-virtual-memory/locality-model.html" target="_self" rel="noopener">locality</a>: 較佳
<br>
13缺點，45優點<br>
趨勢朝向“大”的page size
<br>p.258<br><br>
<br>Program 中所使用之data structures 指令, algo.等，應符合<a class="internal-link" data-href="Locality Model.md" href="/考研筆記/作業系統/ch8-virtual-memory/locality-model.html" target="_self" rel="noopener">locality model</a>則有助於降低page fault對V.M is Good，反之則BAD
<br>Program 中對於Array 元素之處理順序，最好符合Array 元素在memory中之存放順序，以降低page fault ratio
<br>ExampleA:[1..128, 1..128]of int;<br>
每個int 佔1 byte<br>
page size = 128 bytes<br>
A以Row-major存放元素<br>
給予3個frames（且Code已置入第一個frame，其餘為空）採<a class="internal-link" data-href="FIFO" href="/考研筆記/作業系統/ch8-virtual-memory/fifo.html" target="_self" rel="noopener">FIFO</a>/<a class="internal-link" data-href="LRU" href="/考研筆記/作業系統/ch8-virtual-memory/lru.html" target="_self" rel="noopener">LRU</a>，求page fault 次數
(i)
for i= 1 to 128
	for j= 1 to 128 
		A[i, j]=0;
複製
(ii)
for j= 1 to 128
	for i= 1 to 128 
		A[i, j]=0;
複製
Ans:<br>
“../../img/截圖 2022-09-26 下午10.32.13.jpg” could not be found.
(i)每清一列一次page fault  =&gt; 1281次<br>
(ii)每清一行元素發生128次 page fault =&gt; 128128次<br><br>主要是在探討3種fork():<br><br>直接複製<br>
定義：當Parent process生出child process，OS會替child process 配置 New frames 給 child<br>
(即 Parent, child 佔用不同空間)且OS也須 Copy parent 的內容給 child。
<br>缺點：<br>
<br>每生出child process，OS及要配置 New Frames 給 child =&gt; 大幅佔用 memory
<br>process creation 速度慢，因為需要Copy parent 內容給 child
<br><br>先不複製，做記號，需要改動再複製<br>
定義：Parent 建立 child process。 Initially, child 先共享 parent 之 memory space，不先配置child process New frames 。<br>
直到parent or child process 需更改重要內容，先進行完整的copy，再去修改。
<br>
<br>有可能write之pages需mark "copy-on-write" pages
<br>不會modified pages(eg. read-only Code)不需 mark
<br>優點<br>
<br>minimizing the need of Memory
<br>speed up the process creation
<br><br>
定義：也是讓child 出生時暫時共享parent's frames，但是不提供copy-on-write<br>
任一方該更改，另一方會受影響
適用於child出生後 馬上execlp()
<br>p.261<br><br>量度TLB的兩個metrix
<br>TLB Hit ratio
<br>TLB Reach
<br>
定義：經由TLB所能存取到的memory size，即<br>
TLB Reach = TLB entry數*Page size<br>
希望TLB Reach 越大越好
理想中，process的working set存放在TLB中。如果不是，那可能要花很多精力處理page fault。
<br>增大TLB的方法：<br>
<br>增加TLB entry 數目

<br>優點:增大TLB Reach/Hit-ratio
<br>缺點:

<br>成本高
<br>也可能無法涵蓋Process的working set




<br>加大Page size:

<br>優點：

<br>加大TLB Reach
<br>page fault ration &amp; page table size 下降


<br>缺點：

<br>內部碎裂嚴重
解法
提供多種page size=&gt; 在TLB中增加一個page size欄位。<br>
此外，很多機器是由OS來管理TLB（以前是HW管理）






<br>p.263]]></description><link>考研筆記/作業系統/ch8-virtual-memory/ch8-virtual-memory.html</link><guid isPermaLink="false">考研筆記/作業系統/CH8 Virtual Memory/CH8 Virtual Memory.md</guid><pubDate>Wed, 13 Mar 2024 09:22:13 GMT</pubDate><enclosure url="lib/media/截圖-2022-09-14-下午2.40.59.jpg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib/media/截圖-2022-09-14-下午2.40.59.jpg&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Enhanced Second chance]]></title><description><![CDATA[ 
 <br><br>
定義：以 &lt;Reference Bit, Modification Bit&gt; 配對值為排選victim page 依據<br>
值最小之page 為victim<br>
若多個pages且相同值，以FIFO為準
<br><img alt="../img/截圖 2022-09-24 下午3.02.06.jpg" src="/lib/media/截圖-2022-09-24-下午3.02.06.jpg" style="width: 450px; max-width: 100%;">]]></description><link>考研筆記/作業系統/ch8-virtual-memory/enhanced-second-chance.html</link><guid isPermaLink="false">考研筆記/作業系統/CH8 Virtual Memory/Enhanced Second chance.md</guid><pubDate>Wed, 13 Mar 2024 09:20:22 GMT</pubDate><enclosure url="lib/media/截圖-2022-09-24-下午3.02.06.jpg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib/media/截圖-2022-09-24-下午3.02.06.jpg&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[FIFO]]></title><description><![CDATA[ 
 <br><br>應該不用多說了吧，最簡單的<br>
定義：最早載入的page作為victim page
<br>ExampleQ:給予3個frames, they are all empty initially,<br>
給予下列page reference string(也就是page number)<br>
求page fault次數?<br>
7,0,1,2,0,3,0,4,2,3,0,3,2,1,2,0,1,7,0,1<br>
(or page size = 100, string = 742, 302, 492, 089, ...)
ANS:<br>
圖示<br>
<img alt="../img/296AF51D-F3CC-4760-95BD-4285CD97B985.jpeg" src="/lib/media/296af51d-f3cc-4760-95bd-4285cd97b985.jpeg" style="width: 400px; max-width: 100%;"><br><br>
<br>page fault ratio 相當高，效果不佳
<br>Simple, easy製作
<br>可能有<a class="internal-link" data-href="Belady Anomaly.md" href="/考研筆記/作業系統/ch8-virtual-memory/belady-anomaly.html" target="_self" rel="noopener">Belady Anomaly</a>
<br>NOTE:在所有replacement法則中，沒有最差的]]></description><link>考研筆記/作業系統/ch8-virtual-memory/fifo.html</link><guid isPermaLink="false">考研筆記/作業系統/CH8 Virtual Memory/FIFO.md</guid><pubDate>Wed, 13 Mar 2024 09:46:47 GMT</pubDate><enclosure url="lib/media/296af51d-f3cc-4760-95bd-4285cd97b985.jpeg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib/media/296af51d-f3cc-4760-95bd-4285cd97b985.jpeg&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Global replacement policy]]></title><description><![CDATA[ 
 <br><br>
與<a class="internal-link" data-href="Local replacement policy.md" href="/考研筆記/作業系統/ch8-virtual-memory/local-replacement-policy.html" target="_self" rel="noopener">Local</a>相反
]]></description><link>考研筆記/作業系統/ch8-virtual-memory/global-replacement-policy.html</link><guid isPermaLink="false">考研筆記/作業系統/CH8 Virtual Memory/Global replacement policy.md</guid><pubDate>Mon, 04 Mar 2024 08:08:29 GMT</pubDate></item><item><title><![CDATA[Local replacement policy]]></title><description><![CDATA[ 
 <br><br>
當某process page fault，需做<a class="internal-link" data-href="Page Replacement.md" href="/考研筆記/作業系統/ch8-virtual-memory/page-replacement.html" target="_self" rel="noopener">Page replacement</a>, OS只能從該process之pages(frames) 選victim page， 不可從其他processes選
<br>
<br>優點：<a class="internal-link" data-href="Thrashing.md" href="/Thrashing.md" target="_self" rel="noopener">Thrashing</a> 現象不至於大幅度擴散
]]></description><link>考研筆記/作業系統/ch8-virtual-memory/local-replacement-policy.html</link><guid isPermaLink="false">考研筆記/作業系統/CH8 Virtual Memory/Local replacement policy.md</guid><pubDate>Mon, 04 Mar 2024 08:08:39 GMT</pubDate></item><item><title><![CDATA[Locality model]]></title><description><![CDATA[ 
 <br>feat: 計組<br><br>
定義:process在執行期間對於所有存取的memory location 並非是均勻的，而是某種局部/集中之特性
<br>一般而言分為<br>
<br>Temporal(時間) Locality:<br>
目前存取之memory area, 過不久後又會被存取 =&gt; 此區域經常被存取<br>
EX:Loop, Counter, Subroutine(副程式), pure code, stack(eg. TOP element).
<br>Spatial(空間) Locality<br>
目前存取之memory area, 其鄰近的區域也馬上會被參考 =&gt; 與鄰居有關聯<br>
EX:Array, sequentail code execution, Commom data area, vector operation.
<br>若process結構符合Locality model對V.M來說是好的<br>
反之則不好(EX:Link list, Hashing, Binary Search, goto, Jump, Indirect  addressing mode)<br>違背Temporal(時間) Locality少見<br>EX:p.300:75]]></description><link>考研筆記/作業系統/ch8-virtual-memory/locality-model.html</link><guid isPermaLink="false">考研筆記/作業系統/CH8 Virtual Memory/Locality Model.md</guid><pubDate>Wed, 13 Mar 2024 09:24:32 GMT</pubDate></item><item><title><![CDATA[LRU]]></title><description><![CDATA[ 
 <br><br>過去（包含pages外的）很久沒使用的~~<br>
定義：選擇最近（過去）不常使用之page 為victim page，<br>
即是"reverse OPT "<br>
即"The last reference Time"最小的page 即為LRU page
<br><br>
<br>Page fault ratio 可接受
<br>沒有<a class="internal-link" data-href="Belady Anomaly.md" href="/考研筆記/作業系統/ch8-virtual-memory/belady-anomaly.html" target="_self" rel="noopener">Belady Anomaly</a>
<br>LRU的製作cost 很高（需大量HW支援 for recording)
<br><br>
<br>使用Counter(作logical timer)<br>
每發生memory access

<br>counter++
<br>且copy Counter值到該存取page 的"the last ref time"欄位中
<br>OS要select victim 時，則"the last ref time"的page為LRU page


<br>Stack 法

<br>最近一次被存取的置於stack頂部
<br>stack bottom即為LRU page
<br>Frame 數目即為stack size<br>
圖示<br>
<img alt="../img/image 2.jpg" src="/lib/media/image-2.jpg">


<br><img alt="../img/image.jpg" src="/lib/media/image.jpg">]]></description><link>考研筆記/作業系統/ch8-virtual-memory/lru.html</link><guid isPermaLink="false">考研筆記/作業系統/CH8 Virtual Memory/LRU.md</guid><pubDate>Wed, 13 Mar 2024 09:47:23 GMT</pubDate><enclosure url="lib/media/image-2.jpg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib/media/image-2.jpg&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Modification Bit]]></title><description><![CDATA[ 
 <br><br>
用以表示page Content是否曾經被修改過自上次載入貨reset此Bit後
<br>
<br>若Bit = 1:表曾被修改過
<br>若Bit = 0:表未曾被修改過
<br><br>OS selects a Victim page後，check 該 Bit 值<br>
<br>若Bit = 0:無需swap out
<br>若Bit = 1:需swap out
]]></description><link>考研筆記/作業系統/ch8-virtual-memory/modification-bit.html</link><guid isPermaLink="false">考研筆記/作業系統/CH8 Virtual Memory/Modification Bit.md</guid><pubDate>Wed, 13 Mar 2024 09:23:13 GMT</pubDate></item><item><title><![CDATA[OPT]]></title><description><![CDATA[ 
 <br><br>
定義：selects ”將來長期不會使用之page“為victim
<br><br><img src="/lib/media/96db614d-2bde-4588-bf7c-749476b9d534.jpeg"><br><br>
<br>page fault ratio最低-&gt;最佳
<br>沒有
<br>不會發生<a class="internal-link" data-href="Belady Anomaly.md" href="/考研筆記/作業系統/ch8-virtual-memory/belady-anomaly.html" target="_self" rel="noopener">Belady Anomaly</a> 
]]></description><link>考研筆記/作業系統/ch8-virtual-memory/opt.html</link><guid isPermaLink="false">考研筆記/作業系統/CH8 Virtual Memory/OPT.md</guid><pubDate>Wed, 13 Mar 2024 09:47:27 GMT</pubDate><enclosure url="lib/media/96db614d-2bde-4588-bf7c-749476b9d534.jpeg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib/media/96db614d-2bde-4588-bf7c-749476b9d534.jpeg&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[page Buffering 機制]]></title><description><![CDATA[ 
 <br><br>
現況（緣由）：OS選完victim page且此page is modified，現行流程
<br>
<br>將victim page write back
<br>才能載入miss page
<br>then, process才可恢復執行
<br>=&gt;process 可恢復時間拖很久(I/O time 兩次)，希望改善之。page fault影響太大<br><br>用事先空出來的frame作為暫時miss page存放的地方，錯開整理時間<br>
（只會找page table裡的）先用私房錢，等有時間再還。當下處理page fault只用一次I/O time
<br>將frame 分成<br>
<br>Resident frames =&gt; 分配給process
<br>Free frames pool =&gt;OS keep 私房錢
<br>用途<br>
提供free frame(私房錢)，讓miss page先行載入<br>使用流程<br>
<br>OS選完victim page且為modified
<br>OS先自 Free frames pool 中先提供一 free frame，供miss page載入
<br>載入完，process先恢復執行
<br>OS稍後再將 victim page 寫回Disk，然後歸還 free frame
<br><br>不常用的做記號<br>OS會keep 一條 Modification list ，記載著<a class="internal-link" data-href="Modification Bit.md" href="/考研筆記/作業系統/ch8-virtual-memory/modification-bit.html" target="_self" rel="noopener">Modification Bit</a>值= 1 之所有page No.<br>
OS會等Disk比較空間的時候，將此list 中一些pages write back to Dick, and clear thier m.bit為0，如此一來可增加選出的victim pages是 unmodified之機率<br><br>
把free frame pool看作cache，要找東西之前先看F.F.P(free frame pool)
<br>以[法一]為基礎 差在此法會檢查free frame pool並直接用裡面的page<br>
OS在針對 free frames pool中每個 free frame 紀錄此頁匡裡頭放的是哪一個process之哪個page，因為這些free frame pool中 free frame 內放的內容一定是最新的。<br>使用流程<br>
<br>OS選完victim且modified
<br>OS先到free frame pool中找有沒有miss pool存在
<br>若有，直接用。若沒有，[法一]後續流程
<br>OS等Disk有空，將victim page寫回Disk，再歸還free frame
]]></description><link>考研筆記/作業系統/ch8-virtual-memory/page-buffer機制.html</link><guid isPermaLink="false">考研筆記/作業系統/CH8 Virtual Memory/Page Buffer機制.md</guid><pubDate>Wed, 13 Mar 2024 09:24:49 GMT</pubDate></item><item><title><![CDATA[page fault frequence control]]></title><description><![CDATA[ 
 <br>page fault frequence control<br>
定義：OS會訂定process page fault ratio之合理的上限值與下限值，若page fault ratio可以控制在一區間，可以降低Thrashing發生機率。
<br>
<br>若OS發現P.F.R太高=&gt; OS應該多分配頁匡給該process，降低其P.F.R
<br>若OS發現P.F.R太低=&gt; OS應取走多餘頁匡，分給其他process
]]></description><link>考研筆記/作業系統/ch8-virtual-memory/page-fault-frequence-control.html</link><guid isPermaLink="false">考研筆記/作業系統/CH8 Virtual Memory/page fault frequence control.md</guid><pubDate>Wed, 13 Mar 2024 09:16:12 GMT</pubDate></item><item><title><![CDATA[Page Replacement]]></title><description><![CDATA[ 
 <br><br>
定義：當Page fault發生且memory中無free frame時，OS必須執行此工作，即是要排出一個Victim page(or the replaced page)將他swap out 到Disk保存，以空出一個free frame 供miss page 載入之用
<br><br><img src="/lib/media/764d9919-15ac-4a28-851b-ec3e726efc0f.jpeg"><br>
<br>為降低額外的swap out 之i/o次數，故在page table 在引進一個欄位：<a class="internal-link" data-href="Modification Bit.md" href="/考研筆記/作業系統/ch8-virtual-memory/modification-bit.html" target="_self" rel="noopener">Modification Bit</a>
<br>OS在selects Victim page 時，有兩大策略

<br>


<br>




]]></description><link>考研筆記/作業系統/ch8-virtual-memory/page-replacement.html</link><guid isPermaLink="false">考研筆記/作業系統/CH8 Virtual Memory/Page Replacement.md</guid><pubDate>Wed, 13 Mar 2024 09:23:13 GMT</pubDate><enclosure url="lib/media/764d9919-15ac-4a28-851b-ec3e726efc0f.jpeg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib/media/764d9919-15ac-4a28-851b-ec3e726efc0f.jpeg&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[prepaging]]></title><description><![CDATA[ 
 <br><br>當process執行，若所趨的page接載memory，則一切正常無誤。<br>
但若process企圖存取不在memory中的page，則產生page fault<br><br>
所有可被(deteministic)演算法在多項式時間內解決的decision problem
]]></description><link>考研筆記/作業系統/ch8-virtual-memory/prepaging.html</link><guid isPermaLink="false">考研筆記/作業系統/CH8 Virtual Memory/prepaging.md</guid><pubDate>Wed, 13 Mar 2024 09:29:31 GMT</pubDate></item><item><title><![CDATA[Second chance]]></title><description><![CDATA[ 
 <br><br>作法：以<a class="internal-link" data-href="FIFO.md" href="/考研筆記/作業系統/ch8-virtual-memory/fifo.html" target="_self" rel="noopener">FIFO</a> order為基礎Reference Bit 使用<br>
刷新他的資訊
<br>steps:<br>
<br>若next page存在，reset it's R.Bit = 1
<br>先以FIFO order排出一個page
<br>check page 的R.Bit

<br>case1: 若為0，則他即是victim page
<br>case2: 若為1，則

<br>給他機會，先留在記憶體
<br>Reset it's R.Bit = 0
<br>Reset loading time(改為現在時間)，變成最晚排入的
<br>goto 1.




<br>Example“../img/截圖 2022-09-24 下午2.52.55.jpg” could not be found.<br>
箭頭指向FIFO order的最後一個<br>
“../img/截圖 2022-09-24 下午2.53.01.jpg” could not be found.]]></description><link>考研筆記/作業系統/ch8-virtual-memory/second-chance.html</link><guid isPermaLink="false">考研筆記/作業系統/CH8 Virtual Memory/Second chance.md</guid><pubDate>Wed, 13 Mar 2024 09:24:51 GMT</pubDate></item><item><title><![CDATA[Working Set Model]]></title><description><![CDATA[ 
 <br><br><br><br>
<br>Working Set Window: 記為∆，表示以∆次Memory Access作為統計 Working Set 之依據（∆直可通帶調整）
<br>Working Set: 在∆次page access中所參考到的不同pages所形成之集合
<br>Working Set Size(WSS): working set 之page 個數，即 process 在此時期所需之 Frame 數
<br>Example...2 3 4 5 3 6 7 7 7 7 3 4 2 3 4...<br>
∆ = 10<br>
第一期的working是{2,3,4,5,6,7}<br><br>令 n =process數目<br>
WSSᵢ: Processᵢ在此時期之working set size<br>
M: phy. memory 大小<br>
求出D = Sigma i =1~n(WSSᵢ) = 頁匡總需求？<br>分成2 case<br>
<br>case 1: 若D &lt;= M<br>
則OS會依照WSSᵢ直飛給個Pᵢ足夠的frame數，如此可預防thrashing
<br>case 2: 若D &gt; M<br>
則OS會select一些processes將他們swap out到Disk，以降低D值，直到D&lt;= M(case 1)在做分配，等到有足夠記憶體空間
<br><br>
<br>可預防Thrashing
<br>對於Prepaging 也有助益
<br><br>
<br>不易制定精確的Working Set(∆不好制定)
<br>若前後期working set差異太大，易造成太多I/O運作。
<br>Example{1,2,3} =&gt; {4,5,6}<br>
6次I/O
{1,2,3} =&gt; {2,3,4}<br>
2次I/O]]></description><link>考研筆記/作業系統/ch8-virtual-memory/working-set-model.html</link><guid isPermaLink="false">考研筆記/作業系統/CH8 Virtual Memory/Working Set Model.md</guid><pubDate>Wed, 13 Mar 2024 09:22:51 GMT</pubDate></item><item><title><![CDATA[Bit vector]]></title><description><![CDATA[ 
 <br><br>
定義：<br>
每一個Block用一1Bit表示配置與否（0:free, 1:allocated）<br>
若Disk有n個Blocks 則its Bit vector = n bit
<br>優點<br>
<br>Simple, easy implementation
<br>適用小型Disk
<br>容易找到連續的free Blocks
<br>缺點<br>
<br>不適合用在大型的Disk(要是Bit vector多到無法載到memory中，部分Block就無法讀取)
]]></description><link>考研筆記/作業系統/ch9-disk-management/bit-vector.html</link><guid isPermaLink="false">考研筆記/作業系統/CH9 Disk Management/Bit vector.md</guid><pubDate>Wed, 13 Mar 2024 09:25:43 GMT</pubDate></item><item><title><![CDATA[Disk system 組成 <a href="?query=tag:%E2%AD%90%EF%B8%8F" class="tag" target="_blank" rel="noopener">#⭐️</a>]]></title><description><![CDATA[<a class="tag" href="?query=tag:⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️</a> <a class="tag" href="?query=tag:⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️</a> <a class="tag" href="?query=tag:⭐️⭐️⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️⭐️⭐️</a> <a class="tag" href="?query=tag:⭐️⭐️⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️⭐️⭐️</a> <a class="tag" href="?query=tag:⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️</a> <a class="tag" href="?query=tag:⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️</a> <a class="tag" href="?query=tag:⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️</a> <a class="tag" href="?query=tag:⭐️⭐" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐</a> <a class="tag" href="?query=tag:⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️</a> 
 <br>為什麼OS需要block儲存在Disk的相關資訊Ans:需要知道File在Disk裡是怎麼儲存，藉以應用最適合的disk scheduling
原問題：<br>
Give the reasons why the operating system might require accurate information on how blocks are stored on a disk. How could the operating system improve file system performance with this knowledge? Briefly justify your answers.<br><br>
<br>由多片Disks組成
<br>每片Disk通常雙面可存Data
<br>每面劃分成多個同心圓軌道，叫做 Track(磁軌)
<br>每條Track在畫分為多個 sector(磁區)
<br>sector 是 Dick controller 可 read, write, 控制之基本單位
<br>不同面之相同 Track No 之集合稱為 cylinder(磁柱)
<br><br>
由三個部分組成
<br>
<br>seek Time：將Head移動到存取的Track上方所花之時間
<br>Latency Time：將域存取的sector「轉」到讀寫頭下方所花的時間
<br>Transfer Time：Data在Disk和Memory之間的傳輸時間
<br>Disk Access Time = seek time + Latency time + Transfer time<br>Avg Disk Accsee Time (假設讀取XBlock)
= {avg seek time}+{avg Latency time=轉一圈的時間/2}+{傳輸XBlock的時間}`
複製<br>通常以seek Time為主<br>rpm(rotation per minute)<br>Disk 轉速7200 rpm，球avg. Latency Time-&gt; 一秒120圈<br>
-&gt; 轉一圈花1/120秒<br>
故平均 = 1/120/2 (s)<br>求Transfer rate（每秒可以傳輸多少Data）Disk 有10 片disks<br>
雙面可存<br>
每面有2048條track<br>
每條track有4096個sector<br>
每個secto可存16Kb<br>
轉速6000rpm<br>
求Transfer rate（每秒可以傳輸多少Data）

Ans:<br>
6000rpm = 100圈/s<br>
轉一圈 = 讀取一整個磁柱<br>
而一條cylinder容量 = 20條Tracks = 20*4096*16Kb
100*20*4096*16(Kb/s)<br>
= 128000MB/secDataview (inline field '128000MB/sec'): Error: 
-- PARSING FAILED --------------------------------------------------

&gt; 1 | 128000MB/sec
    |       ^

Expected one of the following: 

'(', '*' or '/' or '%', '+' or '-', '.', '&gt;=' or '&lt;=' or '!=' or '=' or '&gt;' or '&lt;', '[', 'and' or 'or', EOF
<br>承上題假設Disk平均seek time = 10ms<br>
今天要read a File , File size = 4MB<br>
需花?ms

Ans:<br>
Disk Access Time<br>
= seek time(Avg.) + latency time(Avg.) + Transfer time<br>
= 10ms + 1/2 *1/100 + 4MB/128000(MB/s)<br><br>基礎：Disk 之配置、存取單位是 Block<br><br>Grouping, Counting 都是link list的變形<br><img alt="../../資料結構/img/截圖 2022-11-02 下午7.52.40.jpg" src="/lib/media/截圖-2022-11-02-下午7.52.40.jpg" style="width: 400px; max-width: 100%;"><br><br>為什麼需要明確的file資訊Ans:<br>
需要知道file的儲存方式和address，並利用此資訊實施最好的disk algorithm<br>哪一個File Allocation Method在operation多為"append", "truncate"最適合？Indexed Allocation<br>Contiguous &amp; linked 特性相反<br><br>
<br><a class="internal-link" data-href="FAT" href="/考研筆記/作業系統/ch9-disk-management/fat.html" target="_self" rel="noopener">FAT</a> 把指標存在一起的linked allocation（追蹤只要讀pointer不用整個block）
<br>UNIX的<a class="internal-link" data-href="I-Node.md" href="/考研筆記/作業系統/ch9-disk-management/i-node.html" target="_self" rel="noopener">I-Node</a>
<br><br><br><br>
<br><a class="internal-link" data-href="physical formatting(low-level formatting).md" href="/考研筆記/作業系統/ch9-disk-management/physical-formatting(low-level-formatting).html" target="_self" rel="noopener">physical formatting(low-level formatting)</a>
<br><a class="internal-link" data-href="logical formatting(high-level formatting).md" href="/考研筆記/作業系統/ch9-disk-management/logical-formatting(high-level-formatting).html" target="_self" rel="noopener">logical formatting(high-level formatting)</a>
<br><br>如字面上的意思<br>
將磁碟當作「大型的陣列」來用，沒有任何File sys支援服務
<br>優點：快<br>
缺點：不方便使用<br><br>
定義：此loader只有一個目的

<br>開機時，用來將object code從Disk 載入到RAM

<br>[早期]：<br>
Bootstrap loader存在ROM裏面，開機時首先執行載入OS。<br>
缺點<br>
<br>Bootstrap loader不容易修改（ROM是燒進去的）
<br>ROM大小有限-&gt;Bootstrap loader無法過大
<br>[現代]：<br>
ROM裡面存Bootstrap的位址，Bootstrap存在Disk<br>
Bootstrap loader（or Bootstrap records)存在ROM裏面，開機時透過Bootstrap loader找出「在磁碟內完整的Bootstrap loader」，抓到RAM，再透過完整的Bootstrap loader載入OS。<br>
此外，Bootstrap loader放在Disk中「固定」的Blocks中，稱為Boot Block ;擁有Boot Block的Disk叫做Boot Disk or system Disk<br><br>為何會壞？<br>
<br>工廠生產過程就壞了
<br>使用一段時間才壞
<br>處理方法<br>
<br>Mark BAD sectors,以後不使用（IDE disk controller採用）
<br>使用spare sectors來代替（SCSI disk controller採用）
spare sectors：low-formatting就以配置、OS看不到、只有SCSI disk controller可用
複製

<br>缺點：這樣轉向可能會破壞掉原本 Disk scheduling 的效能<br>
（解法：spare sector分散/安插在track上，再利用平移讓BAD sector旁邊是空的）<br><br>Disk除了一般儲存Files Data外，也有負責暫存SWAP out 的process（沒有kernel的） image or pages，尤其是<a class="internal-link" data-href="../CH8 Virtual Memory/CH8 Virtual Memory.md" href="/考研筆記/作業系統/ch8-virtual-memory/ch8-virtual-memory.html" target="_self" rel="noopener">CH8 Virtual Memory</a>機制<br>使用此技術會:<br>
<br>降低系統performance
<br>提升Virtual memory size
<br>SWAP space<br>
<br>也可以單獨利用其他Disks來保存，不跟kernel儲存的Disk混用
<br>通常是預留空間，space size宜大不宜小，雖有space浪費，但至少安全
<br>Management方法<br>
<br>使用File system以File system以File 形式存放SWAP out之process image or pages<br>
優點：

<br>容易製作<br>
缺點：
<br>效能不佳
<br>外部碎裂問題（通常用<a class="internal-link" data-href="Contiguous Allocation.md" href="/考研筆記/作業系統/ch9-disk-management/contiguous-allocation.html" target="_self" rel="noopener">Contiguous Allocation</a>)


<br>使用獨立的Partition 存放。Raw-I/O<br>
優點：效能佳<br>
缺點：萬一partition size不夠大，必須重新re-partition
<br><br><br>提升技術：<a class="internal-link" data-href="Data striping.md" href="/考研筆記/作業系統/ch9-disk-management/data-striping.html" target="_self" rel="noopener">Data striping</a><br><br>
<br><a class="internal-link" data-href="Mirror.md" href="/考研筆記/作業系統/ch9-disk-management/mirror.html" target="_self" rel="noopener">Mirror</a>
<br><a class="internal-link" data-href="parity-check.md" href="/考研筆記/作業系統/ch9-disk-management/parity-check.html" target="_self" rel="noopener">parity-check</a>
<br><br>（Redundant Array of Independent Disks)<br><br>
用多個小的Disk替代一個大的Disk<br>
目的:提升disk 的throughput、reliability
<br><br>
<br>
RAID-0

即是Block-level striping 且沒有任何reliability提升技術，如<a class="internal-link" data-href="Mirror.md" href="/考研筆記/作業系統/ch9-disk-management/mirror.html" target="_self" rel="noopener">mirror</a> or parity-check<br>
適用於高效能存取要求且可靠度不甚重要之應用場合


<br>
RAID-1

即是<a class="internal-link" data-href="Mirror.md" href="/考研筆記/作業系統/ch9-disk-management/mirror.html" target="_self" rel="noopener">mirror</a> only<br>
缺點同<a class="internal-link" data-href="Mirror.md" href="/考研筆記/作業系統/ch9-disk-management/mirror.html" target="_self" rel="noopener">mirror</a>


<br>
RAID-2（無實際產品）

採用memory 之 ECC(error-checking Code)技術，Disks數需2N-1

<br>成本降低有限
<br>可靠度根RAID-3一樣但成本高於RAID-3



<br>
RAID-3

採用Bit-Level striping 及 parity-check技術

<br>N+1部Disks



<br>
RAID-4

採Block-Level striping 及 parity-check技術

<br>N+1部Disks



<br>
RAID-5

採用Block-Level striping及 parity-check技術，但差別在於parity blocks是分散於Disks中，並非集中存於單一Disk中

<br>目的：避免單一Disk過度使用
<br>N部Disks（每個disk要額外容納parity的資訊）（也就是只允許一步Disk出錯)



<br>
RAID-6（無實際產品）

採用Reed-Solomon技術，可允許兩部Disks同時出錯。但是成本太高。


<br>
RAID-0 &amp; RAID-1組合

高效能存取與高可靠度皆要求之場合

分為:

<br>RAID 0+1:先striping 再整體<a class="internal-link" data-href="Mirror.md" href="/考研筆記/作業系統/ch9-disk-management/mirror.html" target="_self" rel="noopener">mirror</a><br>
<img src="/lib/media/截圖-2022-12-14-下午6.27.40.jpg">
<br>RAID1+0:先個別<a class="internal-link" data-href="Mirror.md" href="/考研筆記/作業系統/ch9-disk-management/mirror.html" target="_self" rel="noopener">mirror</a> 再交錯(striping)<br>
<img src="/lib/media/截圖-2022-12-14-下午6.27.54.jpg">


<br><br>
定義：將RAM切割一塊space作為一個logical Disk使用
<br>優點<br>
<br>速度極快
<br>缺點：<br>
<br>容量小
<br>power-off後，data不見。
]]></description><link>考研筆記/作業系統/ch9-disk-management/ch9-disk-management.html</link><guid isPermaLink="false">考研筆記/作業系統/CH9 Disk Management/CH9 Disk Management.md</guid><pubDate>Wed, 13 Mar 2024 09:21:32 GMT</pubDate><enclosure url="lib/media/截圖-2022-11-02-下午7.52.40.jpg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib/media/截圖-2022-11-02-下午7.52.40.jpg&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Contiguous Allocation]]></title><description><![CDATA[ 
 <br>
定義：若File 大小 = n個Blocks，則OS必須在Disk中找到n個_連續的_free Blocks，才能配置給他
<br>例：<br>
<img alt="../../資料結構/img/截圖 2022-11-02 下午8.10.11.jpg" src="/lib/media/截圖-2022-11-02-下午8.10.11.jpg" style="width: 150px; max-width: 100%;"><br>
File 1 大小 = 3 Blocks<br>
則OS配置5, 6, 7號Blocks給他且在"physical" Directory 中紀錄下列配置資訊<br><br>分析<br>
優點：<br>
<br>平均的seek time 較短（因為連續的Blocks大多落在同一條track上）
<br>可支援<a class="internal-link" data-href="Random(Direct) Access.md" href="/考研筆記/作業系統/ch9-disk-management/random(direct)-access.html" target="_self" rel="noopener">Random(Direct) Access</a> 及sequential Access
<br>可靠度較高（than linked Allocation)
<br>訓序存取速度快（than linked Allocation)
<br>缺點：<br>
<br>會有[外部碎裂]問題
在Disk中是要Repack（磁碟重組）解決外碎，類似於 Memory 中之 Compaction

<br>檔案大小不易擴增
]]></description><link>考研筆記/作業系統/ch9-disk-management/contiguous-allocation.html</link><guid isPermaLink="false">考研筆記/作業系統/CH9 Disk Management/Contiguous Allocation.md</guid><pubDate>Wed, 13 Mar 2024 09:20:17 GMT</pubDate><enclosure url="lib/media/截圖-2022-11-02-下午8.10.11.jpg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib/media/截圖-2022-11-02-下午8.10.11.jpg&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Counting]]></title><description><![CDATA[ 
 <br>
定義：也是<a class="internal-link" data-href="Link list.md" href="/考研筆記/作業系統/ch9-disk-management/link-list.html" target="_self" rel="noopener">Link list</a>變形<br>
適用於連續性配置及回收之方法
<br>作法：<br>
free Block內除了記下一個free Block No之外，還紀錄之後的連續的free Blocks 數目]]></description><link>考研筆記/作業系統/ch9-disk-management/counting.html</link><guid isPermaLink="false">考研筆記/作業系統/CH9 Disk Management/Counting.md</guid><pubDate>Wed, 13 Mar 2024 09:29:26 GMT</pubDate></item><item><title><![CDATA[Data striping]]></title><description><![CDATA[ 
 <br><br>
定義：使用多部physical Disks組成一個單一個logical disk，運用Data「平行write/read」來提升速度
<br>一般可分為<br>
<br>Bit-Level striping
<br>Block-Level striping
]]></description><link>考研筆記/作業系統/ch9-disk-management/data-striping.html</link><guid isPermaLink="false">考研筆記/作業系統/CH9 Disk Management/Data striping.md</guid><pubDate>Wed, 13 Mar 2024 09:24:28 GMT</pubDate></item><item><title><![CDATA[Disk scheduling Algorithm <a href="?query=tag:%E2%AD%90%EF%B8%8F%E2%AD%90%EF%B8%8F%E2%AD%90%EF%B8%8F%E2%AD%90%EF%B8%8F%E2%AD%90%EF%B8%8F" class="tag" target="_blank" rel="noopener">#⭐️⭐️⭐️⭐️⭐️</a>]]></title><description><![CDATA[<a class="tag" href="?query=tag:⭐️⭐️⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️⭐️⭐️</a> 
 <br><br>在 Disk queue會有多個track access requests，OS如何安排服務順序使得tracks movement 數較少，此為Disk scheduling目的<br>沒有最差，也沒有最佳的法則<br><br>tip: C代表單一方向（中途不會改變掃描的方向）<br><br>
定義：早來的track request優先服務
<br>例：Disk 有200track，編號0~199，Head目前停在53，剛服務完60，現有下列track requests依序到達98, 183, 37, 122, 14, 124, 65, 67，求track 移動總數？<br>
|98-53|+|37-183|+|122-37|+|14-122|+|124-14|+|65-124|+|67-65| = 640<br>!!!不准算錯<br>分析：<br>
<br>Simple, 易於實施
<br>公平，No <a class="internal-link" data-href="../CH4 Process Management &amp; Tread Management/starvation.md" href="/考研筆記/作業系統/ch4-process-management-&amp;-tread-management/starvation.html" target="_self" rel="noopener">Starvation</a>
<br>排班效果不是很好，移動數度稍多-&gt;平均seek time偏長
<br><br>
定義：目前離Head位置最近的track request優先服務
<br>例：呈上<br>
ans:服務順序: 53-&gt; 65-&gt; 67-&gt; 37-&gt; 14-&gt; 98 -&gt; 122-&gt; 124-&gt; 183<br>分析：<br>
<br>不公平，可能有<a class="internal-link" data-href="../CH4 Process Management &amp; Tread Management/starvation.md" href="/考研筆記/作業系統/ch4-process-management-&amp;-tread-management/starvation.html" target="_self" rel="noopener">Starvation</a>
<br>效果不錯，seek-time平均較短。
<br><br>
定義：Head來回移動掃描，育有Track request立刻服務。（！！到兩端才會改變方向）
<br>例：呈上<br>
<img src="/lib/media/截圖-2022-12-05-下午7.00.55.jpg"><br>分析：<br>
<br>排班效果尚可
<br>適用於大量track requests(overload重)的時候可獲得較均勻地等待時間
<br>在某一些時刻對於某些track request似乎不盡公平 。Note:C-SCAN
<br>Head 非得遇到兩端才折返，此舉浪費不必要的seek-time Mote:用look改善
<br><br>
定義：SCAN之變形，提供「單向」服務
<br>Note:計算有爭議<br>
最多版本<br>
<br>回程的移動時間不列入
<br>回程的移動時間列入
<br>加1軌
<br><br>提早折返的SCAN<br>
定義：類似SCAN，差別：Head在「服務完該方向之最後一個track request後就會折返」
<br><br>單向的Look]]></description><link>考研筆記/作業系統/ch9-disk-management/disk-scheduling-algorithm.html</link><guid isPermaLink="false">考研筆記/作業系統/CH9 Disk Management/Disk scheduling Algorithm.md</guid><pubDate>Wed, 13 Mar 2024 09:18:15 GMT</pubDate><enclosure url="lib/media/截圖-2022-12-05-下午7.00.55.jpg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib/media/截圖-2022-12-05-下午7.00.55.jpg&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[FAT]]></title><description><![CDATA[ 
 <br>把指標存在一起的linked allocation（追蹤只要讀pointer不用整個block）<br>
定義：是<a class="internal-link" data-href="Linked Allocation.md" href="/考研筆記/作業系統/ch9-disk-management/linked-allocation.html" target="_self" rel="noopener">Linked Allocation</a>的變形<br>
差別：將原本存於Disk中Blocks之linking info 存於Table中，不用存於Disk之Allocated Blocks。<br>
當OS在做File Allocation 及accsee時，FAT會置於Memory中<br>
如此OS可在 Table(in Memory)取得Allocated Blocks 間的linking info，加速存取Data Blocks
<br>優點：<br>
<br>可改善傳統<a class="internal-link" data-href="Linked Allocation.md" href="/考研筆記/作業系統/ch9-disk-management/linked-allocation.html" target="_self" rel="noopener">Linked Allocation</a>方法無法快速存取ith Block（<a class="internal-link" data-href="Random(Direct) Access.md" href="/考研筆記/作業系統/ch9-disk-management/random(direct)-access.html" target="_self" rel="noopener">Random(Direct) Access</a>）之問題<br>
（因為FAT在memory裏，不像原始的link allocation需要不斷地讀取Disk，藉由追蹤FAT的pointer，就可以得到ith個block）
<br>例：<br>
<img alt="../img/截圖 2022-11-02 下午8.44.17.jpg" src="/lib/media/截圖-2022-11-02-下午8.44.17.jpg" style="width: 150px; max-width: 100%;"><br>
File 2 大小 = 4 Blocks<br>
則OS配置5, 10, 8, 13號Blocks給他且在"physical" Directory 中紀錄下列配置資訊<br><br><img alt="../img/截圖 2022-11-02 下午8.50.42.jpg" src="/lib/media/截圖-2022-11-02-下午8.50.42.jpg" style="width: 150px; max-width: 100%;"><br>Question“../../img/截圖 2022-12-29 下午3.04.30.jpg” could not be found.]]></description><link>考研筆記/作業系統/ch9-disk-management/fat.html</link><guid isPermaLink="false">考研筆記/作業系統/CH9 Disk Management/FAT.md</guid><pubDate>Wed, 13 Mar 2024 09:46:37 GMT</pubDate><enclosure url="lib/media/截圖-2022-11-02-下午8.44.17.jpg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib/media/截圖-2022-11-02-下午8.44.17.jpg&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Grouping]]></title><description><![CDATA[ 
 <br><br>
是link list方法之變形<br>
每個free Block除了紀錄下一個free Block之No(位址)以外，另外多加記錄其他free Blocks 之No
<br>優點<br>
<br>可迅速找到大量的free block
<br>缺點]]></description><link>考研筆記/作業系統/ch9-disk-management/grouping.html</link><guid isPermaLink="false">考研筆記/作業系統/CH9 Disk Management/Grouping.md</guid><pubDate>Wed, 13 Mar 2024 09:29:29 GMT</pubDate></item><item><title><![CDATA[I-Node]]></title><description><![CDATA[ 
 <br>混合式的<a class="internal-link" data-href="Index Allocation.md" href="/考研筆記/作業系統/ch9-disk-management/index-allocation.html" target="_self" rel="noopener">Index Allocation</a><br>
<img src="/lib/media/截圖-2022-12-05-下午6.16.51.jpg"><br>
結構<br>
例：15個entry。其中(依照題意)：<br>
<br>1~12格：紀錄Data Blocks No
<br>13格：pointer to Single-level Index structure
<br>14格：pointer to Two-level Index structure
<br>15格：pointer to Three-level Index structure
<br>ExampleI-node 有15個entry(規定如上)<br>
Block size = 8KB<br>
Block No. (Address/pointer)佔4bytes

求 MAX File size
一個Index Block可以存 8KB/4Bytes = 2¹¹個Block No.<br>
MAX File size = (12+2¹¹+(2¹¹)²+(2¹¹)³)個Data  = (12+2¹¹+(2¹¹)²+(2¹¹)³)*8bytes

有一File 大小 = 6000個Blocks。若要直接存取其第5000個Data Block內容，需要幾次Block I/O?（假設I-Node已在Memory中）
5000 -12 -2048 = 2940 (用了1~13)<br>
2940 -2048 = 892 (用了14-1)<br>
-&gt; 用在14指向的Block 的第二個指向的第892個No 指向的資料<br>
-&gt; 3次

若要循序(sequence)存取此File的前5000個Data Blocks 則需?次I/O?
依照上題<br>
5000th落在14Block下的 第2Block下的 第892個<br>
前面有2048落在 2 level裏<br>
-&gt; 3*(892+2048)+ 2*2048+ 1*12]]></description><link>考研筆記/作業系統/ch9-disk-management/i-node.html</link><guid isPermaLink="false">考研筆記/作業系統/CH9 Disk Management/I-Node.md</guid><pubDate>Wed, 13 Mar 2024 09:36:12 GMT</pubDate><enclosure url="lib/media/截圖-2022-12-05-下午6.16.51.jpg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib/media/截圖-2022-12-05-下午6.16.51.jpg&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Index Allocation]]></title><description><![CDATA[<a class="tag" href="?query=tag:⭐️⭐️⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️⭐️⭐️</a> 
 <br><br>用額外的Index Block指向所有分配的Block<br>
定義：若File 大小= n 個Blocks，則OS除了配置n個free Blocks 給他之外，另須額外配置 Index Block給他，記錄所有Allocated Data Blocks之No.
<br>例：<br>
<img alt="../img/截圖 2022-11-02 下午8.44.17.jpg" src="/lib/media/截圖-2022-11-02-下午8.44.17.jpg" style="width: 150px; max-width: 100%;"><br>
File 3 大小 = 4 Blocks<br>
則OS配置12, 6, 4, 9號Blocks給他，另外配置15號作為Index Block，且在"physical" Directory 中紀錄下列配置資訊<br><br><br>優點：<br>
<br>沒有外部碎裂
<br>可支援<a class="internal-link" data-href="Random(Direct) Access.md" href="/考研筆記/作業系統/ch9-disk-management/random(direct)-access.html" target="_self" rel="noopener">Random(Direct) Access</a>及sequential Access
<br>可以動態擴充大小
<br>建立File前於須事先宣告大小
<br>缺點：<br>
<br>Index Blocks佔用額外空間
<br>linking 欄位之overhead/浪費（不論有幾個linking 都是佔用一樣「大」的空間）
<br>若File 大小很大則可能單一一個Index Block無法記錄全部
<br><br><br><br>用Index Blocks中的其中一個索引紀錄下一個Index Block的No.(Address)<br>
缺點：存取ith資料的平均I/O次數增加<br><br>看起來像tree<br>
例：(2 level)<br>
優點：存取ith Block之I/O次數為固定值（固定level數+1)<br>
缺點：極不適合小型檔案<br>]]></description><link>考研筆記/作業系統/ch9-disk-management/index-allocation.html</link><guid isPermaLink="false">考研筆記/作業系統/CH9 Disk Management/Index Allocation.md</guid><pubDate>Wed, 13 Mar 2024 09:22:53 GMT</pubDate><enclosure url="lib/media/截圖-2022-11-02-下午8.44.17.jpg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib/media/截圖-2022-11-02-下午8.44.17.jpg&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Link list]]></title><description><![CDATA[ 
 <br>
在Disk中直接將這些free Blocks 以 Link list方式串連
<br>優點<br>
<br>適用於大型Disk
<br>加入刪除方便
<br>缺點<br>
<br>不易找到連續的free Block
<br>不易迅速找到大量的free Block(在Disk 中，沿著linking 找，這是I/O運作)
]]></description><link>考研筆記/作業系統/ch9-disk-management/link-list.html</link><guid isPermaLink="false">考研筆記/作業系統/CH9 Disk Management/Link list.md</guid><pubDate>Wed, 13 Mar 2024 09:27:34 GMT</pubDate></item><item><title><![CDATA[Linked Allocation]]></title><description><![CDATA[ 
 <br>
定義：若File 大小 = n Blocks，則OS只需在Disk中找到n 個free Blocks 但不一定要連續。此外，各Allocated Blocks 之間用Link 串連起來
<br>例：<br>
<img alt="../../資料結構/img/截圖 2022-11-02 下午8.10.11.jpg" src="/lib/media/截圖-2022-11-02-下午8.10.11.jpg" style="width: 150px; max-width: 100%;"><br>
File 2 大小 = 3 Blocks<br>
則OS配置9-&gt;12-&gt;14號Blocks給他且在"physical" Directory 中紀錄下列配置資訊<br><br>分析<br>
與<a class="internal-link" data-href="Contiguous Allocation.md" href="/考研筆記/作業系統/ch9-disk-management/contiguous-allocation.html" target="_self" rel="noopener">Contiguous Allocation</a>相反]]></description><link>考研筆記/作業系統/ch9-disk-management/linked-allocation.html</link><guid isPermaLink="false">考研筆記/作業系統/CH9 Disk Management/Linked Allocation.md</guid><pubDate>Wed, 13 Mar 2024 09:22:12 GMT</pubDate><enclosure url="lib/media/截圖-2022-11-02-下午8.10.11.jpg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib/media/截圖-2022-11-02-下午8.10.11.jpg&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[logical formatting(high-level formatting)]]></title><description><![CDATA[ 
 <br>logical formatting(high-level formatting)<br>Disk在真正使用前，必須再做2件事<br>
<br>Partiton：每一個Partition視為一個獨立的logical drive (e.g. C, D, E, ... disk)
<br>logical formatting：OS必須建立File Management所需的Data structure
]]></description><link>考研筆記/作業系統/ch9-disk-management/logical-formatting(high-level-formatting).html</link><guid isPermaLink="false">考研筆記/作業系統/CH9 Disk Management/logical formatting(high-level formatting).md</guid><pubDate>Mon, 04 Mar 2024 08:06:32 GMT</pubDate></item><item><title><![CDATA[Mirror(or shadow)技術]]></title><description><![CDATA[ 
 <br><br>存兩份資料<br>
定義：對每一部正常的Disk均配置一部mirror Disk，Data 除了寫入正常Dusk以外，也同步存入Mirror disk 中<br>
若有N部正常Disks，另需配置N部Mirror Disk
<br>EX:<br>
若有4部正常的Disks，容量各1TB，則採Mirror機制<br>
需要8部Disks。<br>
可以儲存的最大容量= 4TB<br>優點：<br>
<br>可靠度最高
<br>Data recovery速度最快
<br>缺點：<br>
<br>貴！！
]]></description><link>考研筆記/作業系統/ch9-disk-management/mirror.html</link><guid isPermaLink="false">考研筆記/作業系統/CH9 Disk Management/Mirror.md</guid><pubDate>Wed, 13 Mar 2024 09:36:13 GMT</pubDate></item><item><title><![CDATA[parity-check技術]]></title><description><![CDATA[ 
 <br><br>
定義：對N部正常使用的Disks再額外配置一部Disk作為Parity-check Disk。所以共需N+1部Disks<br>
Data寫入時，除了Data Block存入之外，另需額外花時間求出parity-check Block內容，然後寫入Parity Disk
<br><img src="/lib/media/截圖-2022-12-05-下午9.03.49.jpg"><br>
將來，若某一Data Block is BAD 則可用其他Data Blocks和parity Blocks再做「偶同位」，即可回覆<br>
優點：成本便宜<br>
缺點：<br>
<br>可靠度比<a class="internal-link" data-href="Mirror.md" href="/考研筆記/作業系統/ch9-disk-management/mirror.html" target="_self" rel="noopener">mirror</a>低
<br>Data recovery speed 慢於<a class="internal-link" data-href="Mirror.md" href="/考研筆記/作業系統/ch9-disk-management/mirror.html" target="_self" rel="noopener">Mirror</a>
<br>需花額外時間求parity Block，write速度較慢
]]></description><link>考研筆記/作業系統/ch9-disk-management/parity-check.html</link><guid isPermaLink="false">考研筆記/作業系統/CH9 Disk Management/parity-check.md</guid><pubDate>Wed, 13 Mar 2024 09:24:47 GMT</pubDate><enclosure url="lib/media/截圖-2022-12-05-下午9.03.49.jpg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib/media/截圖-2022-12-05-下午9.03.49.jpg&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[physical formatting(low-level formatting)]]></title><description><![CDATA[ 
 <br>physical formatting(low-level formatting)<br>
<br>工廠生產時會做
<br>主要切割出sector，讓Disk controller可以控制
<br>可以偵測出壞掉的磁區並標記他
]]></description><link>考研筆記/作業系統/ch9-disk-management/physical-formatting(low-level-formatting).html</link><guid isPermaLink="false">考研筆記/作業系統/CH9 Disk Management/physical formatting(low-level formatting).md</guid><pubDate>Mon, 04 Mar 2024 08:06:41 GMT</pubDate></item><item><title><![CDATA[Random(Direct) Access]]></title><description><![CDATA[ 
 <br>
要Access File 中的ith Block, 則start Block No.+i-1 即為ith Block No.<br>
又稱drirect access
]]></description><link>考研筆記/作業系統/ch9-disk-management/random(direct)-access.html</link><guid isPermaLink="false">考研筆記/作業系統/CH9 Disk Management/Random(Direct) Access.md</guid><pubDate>Wed, 13 Mar 2024 09:20:23 GMT</pubDate></item><item><title><![CDATA[File open 與 close動作]]></title><description><![CDATA[ 
 <br><br>
緣由<br>
OS對File進行任何運作(e.g read, write, change name,...)之前，皆須先找到Disk中之phsical Directory ，進行搜尋，找到該File
<br>然而，有下列問題：<br>
<br>search time太長：因爲file數目太多
<br>I/O次數多：因為phy. Directory 放在Disk中
<br>所以才有File open &amp; close 運作<br><br>
定義：<br>
OS會在Memory 中建立一個table 叫做"open file table"，<br>
若File 第一次被使用時，OS會到Disk之physical Directory 找出他的配置資訊，會copy 此資訊到 open File table 。<br>
將來OS進行任何運作前，只需到此表格中進行search 即可
<br>優點：<br>
<br>search Time 很小（一般才存20~30左右個檔案之配置資訊）
<br>存取速度快
<br><br>
定義：<br>
當File不再使用了，OS會將open file table 中此file 之配置資訊 存回Disk中之physical Directory ，且open file  table 在刪去此一資訊
<br><br>
若考慮File被多個Processes共用，則system會create 2類的open file table

<br>system-open-file-table：只會存放此共用file之共通配置資訊
<br>process-open-file-table：保存該process對於檔案存取的個別資訊 （e.g存取權利、目前File pointer 位置）

<br><br>(一致性語意)<br>
主要是討論File共享之模式及一些權利<br>
有三種semantic：<br>
<br>UNIX semantic：<br>
例如：座次表（賣票系統）被多個Processes共用

<br>需互斥存取控制
<br>大家看到的內容是一致的
<br>某個process對他改變內容其結果是visible to all


<br>session semantic：<br>
例如：空白報名表，供人下載使用

<br>不需要互斥存取控制
<br>大家看到的內容不見得一致


<br>Immutable semantic：<br>
例如：總經理公告文件第0036號

<br>不可更改、read only、檔名不可重複


<br><br>以UNIX為例（交大喜歡問）<br>將File 之user分為三級<br>
<br>Owner：File建立者
<br>Group(or member)：被Owner指定成為group member 者
<br>others(or universal)：其他user
<br>將File 之存取權利分為三級<br>
<br>r: read
<br>w: write
<br>x: execute
<br><br>例：<br>
{Owner}{Group}{others}<br>rwx r-x --x -&gt; 111 101 001 -&gt; 751<br>
=&gt;命令 chmod File-Name 751<br>p343練習]]></description><link>考研筆記/作業系統/ch10-file-system/ch10-file-system.html</link><guid isPermaLink="false">考研筆記/作業系統/CH10 File System/CH10 File System.md</guid><pubDate>Wed, 13 Mar 2024 09:24:22 GMT</pubDate></item><item><title><![CDATA[作業系統]]></title><description><![CDATA[<a class="tag" href="?query=tag:⭐️⭐" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐</a> <a class="tag" href="?query=tag:⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️</a> <a class="tag" href="?query=tag:⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️</a> <a class="tag" href="?query=tag:⭐️⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️⭐️</a> <a class="tag" href="?query=tag:⭐️⭐️⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️⭐️⭐️</a> <a class="tag" href="?query=tag:⭐️⭐️⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️⭐️⭐️</a> <a class="tag" href="?query=tag:⭐️⭐️⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️⭐️⭐️</a> <a class="tag" href="?query=tag:⭐️⭐️⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️⭐️⭐️</a> <a class="tag" href="?query=tag:⭐️⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️⭐️</a> <a class="tag" href="?query=tag:⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️</a> 
 <br><br>前言
<br>熟#⭐️⭐️⭐️⭐️ 以上 -&gt; 70%
<br>sychronization 要trace code，鎖的時機點，誰鎖誰
<br><br><br><br><br><br><br><br><br><br><br>相關好用筆記連結<br>
<a rel="noopener" class="external-link" href="https://hackmd.io/@Chang-Chia-Chi/OS/https%3A%2F%2Fhackmd.io%2F%40Chang-Chia-Chi%2FOS-CH5" target="_blank">https://hackmd.io/@Chang-Chia-Chi/OS/https%3A%2F%2Fhackmd.io%2F%40Chang-Chia-Chi%2FOS-CH5</a>]]></description><link>考研筆記/作業系統/⭐️作業系統.html</link><guid isPermaLink="false">考研筆記/作業系統/⭐️作業系統.md</guid><pubDate>Wed, 13 Mar 2024 09:52:14 GMT</pubDate></item><item><title><![CDATA[整數除法]]></title><description><![CDATA[ 
 <br><br>int Myst(int x, int n ){
	...
}
複製]]></description><link>考研筆記/資料結構/ch1演算法/數學/整數除法.html</link><guid isPermaLink="false">考研筆記/資料結構/CH1演算法/數學/整數除法.md</guid><pubDate>Wed, 13 Mar 2024 09:49:07 GMT</pubDate></item><item><title><![CDATA[Ackerman's function]]></title><description><![CDATA[ 
 <br><br>
A(m, n)
<br>=&gt;n+1, if m = 0<br>
=&gt;A(m-1, 1), if n = 0<br>
=&gt;A(m-1, A(m, n-1)), otherwise<br>
<br>求A(2, 2)之值：
<br>
A(2, 2)-&gt;A(1, A(2, 1))-&gt;A(1, A(1, A(2, 0)))-&gt;....
]]></description><link>考研筆記/資料結構/ch1演算法/數學/ackerman&apos;s-function.html</link><guid isPermaLink="false">考研筆記/資料結構/CH1演算法/數學/Ackerman&apos;s function.md</guid><pubDate>Wed, 13 Mar 2024 09:28:21 GMT</pubDate></item><item><title><![CDATA[Algo定義]]></title><description><![CDATA[ 
 <br><br>解決特定問題之有限個step/敘述/指令 之集合，而algo之撰寫必須滿足下列5 critieria<br>
<br>Input：至少提供&gt;={空}個輸入資料。
<br>Output：至少要產生&gt;=個輸出結果。
<br>Definiteness：每個步驟必須是clear and unambiguous。
<br>Finiteness(有限性)：algo在執行or追蹤有限個步驟後，必須能夠終止。<br>
Note:此性質是Program與Algo之一大不同之點 -&gt;Program不一定要滿足“有限性”
<br>Effectiveness(有效性)：人在追蹤or執行Algo時每個steps/指令/敘述 必須是“夠基本”，及人可以用紙筆執行每一條敘述。<br>
Note:&lt;動機&gt;當演算法完成，如何判斷他是對的
]]></description><link>考研筆記/資料結構/ch1演算法/數學/algo定義.html</link><guid isPermaLink="false">考研筆記/資料結構/CH1演算法/數學/Algo定義.md</guid><pubDate>Wed, 13 Mar 2024 09:48:47 GMT</pubDate></item><item><title><![CDATA[Binomial coe.]]></title><description><![CDATA[ 
 <br><br>C幾取幾<br>
<br>
Q1:

<br>
Ans:
int Bin(int n, int m){
	if(m == 0 || n == m)return 1;
	else return Bin(n - 1, m)+Bin(n-1, m-1);

}
複製



<br>
Q2:依上述Code求Bin(5, 3)值和呼叫次數：

<br>Ans:<br>
T(n, m) = T(n-1, m-1)+T(n-1, m)+1<br>
T(1, 0) = 1<br>
T(0, 0) = 1


<br>
Q3(極少考):Design Iterative or Dynamic programing 求C(n, k)=?

<br>Ans:

int Bin(int n, int k){
	int c[n+1][k+1];
	for(int i = 0; i&lt;= n; i++){
		for(int j = 0; j&lt;=min(i, k);j++){
			if(j==0||j==i)c[i][j] = 1;
			else c[i][j]= c[i-1][j-1]+c[i-1][j];
		}
	}
	return c[n][k];
}
複製

]]></description><link>考研筆記/資料結構/ch1演算法/數學/binomial-coe..html</link><guid isPermaLink="false">考研筆記/資料結構/CH1演算法/數學/Binomial coe..md</guid><pubDate>Wed, 13 Mar 2024 09:47:02 GMT</pubDate></item><item><title><![CDATA[Factorial]]></title><description><![CDATA[ 
 <br>
<br>


<br>Q1:write iterative Algo/Code

<br>Ans:

int Fac(int n){
	int s = 1;
	int i;
	if(n == 0)return 1;
	else{
		for (i=1; i&lt;= n; i++)
			s = s* i;
		return s;
	}
}
複製

<br>Q2:write Recursive Algo/Code

<br>Ans:KEY:記住數學定義的遞迴式

int Fac(int n){
	if(n == 0)
		return 1;
	else{
		return Fac(n-1)* n;
	}
}
複製



]]></description><link>考研筆記/資料結構/ch1演算法/數學/factorial.html</link><guid isPermaLink="false">考研筆記/資料結構/CH1演算法/數學/Factorial.md</guid><pubDate>Wed, 13 Mar 2024 09:48:19 GMT</pubDate></item><item><title><![CDATA[Fibonacci Number ⭐️⭐️⭐️⭐️⭐️]]></title><description><![CDATA[ 
 <br><br>
<br>
定義：

<br>

0 , if n = 0<br>
1 , if n = 1<br>
F(n-1)+F(n-2), if n&gt;= 2




<br>
例：求&lt;=500之最大費式數Fa。Fa = ?, a = ?<br>
F(14)

<br>
Q1:Write a Recursive Algo of  Fn

O({n在指數})

int Fib(int n){
	if(n == 0)return 0;
	if(n == 1)return 1;
	return Fib(n-1)+ Fib(n-2);
}
複製
延伸：問次數<br>
T(n) = T(n-1)+T(n-2)+1

<br>
Q2:Write a Iterative Algo of Fn

O(n)

int Fib(int n){
	if(n == 0)return 0;
	else if(n == 1)return 1;
	else{
		int a = 0, b = 1, c;
		for(int i = 2; i&lt;= n ; i++){
			c = a + b
			a = b;
			b = c;
		}
		return c;
	}
}
複製

<br>
Q3:使用DP方法求Fn
	int A[n + 1];
	int Fib(int n){
		A[0] = 0;
		A[1] = 1;
		if (n == 0)return A[0];
		else if(n == 1)return A[1];
		else{
			for(int i = 2; i&lt;=n; i++){
				A[i] = A[i-1] + A[i-2];
			}
			return A[n];
		}
	} 
複製
延伸：問次數、個別被呼叫次數：

<br>
T(n)
<br>=&gt;T(n+1)+T(n+2), if n &gt;= 1;
=&gt;T(2), if n = 0
複製Dataview (inline field '&gt;T(n+1)+T(n+2), if n &gt;= 1;
=&gt;T(2), if n = 0'): Error: 
-- PARSING FAILED --------------------------------------------------

&gt; 1 | &gt;T(n+1)+T(n+2), if n &gt;= 1;
    | ^
  2 | =&gt;T(2), if n = 0

Expected one of the following: 

'(', 'null', boolean, date, duration, file link, list ('[1, 2, 3]'), negated field, number, object ('{ a: 1, b: 2 }'), string, variable
<br>Question“../../../img/截圖 2022-12-29 下午6.38.32.jpg” could not be found.]]></description><link>考研筆記/資料結構/ch1演算法/數學/fibonacci-number-⭐️⭐️⭐️⭐️⭐️.html</link><guid isPermaLink="false">考研筆記/資料結構/CH1演算法/數學/Fibonacci Number ⭐️⭐️⭐️⭐️⭐️.md</guid><pubDate>Wed, 13 Mar 2024 09:22:15 GMT</pubDate></item><item><title><![CDATA[Towers of Hanoi]]></title><description><![CDATA[ 
 <br><br>
河內塔
<br>
<br>


<br>每次只能移動一個盤子
<br>過程中，小盤不可在大盤之下


<br>


<br>Ans:

<br>code

void Hanoi(int n, char A, char B, char C){
	if(n == 1)
		printf("move disk %d from %c to %c \n", 1, A, C);
	else{
		// move n-1 plate form A to B
		Hanoi(n-1, A, C, B);
		// move 1 plate form A to C
		Hanoi(1, A, B, C); // or printf("...")
		// move n-1 plate in B to C
		Hanoi(n-1, B, A, C);
	}
}
複製

<br>


<br>


<br>

T(n) = T(n-1)+1+T(n-1) = 2T(n-1) + 1


<br>

T(n) = 2^n -1






]]></description><link>考研筆記/資料結構/ch1演算法/數學/towers-of-hanoi.html</link><guid isPermaLink="false">考研筆記/資料結構/CH1演算法/數學/Towers of Hanoi.md</guid><pubDate>Wed, 13 Mar 2024 09:36:37 GMT</pubDate></item><item><title><![CDATA[X^n]]></title><description><![CDATA[ 
 <br><br>
<br>慢速
<br>int exp(n){
	if(n == 0)return 1;
	else
		return exp x*exp(n-1);
}
複製<br>
<br>加速：
<br>
X^2 = X  (X^2)^n/2, if n是奇數<br>
X^2 = 1  (X^2)^n/2, if n是偶數
]]></description><link>考研筆記/資料結構/ch1演算法/數學/x^n.html</link><guid isPermaLink="false">考研筆記/資料結構/CH1演算法/數學/X^n.md</guid><pubDate>Wed, 13 Mar 2024 09:50:04 GMT</pubDate></item><item><title><![CDATA[算行數例題]]></title><description><![CDATA[ 
 <br>算行數例題<br>
“../../IMG_2251.heic” could not be found.<br>“../../IMG_2253.heic” could not be found.<br>“../../IMG_2254.heic” could not be found.<br>“../../IMG_2255.heic” could not be found.<br>“../../IMG_2256.heic” could not be found.<br>“../../IMG_2257.heic” could not be found.<br>“../../IMG_2258.heic” could not be found.<br>“../../IMG_2259.heic” could not be found.<br>“../../IMG_2260.heic” could not be found.]]></description><link>考研筆記/資料結構/ch1演算法/算行數例題.html</link><guid isPermaLink="false">考研筆記/資料結構/CH1演算法/算行數例題.md</guid><pubDate>Wed, 13 Mar 2024 09:50:25 GMT</pubDate></item><item><title><![CDATA[數學類]]></title><description><![CDATA[ 
 <br><br><br><br><br><br><br><br><br><br>(原題目P.55課本42）]]></description><link>考研筆記/資料結構/ch1演算法/數學類.html</link><guid isPermaLink="false">考研筆記/資料結構/CH1演算法/數學類.md</guid><pubDate>Wed, 13 Mar 2024 09:51:21 GMT</pubDate></item><item><title><![CDATA[Analysis(or 預估)方法]]></title><description><![CDATA[ 
 <br><br><br>
<br>例1:不考慮"指令難易程度"<br>
程式：
//int count = 0;
int test(int n){
	int i;
	int s = 0;
	//count++;
	for(i = 1; i&lt;= n; i++){
		//count++;
		s = s+ i;
		//count++;
	}
	//count++; //for失敗的那次
	return s;
}
複製

<br>宣告全域變數count
<br>在適當處加入count++
<br>統計<br>
Ans: 1+2n+1+1 = 2n+3次


<br>例2:考量"指令難易程度"

<br>

=&gt; 5n+5


]]></description><link>考研筆記/資料結構/ch1演算法/analysis(or-預估)方法.html</link><guid isPermaLink="false">考研筆記/資料結構/CH1演算法/Analysis(or 預估)方法.md</guid><pubDate>Wed, 13 Mar 2024 09:36:53 GMT</pubDate></item><item><title><![CDATA[CH1演算法]]></title><description><![CDATA[<a class="tag" href="?query=tag:⭐️⭐️⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️⭐️⭐️</a> <a class="tag" href="?query=tag:⭐️⭐️⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️⭐️⭐️</a> 
 <br><br>複製<br><br><br><br>
<br>Recursion
<br>Non-Recursion
<br><br>
<br>Direct recursion：Algo/Code中含有自我呼叫敘述存在
<br>Indirect：多個模組/副程式之間彼此行程calling cycle
<br>Tail：是Direct recursion之一種，Recursion結束後之下一個執行敘述是END敘述
<br><br><br>
<br>給問題，write Recursive Algo/Code
<br>給Algo/Code，求追蹤其執行結果、呼叫次數、功能、複雜度
<br><br>
<br><a data-href="數學類" href="/考研筆記/資料結構/ch1演算法/數學類.html" class="internal-link" target="_self" rel="noopener">數學類</a> <a href=".?query=tag:⭐️⭐️⭐️⭐️⭐️" class="tag" target="_blank" rel="noopener">#⭐️⭐️⭐️⭐️⭐️</a> 
<br>未來章節
<br>其他

<br><a data-href="Towers of Hanoi" href="/考研筆記/資料結構/ch1演算法/數學/towers-of-hanoi.html" class="internal-link" target="_self" rel="noopener">Towers of Hanoi</a>
<br><a data-href="Permutation" href="/考研筆記/資料結構/ch1演算法/permutation.html" class="internal-link" target="_self" rel="noopener">Permutation</a> (排列組合) <a href=".?query=tag:⭐️⭐️⭐️⭐️⭐️" class="tag" target="_blank" rel="noopener">#⭐️⭐️⭐️⭐️⭐️</a> 


<br><br><br>
定義：令sp(p)代表space requirement of Algo. P, 則sp(p) = <a class="internal-link" data-href="Fixed space.md" href="/考研筆記/資料結構/ch1演算法/fixed-space.html" target="_self" rel="noopener">Fixed space</a> ＋ <a class="internal-link" data-href="Variable space.md" href="/考研筆記/資料結構/ch1演算法/variable-space.html" target="_self" rel="noopener">Variable space</a>。
<br>
<br>


假設<br>
int 佔2byte,<br>
float 佔4byte,<br>
address 佔2byte,<br>
且list[]採用call-by-address傳遞。<br>
求此code之sp(i) = ?
float rsum(float list[], int n){
	if(n!= 0)
		return rsum(list, n-1)+ list[n-1];
	return list[0];
}
複製


<br>先決定每發生一次resursion 要push多少data 大小到stack<br>
參數值：list[], n (2 + 2)。區域變數值： 無。反回位址：必定需要(2) =&gt; 6 byte
<br>共發生幾次遞迴<br>
=&gt; n次（不含進入時的那次）


<br><br>
定義：令T(p)代表Algo./Code: P之Time需求，則T(p) = Development Time + Execution Time。本課程旨care "exec. Time"
<br>
<br>


<br>


<br>




<br><br>
定義：令sp(p)代表space requirement of Algo. P, 則sp(p) = <a class="internal-link" data-href="Fixed space.md" href="/考研筆記/資料結構/ch1演算法/fixed-space.html" target="_self" rel="noopener">Fixed space</a> ＋ <a class="internal-link" data-href="Variable space.md" href="/考研筆記/資料結構/ch1演算法/variable-space.html" target="_self" rel="noopener">Variable space</a>。
<br>
<br>


假設<br>
int 佔2byte,<br>
float 佔4byte,<br>
address 佔2byte,<br>
且list[]採用call-by-address傳遞。<br>
求此code之sp(i) = ?
float rsum(float list[], int n){
	if(n!= 0)
		return rsum(list, n-1)+ list[n-1];
	return list[0];
}
複製


<br>先決定每發生一次resursion 要push多少data 大小到stack<br>
參數值：list[], n (2 + 2)。區域變數值： 無。反回位址：必定需要(2) =&gt; 6 byte
<br>共發生幾次遞迴<br>
=&gt; n次（不含進入時的那次）


<br><br>
定義：令T(p)代表Algo./Code: P之Time需求，則T(p) = Development Time + Execution Time_。本課程旨care "exec. Time"
<br>
<br>


<br>


<br>




<br><br><a class="internal-link" data-href="算行數例題.md" href="/考研筆記/資料結構/ch1演算法/算行數例題.html" target="_self" rel="noopener">算行數例題</a><br><br>去看演算法第一章<br>
目的：表達數學（時間）函數的成長速率之等級
<br><br>
<br>𝝤(Big-oh)
<br>𝝮(omega)
<br>𝝝(Theta)
<br>𝝾(little-oh)
<br>𝞈(little-omega)
<br><a class="internal-link" data-href="../../演算法/CH1 Analyzing Algorithm/Extended Master Theorem.md" href="/考研筆記/演算法/ch1-analyzing-algorithm/extended-master-theorem.html" target="_self" rel="noopener">Extended Master Theorem</a><br><br>example例：T(n)= T(n-1) + T(n-2), T(0) = 0, T(1) = 1, 求T(n) = O(?)<br>
ANS:<br>
特徵方程式x^2 = x + 1 =&gt; x^2 -x - 1 = 0<br>
公式解x = {x1, x2}<br>
T(n) = Ax1^n + Bx2^n<br>
T(0) = 0, T(1) = 1代入得解A, B。<br>
T(n) = Ax1^n + Bx2^n<br>]]></description><link>考研筆記/資料結構/ch1演算法/ch1演算法.html</link><guid isPermaLink="false">考研筆記/資料結構/CH1演算法/CH1演算法.md</guid><pubDate>Wed, 13 Mar 2024 09:49:49 GMT</pubDate></item><item><title><![CDATA[Fixed space]]></title><description><![CDATA[ 
 <br>Fixed space 需求: code space + 變數space +常數sapce]]></description><link>考研筆記/資料結構/ch1演算法/fixed-space.html</link><guid isPermaLink="false">考研筆記/資料結構/CH1演算法/Fixed space.md</guid><pubDate>Wed, 13 Mar 2024 09:48:30 GMT</pubDate></item><item><title><![CDATA[Permutation]]></title><description><![CDATA[ 
 <br><br><br>
!!觀念：輪流當head字元
<br><br>void Perm(char* A, int i, int n){
	//列印A[i]~A[n]排列組合, i&lt;= n
	// Assume A:[1..n] of char
	if(i == n){
		for(int j = 0; j &lt;= n; j++){
			printf("%c", A[j]);
			// 排序數量加一
		}
	}else{
		for(int j = i; j&lt;= n ;k++){//j控制跟第j-i個換
			SWAP(A[i], A[j]);//換A[j]當頭。實練輪流當頭的「換頭」步驟
			Perm(A, i+1, n);//A[i+1:n]的排列組合
			SWAP(A[i], A[j]);//還原
		}
	}
}
複製<br><br>A = abc, 求Perm(A, 0, 2) 寫出輸出順序！！<br>
abc acb bac bca cba cab
<br><br>
n個data有n!種排列組合，每列印一種花O(n) =&gt; total: O(n!*n)
]]></description><link>考研筆記/資料結構/ch1演算法/permutation.html</link><guid isPermaLink="false">考研筆記/資料結構/CH1演算法/Permutation.md</guid><pubDate>Wed, 13 Mar 2024 09:48:32 GMT</pubDate></item><item><title><![CDATA[Variable space]]></title><description><![CDATA[ 
 <br>Variable space 需求:<br>
<br>參數為結構型參數 且採用call-by-value參數傳遞方法，或是call-by-address
<br>Stack space for 'Recursion' :<br>
sp(n) = c + sp(i)

我們只關心sp(i)的大小<br>
call-by-address -&gt; sp(i) = 0


]]></description><link>考研筆記/資料結構/ch1演算法/variable-space.html</link><guid isPermaLink="false">考研筆記/資料結構/CH1演算法/Variable space.md</guid><pubDate>Wed, 13 Mar 2024 09:47:56 GMT</pubDate></item><item><title><![CDATA[Array 中元素儲存位址計算 <a href="?query=tag:%E2%AD%90%EF%B8%8F%E2%AD%90%EF%B8%8F%E2%AD%90%EF%B8%8F" class="tag" target="_blank" rel="noopener">#⭐️⭐️⭐️</a>]]></title><description><![CDATA[<a class="tag" href="?query=tag:⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️</a> <a class="tag" href="?query=tag:⭐️⭐️⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️⭐️⭐️</a> <a class="tag" href="?query=tag:⭐️⭐️⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️⭐️⭐️</a> <a class="tag" href="?query=tag:⭐️⭐️⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️⭐️⭐️</a> <a class="tag" href="?query=tag:⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️</a> <a class="tag" href="?query=tag:⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️</a> <a class="tag" href="?query=tag:幾乎不考" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#幾乎不考</a> <a class="tag" href="?query=tag:⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️</a> 
 <br><br><br><img alt="../img/截圖 2022-10-29 下午6.37.22.jpg" src="/lib/media/截圖-2022-10-29-下午6.37.22.jpg" style="width: 200px; max-width: 100%;"><br><br><img alt="../img/截圖 2022-10-29 下午7.17.01.jpg" src="/lib/media/截圖-2022-10-29-下午7.17.01.jpg" style="width: 400px; max-width: 100%;"><br>四大題型<br>
<br>給所有必要資訊，求A[i, j]位址<br>
<img alt="../img/截圖 2022-10-29 下午7.17.19.jpg" src="/lib/media/截圖-2022-10-29-下午7.17.19.jpg" style="width: 400px; max-width: 100%;">
<br>給兩格已知元素位址以及d，求其他資訊<br>
key:需自行判斷row or column major<br>
<img src="/lib/media/截圖-2022-10-29-下午7.22.47.jpg">
<br>給兩個已知元素位址及d，但判斷出Row Col major皆可能，則兩者皆需求算<br>
<img alt="../img/截圖 2022-10-29 下午7.29.15.jpg" src="/lib/media/截圖-2022-10-29-下午7.29.15.jpg" style="width: 500px; max-width: 100%;">
<br>給予三個元素位址判斷出Row or Col major後求出3個未知數(m, n, d)
<br>若題目宣告A[m][n]，等同於A[0..m-1][0..n-1] （同C語言）<br><br>
≧2維陣列，儲存方式也是兩種

<br>Row-major:由左而右看待 ----&gt;
<br>Colemn-major:由右而左 &lt;---

<br><img alt="../img/截圖 2022-10-31 下午2.42.43.jpg" src="/lib/media/截圖-2022-10-31-下午2.42.43.jpg" style="width: 500px; max-width: 100%;"><br><br><br><br>下三角矩陣<br>
<br>Row-major:<br>
k = {前面i-1（橫）列的元素}+{第i列上的第？格}<br>
= i(i-1)/2 + j
<br>Col-major:<br>
k = {前面j-1行的元素}+{第j行上的第？格}<br>
= n(j-1)-(0+1+2+..+(j-2)) + i-(j-1)<br>
= n(j-1)- j(j-1)/2 + i
<br>上三角矩陣<br>
<br>Row-major:<br>
k = {前面j-1列的元素}+{第j列上的第？格}<br>
= j(j-1)/2 + i
<br>Col-major:<br>
k = {前面i-1行的元素}+{第i行上的第？格}<br>
= n(i-1)-(0+1+2+..+(i-2)) + j-(i-1)<br>
= n(i-1)- i(i-1)/2 + j
<br><img alt="../img/截圖 2022-10-31 下午3.28.14.jpg" src="/lib/media/截圖-2022-10-31-下午3.28.14.jpg" style="width: 300px; max-width: 100%;"><br><br>
定義：A是nxn矩陣且A[i, j] = A[j, i]
<br>有效存放方式：<br>
只存在上三角or下三角<br>Question“../img/截圖 2022-10-31 下午4.05.54.jpg” could not be found.<br>
“../img/截圖 2022-10-31 下午4.06.06.jpg” could not be found.<br><br>
令A (a, n, b) 是一個Band Matrix<br>
代表：

<br>A是一個nxn矩陣
<br>A中對角線（含）左下a條斜線是元素
<br>A中對角線（含）右上b條斜線是元素
<br>其他是空(0)

<img alt="../img/截圖 2022-10-31 下午3.57.11.jpg" src="/lib/media/截圖-2022-10-31-下午3.57.11.jpg" style="width: 150px; max-width: 100%;">
<br><img alt="../img/截圖 2022-10-31 下午4.06.29.jpg" src="/lib/media/截圖-2022-10-31-下午4.06.29.jpg" style="width: 400px; max-width: 100%;"><br><img alt="../img/截圖 2022-10-31 下午4.28.02.jpg" src="/lib/media/截圖-2022-10-31-下午4.28.02.jpg" style="width: 400px; max-width: 100%;"><br><br><br><br>回收single link list<br>反轉single link list <a href=".?query=tag:⭐️⭐️⭐️⭐️⭐️" class="tag" target="_blank" rel="noopener">#⭐️⭐️⭐️⭐️⭐️</a><br>
<img alt="../img/截圖 2022-10-31 下午4.41.40.jpg" src="/lib/media/截圖-2022-10-31-下午4.41.40.jpg" style="width: 200px; max-width: 100%;"><br><br>
特性：

<br>不論從何點開始都可以辦訪所有點
<br>回收整條給AV-list, 及連結兩條串列 -&gt;O(1)

<br>回收整條list給AV-list<br>
<img alt="../img/截圖 2022-10-31 下午4.55.02.jpg" src="/lib/media/截圖-2022-10-31-下午4.55.02.jpg" style="width: 200px; max-width: 100%;"><br>Concatenate（連結） A, B兩個Circulat link list<br>
<img alt="../img/截圖 2022-10-31 下午4.55.17.jpg" src="/lib/media/截圖-2022-10-31-下午4.55.17.jpg" style="width: 200px; max-width: 100%;"><br><br>Insert <a href=".?query=tag:⭐️⭐️⭐️⭐️⭐️" class="tag" target="_blank" rel="noopener">#⭐️⭐️⭐️⭐️⭐️</a><br>
insert t node after x node<br>
<img alt="../img/截圖 2022-10-31 下午5.09.53.jpg" src="/lib/media/截圖-2022-10-31-下午5.09.53.jpg" style="width: 200px; max-width: 100%;"><br>
Delete<br>
delete x node<br>
<img alt="../img/截圖 2022-10-31 下午5.10.09.jpg" src="/lib/media/截圖-2022-10-31-下午5.10.09.jpg" style="width: 200px; max-width: 100%;"><br><br><br><br>
定義：令A=(a1, a2, ..., an)是general list，其中ai是A中的元素，而且ai的type有兩種:

<br>Atomic data
<br>Sublist

<br>術語<br>
<br>|A|:A中的元素個數
<br>Head of A: A中的第一個元素
<br>Tail of A: A中除了Head以外的元素集合，是一個generalize list
<br><img alt="../img/截圖 2022-10-31 下午5.33.19.jpg" src="/lib/media/截圖-2022-10-31-下午5.33.19.jpg" style="width: 250px; max-width: 100%;"><br>
Data Structure <a href=".?query=tag:⭐️⭐️⭐️" class="tag" target="_blank" rel="noopener">#⭐️⭐️⭐️</a><br>
<img alt="../img/截圖 2022-10-31 下午5.39.56.jpg" src="/lib/media/截圖-2022-10-31-下午5.39.56.jpg" style="width: 300px; max-width: 100%;"><br>Generalize list 之 recursive operations<br>
<br>Copy 一條串列
<br>Equal(S, T):判斷兩串列是否相同
<br>Depth(S):求S串列深度
<br>下列皆不可作用在recursive的General list e.g: C = (a, C)<br><br>copy<br>Copy(orig){
	if(orig == Nil)t = nil;
	else{
		new(t);
		t-&gt;Tag = orig-&gt;Tag;
		if(orig-&gt;Tag == False)
			t-&gt;Data = orig-&gt;Data;
		else
			t-&gt;dlink = Copy(orig-&gt;dlink);
		t-&gt;Next = Copy(orig-&gt;Next);
	}
	return t;
}
複製<br><br>Equal(S, T)<br>Equal(S, T){
	res = False:
	if(S==Nil and T == Nil)res = True;
	else if(S != Nil and T != Nil){//都還有Node 
		if(S-&gt;Tag == T-&gt;Tag){
			if(S-&gt;Tag == False){// 用Atomic data的情況
				if(S-&gt;Data == T-&gt;Data)
					x = True;
				else x = False;
			}
			else //用dlink的情況
				x = Equal(S-&gt;dlink, T-&gt;dlink);
			if(x == True)
			res = Equal(S-&gt;Next, T-&gt;Next);
		}
	}
	return res;
	
}
複製<br><br>Depth(S) 往下延伸幾層<br>
= 0, if S是空串列<br>
= 1+MAX{depth(ai) | ai為S中子串列元素}, otherwise<br>Depth(S){
	if(S == Nil)return 0;
	else{
		MAX = 0;
		P = S;
		while(P != Nil){
			if(P-&gt;tag == True){
				n = Depth(p-&gt;dlink);//子串列深度
				if(n &gt; MAX) 
					MAX = n;
			}
			P = P-&gt;Next;
		}
		return MAX+1;//有遞迴才會加1 -&gt; 有遇到sublist時
	}
}
複製<br><br><br>[法一]<br>
按照指數由高到低依序儲存個項次的 係數值<br>
<img alt="../img/截圖 2022-10-31 下午8.09.32.jpg" src="/lib/media/截圖-2022-10-31-下午8.09.32.jpg" style="width: 300px; max-width: 100%;"><br>
缺點:若多項式A中有很多0項次 -&gt; 一堆存0 -&gt;浪費空間<br>[法二]<br>
只存非0項次的 指數和係數<br>
作法：若有k個非零項次，準備A[1..2k+1]<br>
<img alt="../img/截圖 2022-10-31 下午8.13.44.jpg" src="/lib/media/截圖-2022-10-31-下午8.13.44.jpg" style="width: 200px; max-width: 100%;"><br>
缺點：若非零項次很多-&gt;浪費空間<br><br>[法ㄧ]<br>
使用single (or 其他)link list 表示<br>
<img alt="../img/截圖 2022-10-31 下午8.19.57.jpg" src="/lib/media/截圖-2022-10-31-下午8.19.57.jpg" style="width: 300px; max-width: 100%;"><br>
缺點：缺乏一致性的Node結構來表示各種多項式。<br>[法二] <a href=".?query=tag:⭐️⭐️" class="tag" target="_blank" rel="noopener">#⭐️⭐️</a><br>
利用Generalize list觀念表示多項式<br><img alt="../img/截圖 2022-10-31 下午8.36.56.jpg" src="/lib/media/截圖-2022-10-31-下午8.36.56.jpg" style="width: 500px; max-width: 100%;"><br><br>稀疏矩陣 -&gt; 0元素很多<br><br>[法一]<br>
直接利用mxn的陣列<br>
-&gt; 浪費一堆空間<br>
[法二]<br>
只存非0元素的資訊 &lt;row, col, value&gt;<br>
作法：<br>
若mxn sparse matrix中有k個非零元素<br>
-&gt; 準備A[0..k, 1..3]來存放<br><img alt="../img/截圖 2022-10-31 下午8.46.45.jpg" src="/lib/media/截圖-2022-10-31-下午8.46.45.jpg" style="width: 500px; max-width: 100%;"><br><br><img alt="../img/截圖 2022-10-31 下午9.02.59.jpg" src="/lib/media/截圖-2022-10-31-下午9.02.59.jpg" style="width: 500px; max-width: 100%;">]]></description><link>考研筆記/資料結構/ch2-array&amp;-ch4-link-list/ch2-array&amp;-ch4-link-list.html</link><guid isPermaLink="false">考研筆記/資料結構/CH2 Array&amp; CH4 Link List/CH2 Array&amp; CH4 Link List.md</guid><pubDate>Mon, 04 Mar 2024 08:07:16 GMT</pubDate><enclosure url="lib/media/截圖-2022-10-29-下午6.37.22.jpg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib/media/截圖-2022-10-29-下午6.37.22.jpg&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[括號法]]></title><description><![CDATA[ 
 <br><br>以Infix轉Postfix之steps<br>
<br>對Infix加上“完整的”括號配對（需注意優先權、結合性）
<br>operator去取代離他最近的右括號
<br>刪左括號，其餘由左而右寫出
<br><a class="internal-link" data-href="常見的operator優先表.md" href="/考研筆記/資料結構/ch3-stack-and-queue/常見的operator優先表.html" target="_self" rel="noopener">常見的operator優先表</a><br><a class="internal-link" data-href="Infix 轉成Postfix 括號法.md" href="/考研筆記/資料結構/ch3-stack-and-queue/infix-轉成postfix-括號法.html" target="_self" rel="noopener">Infix to Postfix using括號法</a>]]></description><link>考研筆記/資料結構/ch3-stack-and-queue/括號法.html</link><guid isPermaLink="false">考研筆記/資料結構/CH3 Stack and Queue/括號法.md</guid><pubDate>Wed, 13 Mar 2024 09:46:50 GMT</pubDate></item><item><title><![CDATA[常見的operator優先表]]></title><description><![CDATA[ 
 <br>常見的operator優先表<br>]]></description><link>考研筆記/資料結構/ch3-stack-and-queue/常見的operator優先表.html</link><guid isPermaLink="false">考研筆記/資料結構/CH3 Stack and Queue/常見的operator優先表.md</guid><pubDate>Wed, 13 Mar 2024 09:23:42 GMT</pubDate></item><item><title><![CDATA[CH3 Stack and Queue]]></title><description><![CDATA[ 
 <br><br><br>
定義：是一個具有LIFO之有序串列

<br>insert 元素動作要Push
<br>delete 元素動作叫Pop

且push 和pop動作皆發生在同一端，稱為Top
<br><br>(記)(選擇題)(課本p.95-96標題)<br>（六）ADD<br>
（9）反序<br>
（10）迷宮<br>
（12）Compiler剖析之一例，palindrome(迴文)之判斷<br>
（13）八后問題<br><br><br><br>
定義：將n個Data 依序push 入stack，但在過程中，可穿插執行任意合法的pop輸出data，依此rules，所有n個data之輸出排列組合，稱之
<br>n個data stack permutations 數目=1/(n+1)*C(2n,n)<br>Note:公式也=<img alt="../img/image.jpg" src="/lib/media/image.jpg" style="width: 300px; max-width: 100%;"><br><br>
<br>n個Node可以形成的不同binary tree 結構數目
<br>n個"("與n個")"之合法配對數目
<br>n+1個matrix相乘之乘法組合數目（algo.中)<br>
<img alt="../img/image 1.jpg" src="/lib/media/image-1.jpg" style="width: 200px; max-width: 100%;">
<br>n部台車入閘再出閘之順序組合<img alt="../img/image 2.jpg" src="/lib/media/image-2.jpg" style="width: 200px; max-width: 100%;">
<br>Note:陷阱題<br>
<br>n 個matrix 相乘之乘法組合數？
<br>n台車無法出車順序=？
<br><br><br><br><br>// key : stack只能越放越「大」
while(Infix 尚未由左而右掃完){
	x = NextToken(Infix);
	if(x is operand)
		printf(x);
	else{ //x是operator
		if(x == ")"){
			repeat{
				y = pop(S);
				if(y!="(")printf(y);
			}until(y == "(")
		}
		else{ //其他operator
			switch(比較優先權(x, S-&gt;Top)){
				case "&gt;":
					push(S, x); 
					break;
				case "&lt;=":
					repeat{//把所有比x大的丟出來，達成優先的效果
						y = pop(S); 
						printf(y);
					}until(x &gt; S-&gt;Top)
			}
		}
	}
}
while(!IsEmpty(S)){
	y = pop(S);
	printf(y);
}
複製<br>Time:O(n), n = Infix長度<br>比較優先權的表<br><br>
題目目標<br>
將一infix轉乘Postfix，使用stack，描述詳細過程<br>
且stack size需&gt;?才夠<br>
<img alt="../img/1299FE09-F17B-4F89-B4A3-FB2B3533893B.jpeg" src="/lib/media/1299fe09-f17b-4f89-b4a3-fb2b3533893b.jpeg" style="width: 400px; max-width: 100%;"><br>
<img alt="../img/AC141488-FD49-4212-9948-56023450966D.jpeg" src="/lib/media/ac141488-fd49-4212-9948-56023450966d.jpeg" style="width: 400px; max-width: 100%;">
<br><br>Infix 轉成Prefix
<br>
A=(B+(C-D*E))/F$G
ans:
(A=((B+(C-(D*E)))/(F$G)))
=&gt; =A/+B-C*DE$FG
複製

<br>
a+ (b-c)/d * e
ans:
(a+(((b-c)/d)*e))
=&gt; +a*/-bcde
複製

<br>
規定優先權: (,) &gt; + &gt; / &gt; - &gt; *
且+,-右結合
*, /左結合
a+b+(c*d-f-g/h)
ans:
(a+(b+(c*(d-(f-(g/h)))))
=&gt; +a+b*c-d-f/gh
複製

<br><br>Postfix 轉成InfixKey: Postfix是op1 op2 operator

<br>
ABC-D+/E*
ans:
A/((B-C)+D)*E
=&gt; A/(B-C+D)*E
複製

<br>
a+ (b-c)/d * e
ans:
(a+(((b-c)/d)*e))
=&gt; +a*/-bcde
複製

<br>
規定優先權: (,) &gt; + &gt; / &gt; - &gt; *
且+,-右結合
*, /左結合
a+b+(c*d-f-g/h)
ans:
(a+(b+(c*(d-(f-(g/h)))))
=&gt; +a+b*c-d-f/gh
複製

<br><br>while(Postfix尚未由左往右掃完){
	x = NextToken(Postfix);
	if(x is operand){
		push(S, x);
	}
	else{
		1. pop stack取出適當數目之operands
		2. 計算
		3. 結果push回stack
	}
}
複製<br>stack內之值即為後序式結果值<br>Examplepostfix: 6 2 / 3 - 4 2 * +<br>
使用stack描述計算過程。<br>
且stack&gt;= ?才足夠<br>
“../img/截圖 2022-09-24 下午7.54.43.jpg” could not be found.<br>Algo. Time: O(n), n= Postfix長度<br>Questionpostfix: ABC-D+/E*<br>
使用stack描述計算過程。<br>
且stack&gt;= ?才足夠<br><br>QuestionChoose the Correct items<br>
(A)Infix 轉postfix中，stack內放的是operator(除了")")<br>
(B)Postfix中不會有括號出現<br>
(C)Postfix計算時，stack內放的是operands<br>
(D)Postfix計算比Prefix計算容易for Compiler
Ans: ABC<br><br><br>類似，差別在Prefix是從右往左掃，先pop的放前面，做運算。<br><br>使用S, T兩個stack(T是為了反序列印用)<br>
Infix是由右往左掃<br>
"(", ")"處理相反<br>
左結合：stack外優先權&gt;stack<br>
由結合：內外相等<br>
要列印的先push到T，最後pop&amp;print出來<br><br>
<br><a class="internal-link" data-href="Parsing括號配對.md" href="/考研筆記/資料結構/ch3-stack-and-queue/parsing括號配對.html" target="_self" rel="noopener">Parsing括號配對</a>
<br><a class="internal-link" data-href="Parsing回文判別.md" href="/考研筆記/資料結構/ch3-stack-and-queue/parsing回文判別.html" target="_self" rel="noopener">回文判別</a>
<br><br>
定義：<br>
是一個有FIFO性質的有序串列

<br>Insert 元素動作叫Enqueue插入元素到Rear(尾端)
<br>Delete元素叫Dequeue從Queue之Front(前端)刪除

<br><br>
<br>OS中各種Queues
<br>Buffer(緩衝區)FIFO設計
<br>Binary Tree 之Level-order Traversal
<br>Graph 之 BFS
<br>系統效能評估：Queueing Theorem
<br>日常生活中的排隊行為
<br><br>operators<br>
<br>Enqueue
<br>Dequeue
<br>IsEmpty
<br>IsFull
<br>Create(Q)
<br>Front(Q):回傳front元素，但不刪除
<br><br><br><br>
<br>Create(Q)

宣告Q: array[1..n] of items;<br>
Rear: int = 0;/指末端元素<br>
Front: int = 0;//指的是前端元素的前一個位置


<br>Enqueue(Q, item)
Enqueue(Q, item){
	if(Rear == n)return "Q滿"
	else{
		Rear ++;
		Q[Rear] = item;
	}
}
複製

<br>Dequeue(Q)
Dequeue(Q){
	if(Rear == front)return "Q空"
	else{
		front++;
		item = Q[front];
		return item;
	}
}
複製

<br>分析<br>
最大問題在於當Rear==n成立時，不代表Queue真的是滿的，極度浪費空間<br>
解決<br>
把元素往前挪（但operator運行時間加長）<br><br>Circular =&gt; front &amp; rear會循環跑<br>
<br>Create(Q)

宣告Q: (同linear array)<br>
array[0..n-1] of items;<br>
Rear: int = 0;//指末端元素<br>
Front: int = 0;//指的是前端元素的前一個位置


<br>Enqueue(Q, item)
Enqueue(Q, item){
   Rear = (Rear + 1)%n;
   if(Rear == Front){
	   Rear = (Rear-1)%n
	   return "Q滿";
	}
	else{
		Q[Rear] = item;
	}
}
複製

<br>Dequeue(Q)
Dequeue(Q){
    	if(Rear == front)return "Q空";
    	else{
    		Front = (Front+1)%n;
    		item = Q[Front];
    		return item;
    	}
}
複製

<br>分析<br>
<br>最多用可利用n-1個空間
<br>Enqueue, Dequeue 之time : O(1)
<br>判斷 Q空 跟 Q滿 的寫法一樣
<br><br>TipEnqueue到碰在一起 =&gt; 必定是滿的 =&gt; Tag = True<br>
Dequeue到碰在一起 =&gt; 必定是空的 =&gt; Tag = True<br>
<br>Create(Q)

宣告Q:<br>
array[0..n-1] of items;<br>
Rear: int = 0;//指末端元素<br>
Front: int = 0;//指的是前端元素的前一個位置<br>
Tag: Boolean  = False;//協助判斷Q空or滿


<br>Enqueue(Q, item)
Enqueue(Q, item){
	if(Rear == Front and Tag == True)
	   return "Q滿";
	else{
		Q[Rear] = item;
		if(Rear == Front)Tag = True;
		Rear++;
	}
}
複製

<br>Dequeue(Q)
Dequeue(Q){
	if(Rear == front and Tag == False)return "Q空";
	else{
		Front = (Front+1)%n;
		item = Q[Front];
		if(Rear == Front)Tag == False; 
		return item;
	}
}
複製

<br>分析<br>
<br>最多可用n格
<br>Time 皆為O(1)
<br>雖然充分使用n格，但實際執行時間比[法二]長一些（因為多了if測試）
<br>Example利用n, front, rear求出Q的元素個數<br>
ANS:(Rear - Front + n)%n<br><br><br>
<br>
Create(Q)

宣告:<br>
<a class="internal-link" data-href="Node.md" href="/考研筆記/資料結構/ch3-stack-and-queue/node.html" target="_self" rel="noopener">Node</a>結構<br>
rear, front: pointer = Nil;


<br>
Enqueue(Q, item)<br>
分析：

<br>case1: Q原本為空<br>
F-&gt;Nil，R-&gt;Nil ==&gt; F-&gt;Node1，R-&gt;Node1
<br>case2: Q原本不為空

Rear-&gt;next = {new node}<br>
Rear -&gt; {new node}
Enqueue(Q, item){
	new(T);
	t-&gt;Data = item;
	t-&gt;next = Nil;
	if(Front == Nil){
		Front = t;
		Rear = t;
 	}
	else Rear-&gt; next = t;
}
複製

<br>
Dequeue(Q)<br>
分析：

<br>case1: Q只有一個Node<br>
先把原node資訊保留(t, item)<br>
F = F-&gt;next<br>
R = Nil<br>
回收t<br>
return item
<br>case2: Q有&gt;1個Node<br>
先把原node資訊保留(t, item)<br>
F = F-&gt;next<br>
回收t<br>
return item

Dequeue(Q){
	if(Front == Nil)return "Q空";
	else{
		t= Front;
		item = Front-&gt;item;
		Front = Front-&gt; Next
		if(Front == Nil)
			Rear = Nil;
		free(t);
		return item;
    	}
}
複製

<br><br>優點：只用一個指標變數Rear指向尾端，Raer-&gt;Next指向前端<br>
<br>
Create(Q)

宣告:<br>
<a class="internal-link" data-href="Node.md" href="/考研筆記/資料結構/ch3-stack-and-queue/node.html" target="_self" rel="noopener">Node</a>結構<br>
Rear: pointer = Nil;


<br>
Enqueue(Q, item)<br>
分析：

<br>case1: Q原本為空
<br>{new Node}-&gt;Next = {new Node}<br>
R-&gt;{new Node}
<br>case2: Q原本不為空

{new node}-&gt;Next = Rear-&gt;next<br>
Rear-&gt;next = {new node}<br>
Rear -&gt; {new node}
Enqueue(Q, item){
    	new(t);
    	t-&gt;Data = item;
    	if(Rear == Nil) t-&gt;next = t;
    	else{
 	   	t-&gt;Next = Rear-&gt;Next;
 	   	Rear-&gt;next = t;
 	}
 	Rear -&gt; t;
}
複製

<br>
Dequeue(Q)<br>
分析：<br>
先保留R-&gt;next<br>
t = R-&gt;next<br>
item = R-&gt;next-&gt;item

<br>
case1: Q有&gt;1個Node<br>
R的下一個接到下下個（因為要取出下一個）
回收t<br>
return item

<br>
case2:Q只有一個node<br>
也就是若R-&gt;next == R，就是只有一個的意思<br>
所以把R = Nil並回收t就行


Dequeue(Q){
	if(Front == Nil)return "Q空";
	else{
		t= Rear-&gt;next;
		item = t-&gt;item;
		if(Rear-&gt;next == Rear)Rear = Nil;
		else{
			R-&gt;next = t-&gt;next
		}
		free(t);
		return item;
	}
}
複製

<br><br><br>原本的性質<br><br>
定義：此Queue運許插入任意權值資料，但刪除資料是刪最大/最小 元素，並非以FIFO order來刪<br>
提供至少兩個基本運作

<br>Insert
<br>Delete-MAX/ Delete-MIN(擇一)

Heap data structure最適合
<br><br>
定義：Queue之任意兩端皆可插入及刪除元素
<br><a class="internal-link" data-href="../CH9 Advanced Tree/SMMH(Symmetric Min-Max Heap).md" href="/考研筆記/資料結構/ch9-advanced-tree/smmh(symmetric-min-max-heap).html" target="_self" rel="noopener">SMMH</a><br><br>
定義：此Queue提供至少三個基本操作

<br>Insert
<br>Delete-min
<br>Delete-MAX

最適合的data structure：Min-Max Heap, <a class="internal-link" data-href="../CH9 Advanced Tree/Deap(Double-ended Heap).md" href="/考研筆記/資料結構/ch9-advanced-tree/deap(double-ended-heap).html" target="_self" rel="noopener">Deap</a>, <a class="internal-link" data-href="../CH9 Advanced Tree/SMMH(Symmetric Min-Max Heap).md" href="/考研筆記/資料結構/ch9-advanced-tree/smmh(symmetric-min-max-heap).html" target="_self" rel="noopener">SMMH</a>
<br><br>雖然兩著是不同性質的data structure(LIFO vs FIFO)，但彼此可相互製作。<br><br>
<br>Create(Q)
Create(Q){
	Create(S); // Stack
	Create(T); // Stack
}
複製

<br>Enqueue(Q, item)
Enqueue(Q, item){
    if(IsFull(S))return "Q滿";
    else push(S, item);
}
複製

<br>Dequeue(Q)

利用T再次反轉並且保留在T，以供後續使用

Dequeue(Q){
    if(IsEmpty(S) and IsEmpty(T))return "Q空";
    else{
 		if(IsEmpty(T))
 			while(!IsEmpty(S)){ // S移到T
 			   temp = pop(S);
 			   push(T, temp);
 			}
 		item = pop(T)
    }
    return item;
}
複製
大部分case T!= 空 =&gt; Time: O(1)<br>
少部分Time: O(n)<br>
Amotized cost:O(1)
<br><br>
<br>push(S, item)
push(S, item){
 	if(IsFull(Q)) return "S滿";
 	else Enqueue(Q, item);
}
複製

<br>pop(S)

dequeue出所有前面的並重新push回去，直到可以pop 出top元素

pop(S){
 	if(IsEmpty(Q))return "S空";
 	else{
 		n = Q.length;
 		for i = 1 to n-1
 			x = Dequeue(Q);
 			Enqueue(Q, x);
 		item = Dequeue(Q);
 	}
 	return item;
}
複製

<br><br>Example（少考）在一個array[1..n]上製作兩個stack<br>
Ans:<br>
兩個Stack從兩端往相反的方向放
宣告：<br>
A = array[1..n]<br>
top1 : int 0;<br>
top2 : int n+1;
push(i, item){ // push到Si
	if(i == 1){
		if(top1 +1 == top2)return "滿了";
		else{
			top1++;
			A[top1] = item;
		}
	}
	else{
		if(top2 -1 == top1)return "滿了";
		else{
			top2--;
			A[top2] = item;
		}
	}
}
複製
pop(i){
	if(i == 1){
		if(top1 == 0)return "S1空";
		else{
			top1--;
			x = A[top1];
		}
	}
	else{
		if(top2 == n+1)return "S1空";
		else{
			top2++;
			x = A[top2];
		}
	}
	return x;
}
複製]]></description><link>考研筆記/資料結構/ch3-stack-and-queue/ch3-stack-and-queue.html</link><guid isPermaLink="false">考研筆記/資料結構/CH3 Stack and Queue/CH3 Stack and Queue.md</guid><pubDate>Wed, 13 Mar 2024 09:21:36 GMT</pubDate><enclosure url="lib/media/image.jpg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib/media/image.jpg&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Infix 轉成Postfix 括號法]]></title><description><![CDATA[ 
 <br>Infix 轉成Postfix範例<br>Infix 轉成Postfix
<br>
a*(b+c-d)/(e+f*g)
ans:
((a*((b+c)-d))/(e+(f*g))
=&gt; abc+d-*efg*+/
複製

<br>
a*b$c$(d-e/f)
ans:
(a*(b$(c$(d-(e/f)))))
=&gt; abcdef/-$$*
複製

<br>
~A and (B&gt;C or D&lt;E) or ~F
ans:
(((~A) and ((B&gt;C) or (D&lt;E))) or (~F))
=&gt; A~BC&gt;DE&lt; or and F~ or
複製

]]></description><link>考研筆記/資料結構/ch3-stack-and-queue/infix-轉成postfix-括號法.html</link><guid isPermaLink="false">考研筆記/資料結構/CH3 Stack and Queue/Infix 轉成Postfix 括號法.md</guid><pubDate>Wed, 13 Mar 2024 09:21:33 GMT</pubDate></item><item><title><![CDATA[Node]]></title><description><![CDATA[ 
 <br>
Data欄：存元素值<br>
Next欄：point指標指向下一個節點
]]></description><link>考研筆記/資料結構/ch3-stack-and-queue/node.html</link><guid isPermaLink="false">考研筆記/資料結構/CH3 Stack and Queue/Node.md</guid><pubDate>Wed, 13 Mar 2024 09:37:00 GMT</pubDate></item><item><title><![CDATA[Parsing回文判別]]></title><description><![CDATA[ 
 <br>Examplewrite an algo 判斷輸入的字串是否符合回文

除以2

n = string長度
for(int i=0; i&lt;n/2; i++){
	x = Token(S);
	push(S, x);
}

if(n % 2 == 1) x = Token(S); //多抓一個，並忽略他

for(int i=0; i&lt;n/2; i++){
	x = Token(S);
	y = pop(S);
	if(x != y)
		return "NO";
}
return "Yes"
複製<br>Time: O(n)]]></description><link>考研筆記/資料結構/ch3-stack-and-queue/parsing回文判別.html</link><guid isPermaLink="false">考研筆記/資料結構/CH3 Stack and Queue/Parsing回文判別.md</guid><pubDate>Wed, 13 Mar 2024 09:25:18 GMT</pubDate></item><item><title><![CDATA[Parsing括號配對]]></title><description><![CDATA[ 
 <br>Examplewrite an algo. 判斷輸入的"("及")"字串是否為正確的括號配對，若正確回傳yes，反之No.

若")"數目 &gt; "("數目 =&gt; 必錯<br>
其他："(" ")"數目不同 =&gt; 必錯

while(還未掃完input){
	x = NextToken()
	if(x == "("){
		push(S, x);
	}
	else{
		if(IsEmpty(S)){
			then return "NO";
		}else{
			pop(S);
		}
	}
}
if(IsEmpty(S)) return "Yes";
else return "No";
複製]]></description><link>考研筆記/資料結構/ch3-stack-and-queue/parsing括號配對.html</link><guid isPermaLink="false">考研筆記/資料結構/CH3 Stack and Queue/Parsing括號配對.md</guid><pubDate>Wed, 13 Mar 2024 09:25:17 GMT</pubDate></item><item><title><![CDATA[priority Queue]]></title><description><![CDATA[ 
 ]]></description><link>考研筆記/資料結構/ch3-stack-and-queue/priority-queue.html</link><guid isPermaLink="false">考研筆記/資料結構/CH3 Stack and Queue/priority Queue.md</guid><pubDate>Wed, 13 Mar 2024 09:23:40 GMT</pubDate></item><item><title><![CDATA[Stack 之ADT(Abstract Data Type)描述]]></title><description><![CDATA[ 
 <br><br><br>
定義：Data type 之 data objects spec.(規格)與 operations spec. 需與 Data object real representation 及 operations' implementation 是獨立的
<br><br>
<br>Create(S)
<br>Push(S, item)
<br>pop(S)
<br>isEmpty(S)
<br>isFull(S)
<br>Top(S)
]]></description><link>考研筆記/資料結構/ch3-stack-and-queue/stack-之adt(abstract-data-type)描述.html</link><guid isPermaLink="false">考研筆記/資料結構/CH3 Stack and Queue/Stack 之ADT(Abstract Data Type)描述.md</guid><pubDate>Mon, 04 Mar 2024 08:07:00 GMT</pubDate></item><item><title><![CDATA[Stack之製作]]></title><description><![CDATA[ 
 <br><br><br>
<br>
Create(S):

S: array[1..n]of items<br>
Top: int, 初值 = 0


<br>
Push(S, item)
 Push(S, item){
 	if(Top == n) return "S已滿";
 	else{
 		Top++;
 		S[Top] = item;
 	}
 }
複製
Time: O(1)

<br>
pop(S)
 pop(S){
 	if(Top == 0)return "S空"
 	else{
 	item = S[Top];
 	Top--;
 	return item;
 	}
 }

複製
Time: O(1)

<br><br>
<br>
Create(S):

S: <a class="internal-link" data-href="Node.md" href="/考研筆記/資料結構/ch3-stack-and-queue/node.html" target="_self" rel="noopener">Node</a> 結構<br>
Top：pointer = Nil(空)


<br>
Push(S, item)
   Push(S, item){
     	Node *t;
     	t = new(Node);
     	t-&gt;Data = item;
     	t-&gt;Next = Top;
     	Top = t;
   }
複製
Time: O(1)

<br>
pop(S)
 pop(S){
 	if(Top == Nil)return "S空"
 	else{
 		item = Top-&gt;Data;
 		Top = Top-&gt;Next;
 		return item;
 	}
 }

複製
Time: O(1)

]]></description><link>考研筆記/資料結構/ch3-stack-and-queue/stack之製作.html</link><guid isPermaLink="false">考研筆記/資料結構/CH3 Stack and Queue/Stack之製作.md</guid><pubDate>Wed, 13 Mar 2024 09:30:34 GMT</pubDate></item><item><title><![CDATA[以B.T表示expression]]></title><description><![CDATA[ 
 <br><br><a class="internal-link" data-href="../CH3 Stack and Queue/CH3 Stack and Queue.md##Infix, Postfix, Prefix" href="/考研筆記/資料結構/ch3-stack-and-queue/ch3-stack-and-queue.html#" target="_self" rel="noopener">關聯CH3</a><br>
原則：

<br>Leaf: 表示operand
<br>Non-leaf: 表operator
<br>相鄰的operator優先權高且較下層
<br>驗證：用Inorder得出Infix、用Preorder得出Prefix、用Postorder得出Postfix

<br>例：畫出下列expression的B.T表示法]]></description><link>考研筆記/資料結構/ch5-tree-and-binary-tree/以b.t表示expression.html</link><guid isPermaLink="false">考研筆記/資料結構/CH5 Tree and Binary Tree/以B.T表示expression.md</guid><pubDate>Wed, 13 Mar 2024 09:20:26 GMT</pubDate></item><item><title><![CDATA[針對Expression B.T求值]]></title><description><![CDATA[ 
 <br><br>Eval(T: Expression B.T){
	 if(T != Nil){
		 nl = Eval(T-&gt;Lchild);
		 nr = Eval(T-&gt;Rchild);
		 switch(T-&gt;Data){
			case {變數/常數名稱}: return {變數/常數值};
			case "+": return (nl+nr);
				...//其餘operator
			case "NOT": return NOT(nr);
			case "minus": return -nr;
		 }
	 }
}
複製]]></description><link>考研筆記/資料結構/ch5-tree-and-binary-tree/針對expression-b.t求值.html</link><guid isPermaLink="false">考研筆記/資料結構/CH5 Tree and Binary Tree/針對Expression B.T求值.md</guid><pubDate>Mon, 04 Mar 2024 08:08:46 GMT</pubDate></item><item><title><![CDATA[等位關係 <a href="?query=tag:%E9%9B%A2%E6%95%A3%E6%95%B8%E5%AD%B8" class="tag" target="_blank" rel="noopener">#離散數學</a>]]></title><description><![CDATA[<a class="tag" href="?query=tag:離散數學" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#離散數學</a> 
 <br><br>
定義：滿足

<br>反身性
<br>對稱性
<br>遞移性

]]></description><link>考研筆記/資料結構/ch5-tree-and-binary-tree/等位集合.html</link><guid isPermaLink="false">考研筆記/資料結構/CH5 Tree and Binary Tree/等位集合.md</guid><pubDate>Wed, 13 Mar 2024 09:28:04 GMT</pubDate></item><item><title><![CDATA[B.T Height]]></title><description><![CDATA[ 
 <br><br>
以某一種序遞迴，找出左右子樹高度，取MAX{左子樹高度, 右子樹高度}+1
<br>Height(T){
	if(T == Nil)
		return 0;
	else{
		hl = Height(T-&gt;Lchild);
		hr = Height(T-&gt;Rchild);
		return MAX(hl, hr)+1;
	}
}
複製]]></description><link>考研筆記/資料結構/ch5-tree-and-binary-tree/b.t-height.html</link><guid isPermaLink="false">考研筆記/資料結構/CH5 Tree and Binary Tree/B.T Height.md</guid><pubDate>Wed, 13 Mar 2024 09:23:15 GMT</pubDate></item><item><title><![CDATA[Binary Search Tree <a href="?query=tag:%E2%AD%90%EF%B8%8F%E2%AD%90%EF%B8%8F%E2%AD%90%EF%B8%8F%E2%AD%90%EF%B8%8F%E2%AD%90%EF%B8%8F" class="tag" target="_blank" rel="noopener">#⭐️⭐️⭐️⭐️⭐️</a>]]></title><description><![CDATA[<a class="tag" href="?query=tag:⭐️⭐️⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️⭐️⭐️</a> <a class="tag" href="?query=tag:⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️</a> 
 <br><br>複製<br>
定義：是一顆B.T，若不為空，則滿足：

<br>左子樹所有Data皆 &lt; Root
<br>右子樹所有Data皆 &gt; Root
<br>左右子樹亦是Binary Search Tree

左&lt;中&lt;右
<br><br>steps:<br>
<br>將input Data 建成BST
<br>對BST進行 <a class="internal-link" data-href="CH5 Tree and Binary Tree.md###Binary traversal" href="/考研筆記/資料結構/ch5-tree-and-binary-tree/ch5-tree-and-binary-tree.html#" target="_self" rel="noopener">Inorder</a> traversal 即可得出 小-&gt;大 order<br>
(補充：大-&gt;小呢？改用RDL or 利用<a class="internal-link" data-href="../CH3 Stack and Queue/CH3 Stack and Queue.md##Stack" href="/考研筆記/資料結構/ch3-stack-and-queue/ch3-stack-and-queue.html#" target="_self" rel="noopener">Stack</a>做反序)
<br>BST就代表中序<br>哪些可以決定唯一的BST?
Key:BST就代表中序


<br>BST+前序
<br>BST+中序
<br>BST+後序
<br>BST+Level-order

ANS: 1, 3, 4<br><br>A[1..n]: Array of Data<br>
從A[1]開始放<br>
遇到Node與Node-&gt;Data比大小，小則往左，大則往右。<br>
放到A[n]結束<br><br><a href=".?query=tag:⭐️⭐️⭐️" class="tag" target="_blank" rel="noopener">#⭐️⭐️⭐️</a><br>Steps:<br>
<br>先search for x
<br>分成下列case

<br>case 1:x is leaf ，直接砍掉
<br>case 2:x is Degree-1的Node，將x的父點原本指向x的poinetr只向x的child再在砍掉x
<br>case 3:x is Degree-2，則先找出x的 左/右 子樹中的最 大/小 子(y)，y可能是leaf or Degree-1，將x換成y(Data)，x再依照y原本的情況(case 1 or case 2)做刪除。


<br><br>Search for x是Insert x和Delete x之基礎<br>recursive algo for search for x in BST<br>Search(T, x){
	if(T != Nil){
		switch(比較(x, T-&gt;Data)){
			case "=" : return "Sucess";
			case "&lt;" : return Search(T-&gt;Lchild, x);
			case "&gt;" : return Search(T-&gt;Rchild, x);
		}
	}
	else{ // T = Nil
		return "Fail"; // 找不到x
	}
}
複製<br><br>
<br>worst case: O(n)。(if BT is <a class="internal-link" data-href="CH5 Tree and Binary Tree.md###skewed Binary Tree" href="/考研筆記/資料結構/ch5-tree-and-binary-tree/ch5-tree-and-binary-tree.html#" target="_self" rel="noopener">skewed</a>)
<br>Best case: O(lgn)。(e.g <a class="internal-link" data-href="CH5 Tree and Binary Tree.md###Full Binary Tree" href="/考研筆記/資料結構/ch5-tree-and-binary-tree/ch5-tree-and-binary-tree.html#" target="_self" rel="noopener">Full B.T</a>, <a class="internal-link" data-href="CH5 Tree and Binary Tree.md###Complete Binary Tree" href="/考研筆記/資料結構/ch5-tree-and-binary-tree/ch5-tree-and-binary-tree.html#" target="_self" rel="noopener">Complete B.T</a>)
<br>Average: O(logn)
<br>NoteInsert Time &amp; Delete Time 都被Search影響=&gt;Insert Time &amp; Delete Time也是如此<br><br><br>
KEY:跟root的No.?做比較，然後往左或右子移動。
<br>Search(T, i){
	if(T != Nil){
		k = (T-&gt;Lsize)+1; //表示root是第k小
		if(i == k)
			return T-&gt;data;//找到
		else if(i &lt; k)
			return  Serach(T-&gt;Lchild, i);//root比較大-&gt;No.i在左半
		else if(i &gt; k)
			return  Serach(T-&gt;Lchild, i);//root比較小-&gt;No.i在右半第i-k小
	}
}
複製]]></description><link>考研筆記/資料結構/ch5-tree-and-binary-tree/binary-search-tree.html</link><guid isPermaLink="false">考研筆記/資料結構/CH5 Tree and Binary Tree/Binary Search Tree.md</guid><pubDate>Wed, 13 Mar 2024 09:22:44 GMT</pubDate></item><item><title><![CDATA[Binary Tree sorting]]></title><description><![CDATA[ 
 <br><br>用TRee結構做排序<br>
有兩個方式<br>[法ㄧ] <a class="internal-link" data-href="../CH7 Search and Sort/Heap Sort.md" href="/考研筆記/資料結構/ch7-search-and-sort/heap-sort.html" target="_self" rel="noopener">Heap Sort</a><br>[法二]利用search tree做排序<br>e.g: <a class="internal-link" data-href="../CH9 Advanced Tree/AVL Tree.md" href="/考研筆記/資料結構/ch9-advanced-tree/avl-tree.html" target="_self" rel="noopener">AVL Tree</a>,  RB-Tree, B Tree]]></description><link>考研筆記/資料結構/ch5-tree-and-binary-tree/binary-tree-sorting.html</link><guid isPermaLink="false">考研筆記/資料結構/CH5 Tree and Binary Tree/Binary Tree sorting.md</guid><pubDate>Wed, 13 Mar 2024 09:22:28 GMT</pubDate></item><item><title><![CDATA[Build a Heap with n nodes]]></title><description><![CDATA[<a class="tag" href="?query=tag:⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️</a> <a class="tag" href="?query=tag:⭐️⭐️⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️⭐️⭐️</a> <a class="tag" href="?query=tag:⭐️⭐️⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️⭐️⭐️</a> <a class="tag" href="?query=tag:⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️</a> 
 <br><br>分成<br>
<br>Top-Down法（慢O(nlogn)）
<br>Bottom-up法（快==O(n)）
<br><br>一個一個insert<br>steps:<br>
即Inset x one by one 逐步建立Heap<br>
Time:<br>
Inset x into Heap 後，有i個點插入的time約logi -&gt; O(nlogn)<br><br>先隨意建立(complete B.T)再修正<br>steps:<br>
<br>Input data 以Complete B.T呈現(Array[1..n])
<br>從"the last Parent"開始，調整子樹數成為Heap，再往前一個父點一直調整到Root。<br>
<img alt="../img/截圖 2022-09-30 下午8.32.23.jpg" height="300" src="/lib/media/截圖-2022-09-30-下午8.32.23.jpg" style="width: 300px; max-width: 100%;">
<br>Time分析 <a href=".?query=tag:⭐️⭐️⭐️" class="tag" target="_blank" rel="noopener">#⭐️⭐️⭐️</a><br>
n個資料，complete B.T，高度k= ⎡log₂(n+1)⎤<br>
假設父點在level i調整子樹，調整子樹之最大成本為 = k - i<br>
而level i最多有 2^(i-1) 顆子樹，且level值: 1 ~ k<br>
=&gt; Total cost = 2^(i-1) (k - i) = S , 取i = 1~k的總和<br>S = 2^0x(k-1)+...+2^(k-2)x1
2S = ...
2S - S = -(k- 1)+ 2^1+ 2^2+ ...+ 2^k-1
= ((2^k)- 2) / (2- 1) -k+ 1
= 2^k - k - 1
=&gt;因為k = ⎡log₂(n+1)⎤ ~= log₂n
=&gt;S = n- logn -1
=&gt; O(n)
複製<br><br><a href=".?query=tag:⭐️⭐️⭐️⭐️⭐️" class="tag" target="_blank" rel="noopener">#⭐️⭐️⭐️⭐️⭐️</a><br>
分成<br>
<br>Adjust(tree, i, n) 副程式 <a href=".?query=tag:⭐️⭐️⭐️⭐️⭐️" class="tag" target="_blank" rel="noopener">#⭐️⭐️⭐️⭐️⭐️</a>
<br>BuildHeap(tree, n) 主程式 <a href=".?query=tag:⭐️⭐️⭐️" class="tag" target="_blank" rel="noopener">#⭐️⭐️⭐️</a>
<br><br>
又稱heapify
<br>tree: Array[1..n]<br>
i:Node編號<br>
調整以i為Root之子樹成謂Heep<br>
KEY：

<br>先保留root，開始往下檢查
<br>遇到符合大小的規則的，往上移，然後往他的位置繼續檢查
<br>直到往上移完之後再把root放到新的位置

<br>Adjust(tree, i, n) {
	temp = tree[i];
	j = 2*i;
	while(j &lt;= n){   //還有子點
		if(j &lt; n)    //j node還有兄弟（i有右兒子）
			if(tree[j] &lt; tree[j+1])   //右子比較大
				j = j+1;   //j指向比較大的子點
			if(temp &gt;= tree[j])   //i比右&amp;左子大
				break;
			else{   //子點比較大
				tree[j/2] = tree[j];   //j往上放
				j = 2*j;   //下一個左子點位置
			}
	}
	//往上移完，把root放到正確位置
	//！！！因為是比j大，所以放j上一層
	tree[j/2] = temp;
}
複製<br>Time: O(logn)<br><br>針對tree:[1..n]建立Heap<br>BuildHeap(tree, n){
	for(i = n/2; i&gt;= 1; i--){   //從後一個「父」點調整
		Adjust(tree, i, n);
	}
}
複製<br>Time: O(n)]]></description><link>考研筆記/資料結構/ch5-tree-and-binary-tree/build-a-heap-with-n-nodes.html</link><guid isPermaLink="false">考研筆記/資料結構/CH5 Tree and Binary Tree/Build a Heap with n nodes.md</guid><pubDate>Wed, 13 Mar 2024 09:15:43 GMT</pubDate><enclosure url="lib/media/截圖-2022-09-30-下午8.32.23.jpg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib/media/截圖-2022-09-30-下午8.32.23.jpg&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[CH5 Tree and Binary Tree]]></title><description><![CDATA[<a class="tag" href="?query=tag:⭐️⭐️⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️⭐️⭐️</a> <a class="tag" href="?query=tag:⭐️⭐️⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️⭐️⭐️</a> <a class="tag" href="?query=tag:⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️</a> <a class="tag" href="?query=tag:⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️</a> <a class="tag" href="?query=tag:⭐️⭐️⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️⭐️⭐️</a> <a class="tag" href="?query=tag:⭐️⭐️⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️⭐️⭐️</a> <a class="tag" href="?query=tag:⭐️⭐️⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️⭐️⭐️</a> <a class="tag" href="?query=tag:⭐️⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️⭐️</a> <a class="tag" href="?query=tag:⭐️⭐️⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️⭐️⭐️</a> <a class="tag" href="?query=tag:⭐️⭐️⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️⭐️⭐️</a> <a class="tag" href="?query=tag:⭐️⭐️⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️⭐️⭐️</a> <a class="tag" href="?query=tag:⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️</a> <a class="tag" href="?query=tag:⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️</a> <a class="tag" href="?query=tag:⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️</a> <a class="tag" href="?query=tag:ch6" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#ch6</a> 
 <br><br><br><br>
定義：由&gt;個<a class="internal-link" data-href="../CH3 Stack and Queue/Node.md" href="/考研筆記/資料結構/ch3-stack-and-queue/node.html" target="_self" rel="noopener">Node</a>構成，不可為空。<br>
至少有一<a class="internal-link" data-href="../CH3 Stack and Queue/Node.md" href="/考研筆記/資料結構/ch3-stack-and-queue/node.html" target="_self" rel="noopener">Node</a>稱為root
<br>其他相關名詞：<br>
<br>Node's Degree：Node的子樹個數
<br>Leaf：Degree = 0 的 Node
<br>Non-Leaf：Degree &gt; 0 的 Node
<br>parent &amp; child
<br>sibling(兄弟)
<br>Ancestors(祖先)、Descendents(後代)師
<br><br><br><img alt="../img/截圖 2022-09-27 下午7.31.00.jpg" src="/lib/media/截圖-2022-09-27-下午7.31.00.jpg" style="width: 400px; max-width: 100%;"><br><br>正向<br>
<br>B.T.中第 i level 之最多Node數 = 2^(i-1)
數學歸納法證明

<br>高度 k 之B.T最多Node數 = 2^k  -1 (有k層的B.T.最多2^k  -1個Node)
每層之MAX節點數總和  = 2^k -1

<br>反向<br>
<br>
若B.T有n個Nodes，求最大高度<br>
Ans: n (一層一個點)

<br>
B.T有n個Nodes，求最小高度<br>
Ans: 用2^k -1 反推

<br>
若B.T有n個leaf，求最小高度<br>
Ans:  upper(log₂n) +1
用2^(i-1)反推   2^(i-1)  = n<br>
i-1 = upper(log₂n)<br>
i = upper(log₂n) +1

<br>
一個非空的B.T.，若有n0個leaf, n2個Degree-2 Node，則n0 = n2+1 <a href=".?query=tag:⭐️⭐️⭐️⭐️⭐️" class="tag" target="_blank" rel="noopener">#⭐️⭐️⭐️⭐️⭐️</a>
Proof(KEY:分支數量與degree關係)
<br>
假設（很重要）<br>
n = Node數<br>
n1 = Degree-1 的node數<br>
B = Branch總數 ( = n-1)

<br>
n = n0 + n1 + n2 = B+1<br>
= (n1 + 2*n2)+1<br>
=&gt; (n1 + 2*n2)+1 = n0 + n1 + n2<br>
=&gt; n0 = n2 + 1



關鍵：<br>
n = n0 + n1 + n2 + ....<br>
n = B + 1<br>
找這兩者之間的關聯

B.T. 有15個Leaf，求Degree-2的Node數量？因為n0 = n2 + 1 =&gt; 15 = n2 + 1 =&gt; n2 = 14
B.T. 有77個nodes，求Degree-1的Node數有44個，求leaf個數？n = n0 + n1 + n2<br>
77 = n0 + 44 + n2<br>
=&gt; 77 = 2*n0 -1 + 44<br>
n0 = 17
有一顆Tree, 其Degree = 5且Degree為i之Node數有i個，求Leaf個數n = n0+n1+n2+n3+n4+n5<br>
n1 = 1, n1 = 2, n3 = 3, n4 = 4, n5 = 5<br>
n = Branch數+1<br>
=&gt; n = (1*n1+2*n2+3*n3+4*n4+5*n5) +1 = 55+1 = 56<br>
=&gt; n0 = 56-15 = 41
有一顆Tree, Tree's Degree = k且Degree為i之Node數有i個，求Leaf個數?同上一般化
有一顆Tree, Tree's Degree = 4且每個Non-leaf必有4個children，若Leaf有n0個，求Node總數?{Node總數} = n = n0+n4
n = B + 1 = 4*n4+1<br>
=&gt; n0+n4 = 4*n4+1<br>
=&gt; (4*n0-1)/3

<br><br><br>
<br>Left-skewed

定義:每一個Non-leaf皆只有左子點，沒有右子點。


<br>Right-skewed

定義:每一個Non-leaf皆只有右子點，沒有左子點。


<br><br>
定義：高度k之B.T.具有最多Node數= 2^k-1，稱之。
<br><br>
定義：高度k之B.T.具有n個nodes，滿足...

<br>2^(k-1)-1 &lt; n &lt;= 2^k -1 長到最高層但不一定長滿
<br>Node之增長順續為由上而下，同level由左而右增長。

<br><br>Complete Binary Tree具有n個Nodes，Node編號1~n<br>
若某Node編號是i，則<br>
<br>左子點編號=2i, if 2i &gt; n, then 無左子
<br>右子點編號=2i+1, if 2i+1 &gt; n, then 無右子
<br>父點= i/2, if i/2 &lt; 1 then 無父點
<br><br>1000個Nodes編號1~1000。最後一個父點No.?ans: 1000/2 = 500<br>1000個Nodes編號1~1000。How many leaves?ans: N0.501~N0.1000 =&gt; 500
=&gt;求complete B.T的Leaf數-&gt;最後一個parent的下一個到對後一個的編號長。<br>1000個Nodes編號1~1000。有多少個Degree-1的Node?編號是？ans: 已知n0 = 500 , n2 = 499<br>
n1 = 1000-500-499 = 1
=&gt; 最後一個parent<br>(True or False)In a Complete B.T, n1 = 0 or 1True<br>True or False
<br>若樹根的左右子書都是C.B.T，則此樹必為C.B.T (可延伸為其他樹型)<br>
False
<br>一C.B.T.的任何左右子樹必為C.B.T<br>
True
<br>C.B.T中若Node沒有左子點，則此Node必為Leaf<br>
True
<br>C.B.T with n nodes高度必為upper(log₂(n+1))<br>
True
<br>n個branch則必有n-1個node<br>
False
<br><br>
定義：B.T中，every Non-Leaf must have 2 child Node. that is, n1 = 0.。有孩子就要放滿
<br>True or False
<br>Full BT =&gt; strict BT
<br>CBT =&gt; strict BT
<br>strict =&gt; Full BT
<br>Strict BT =&gt; CBT

ANS:

<br>T
<br>F
<br>F
<br>F
<br>在不同Binary tree中，選出正確項目KEY: <a class="internal-link" data-href="CH5 Tree and Binary Tree.md##Binary tree三個基本定理" href="/考研筆記/資料結構/ch5-tree-and-binary-tree/ch5-tree-and-binary-tree.html#" target="_self" rel="noopener">Binary tree三個基本定理</a>

<br>n0 = n2+1
<br>n = 2*n0-1
<br>高度 = upper(log₂(n+1))
<br>n0+n2 &lt;= n &lt;= n0+n2+1

ANS:<br>
對於任意Binary Tree: {1}<br>
對於Full Binary Tree:{1, 2, 3, 4}<br>
對於Complete Binary Tree:{1, 3, 4}<br>
對於Strict Binary Tree:{1, 2, 4} <br><br><br>作法<br>
if BT's heigh = k, then prepare A:array[1..2^k -1], 依照Node 編號，存入對應的Data<br>
另外，若是Complete/Full BT則只需n個node（Array[1..n])即可<br>Draw the B.T, if you can. otherwise, say "invalid"
<br>[A, X, B, Y, , C, ]<br>
可以
<br>[A, B, , C, D, E, ]<br>
invalid
<br>優點<br>
<br>容易存取
<br>對於Full/Complete B.T之儲存充分利用Space
<br>缺點<br>
<br>不易增/刪 Node(可能須改變array大小和元素搬動)
<br>對於skewed B.T 來說極度浪費空間
<br><br>作法<br>
Node structure設計<br>
[Lchild | Data| Rchild]<br>缺點<br>
<br>不易存取(例如找父Node)
<br>⭐️link space 浪費一半左右<br>
n個nodes共2n條links，其中有用的link: n-1條 ，浪費n+1條。
<br>優點<br>
<br>增加刪除方便
<br>對於skewed B.T儲存，比Array節省空間
<br><br><br>O(n)<br>
<br>Preorder:DLR 中左右右子在左子
<br>Inorder:LDR 左中右 從左往右掃
<br>Postorder:LRD 左右中 左子在右子
<br>Level-order: 由上而下由左而右 =&gt; <a class="internal-link" data-href="../CH3 Stack and Queue/CH3 Stack and Queue.md##Queue" href="/考研筆記/資料結構/ch3-stack-and-queue/ch3-stack-and-queue.html#" target="_self" rel="noopener">Queue</a>之應用
<br><img alt="../img/截圖 2022-09-29 下午7.18.15.jpg" src="/lib/media/截圖-2022-09-29-下午7.18.15.jpg" style="width: 400px; max-width: 100%;"><br><br>
<br>
給B.T寫出traversal sequence 記熟各種Binary traversal

<br>
給B.T的前序&amp;中序 或 後序&amp;中序，可決定unique B.T，但若給前&amp;後序則無法 <a href=".?query=tag:⭐️⭐️⭐️⭐️⭐️" class="tag" target="_blank" rel="noopener">#⭐️⭐️⭐️⭐️⭐️</a>
給前序/後序 &amp; 中序 還原Tree“../img/截圖 2022-09-29 下午7.26.54.jpg” could not be found.

前序：左而右看Root<br>
後序：右而左看Root

舉例說明給前&amp;後序無法決定唯一B.T !!記下此案例“../img/截圖 2022-09-29 下午7.40.22.jpg” could not be found.
給予前序後序決定all posible B.T
L&amp;R如何切割 =&gt; 靠人<br>
=&gt;判斷原則：

<br>集合元素相同
<br>Root要一致


“../img/截圖 2022-09-29 下午7.58.30.jpg” could not be found.
下列哪些組合可以決定唯一B.T ⭐️
key:拿左斜右斜驗證


<br>前+中:T
<br>後+中:T
<br>前+後:F
<br>前+level-order:F
<br>中+level-order:T
<br>後+level-order:F


Complete B.T =&gt; 結構卡死 =&gt; 依照[]序放資料


<br>Complete B.T + 前:T
<br>Complete B.T + 中:T
<br>Complete B.T + 後:T
<br>Complete B.T + level-order:T

決定下列B.T各可為哪些種類？
<br>此B.T下的 前序=中序
<br>此B.T下的 後序=中序
<br>此B.T下的 前序=後序

Ans:

<br>DLR = LDR<br>
=&gt; empty, root, Right-skewed B.T(去掉L)
<br>LRD = LDR<br>
=&gt; empty, root, Left-skewed B.T(去掉R)
<br>DLR = LRD<br>
=&gt; empty, root


<br>
B.T前中後序recursive algo. (Assume B.T以link list表示)資工較少

原則：<br>
D=&gt;列印Node Data<br>
L, R=&gt;遞迴追蹤

...覺得簡單。省略

<br>
B.T recursuve Traversal algo.之應用 <a href=".?query=tag:⭐️⭐️⭐️⭐️" class="tag" target="_blank" rel="noopener">#⭐️⭐️⭐️⭐️</a>

<br><a class="internal-link" data-href="Copy a B.T.md" href="/考研筆記/資料結構/ch5-tree-and-binary-tree/copy-a-b.t.html" target="_self" rel="noopener">Copy a B.T</a>
<br><a class="internal-link" data-href="Equal(S, T).md" href="/考研筆記/資料結構/ch5-tree-and-binary-tree/equal(s,-t).html" target="_self" rel="noopener">Equal(S, T)</a>：判斷S, T是否相等
<br><a class="internal-link" data-href="Count B.T Node總數.md" href="/考研筆記/資料結構/ch5-tree-and-binary-tree/count-b.t-node總數.html" target="_self" rel="noopener">Count B.T Node總數</a>
<br>求<a class="internal-link" data-href="B.T Height.md" href="/考研筆記/資料結構/ch5-tree-and-binary-tree/b.t-height.html" target="_self" rel="noopener">B.T Height</a>
<br><a class="internal-link" data-href="Swap a B.T.md" href="/考研筆記/資料結構/ch5-tree-and-binary-tree/swap-a-b.t.html" target="_self" rel="noopener">Swap a B.T</a>
<br><a class="internal-link" data-href="以B.T表示expression.md" href="/考研筆記/資料結構/ch5-tree-and-binary-tree/以b.t表示expression.html" target="_self" rel="noopener">以B.T表示expression</a>，<a class="internal-link" data-href="針對Expression B.T求值.md" href="/考研筆記/資料結構/ch5-tree-and-binary-tree/針對expression-b.t求值.html" target="_self" rel="noopener">針對Expression B.T求值</a>之algo.
<br><a class="internal-link" data-href="Binary Tree sorting.md" href="/考研筆記/資料結構/ch5-tree-and-binary-tree/binary-tree-sorting.html" target="_self" rel="noopener">Binary Tree sorting</a> <a href=".?query=tag:⭐️⭐️⭐️⭐️⭐️" class="tag" target="_blank" rel="noopener">#⭐️⭐️⭐️⭐️⭐️</a>


<br><br><br>
定義：（分為MAX-Heap, Min-Heap）<br>
以MAX為例：

<br>是一顆Complete B.T.
<br>父點皆&gt;= 其子點
<br>Root具有最大值

<br><br>
<br>製作priority Queue之最適合資料結構
<br><a class="internal-link" data-href="../CH7 Search and Sort/Heap Sort.md" href="/考研筆記/資料結構/ch7-search-and-sort/heap-sort.html" target="_self" rel="noopener">Heap Sort</a>
<br>Heap適合用Array保存
<br><br><br><br>公式：1/(n+1) C(2n, n) 證明在課本<br>1,2,3 3個integer可以形成?顆不同的<a class="internal-link" data-href="Binary Search Tree.md" href="/考研筆記/資料結構/ch5-tree-and-binary-tree/binary-search-tree.html" target="_self" rel="noopener">BST</a>，並求其後序。Ans: =&gt;公式 = 5顆<br>
後序剛好是<a class="internal-link" data-href="../CH3 Stack and Queue/CH3 Stack and Queue.md##Stack permutation" href="/考研筆記/資料結構/ch3-stack-and-queue/ch3-stack-and-queue.html#" target="_self" rel="noopener">Stack permutation</a><br>
“../img/截圖 2022-10-01 下午7.01.40.jpg” could not be found.<br>令Bn代表n個nodes可形成的不同B.T數目。完成下列題目
<br>write down the Recursive definition of Bn.<br>
設Root的右子樹有i個點，左子有n-i-1個

Bn = sigma(i=0~n-1)(Bi + Bn-i-1)<br>
B0 = B1 = 1


<br>求解Bn = ?(資工離散) <a href=".?query=tag:離散" class="tag" target="_blank" rel="noopener">#離散</a> <a href=".?query=tag:⭐️⭐️⭐️⭐️⭐️" class="tag" target="_blank" rel="noopener">#⭐️⭐️⭐️⭐️⭐️</a> 
<br>Write the Recursive Algo. code
int B(int n){
	if(n == 0|| n == 1)return 1;
	else{
		int s = 0;
		for(int i; i&lt;= (n-1); i++)
			s += B(i)+ B(n-i-1);
		return s;
	}
}
複製

<br><br><a href=".?query=tag:⭐️⭐️" class="tag" target="_blank" rel="noopener">#⭐️⭐️</a><br><br><br>方法:"Leftmost-child - Next-Right-sibling"法<br>
Steps<br>
<br>建立sibling 間的平行links ~~
<br>刪除父點與子點間的links但保留leftmost-child的link
<br>順時針轉45度。

<br>即次右兄弟變成右子點
<br>保留的最左子當左子


<br>優點：<br>
<br>可充分利用Nil link 空間
<br>方便找到任意一node的中序前/後一個點
<br>簡化中序追蹤，不需遞迴（不用stack)<br>
<img alt="../img/截圖 2022-10-01 下午6.25.53.jpg" src="/lib/media/截圖-2022-10-01-下午6.25.53.jpg" style="width: 400px; max-width: 100%;">
<br><br>Steps:Tree化成B.T的反向<br>
<br>逆轉45度
<br>補上父子link
<br>刪sibling連結
<br>
右子變右邊兄弟，左子還是子（左右沒差）
<br><br><br>Steps:<br>
<br>Forest 中每顆Tree先化B.T（若原本觀察下來就是B.T，依舊要換）
<br>Roots連再一起，平行連
<br>針對Roots順時鐘轉45度（其餘不變）
<br><br>Forest 化成B.T反向<br><br>緣由：n個nodes之B.T，若以link list 表示，則有 n+1 條Nil links，為了充分運用這些links，故將他們視為"Thread pointer"，改成只向其他Node，此種B.T稱之。<br>一般我們是以Inorder順序規範：<br>
<br>若x的leftchild is Nil，則當左引線指向中序順序中x的前一個Node
<br>若x特Rightchild 為Nil，則當右引線指向中序順序中x的下一個Node
<br><br>[ LeftThread | Lchild | Data | Rchild | RightThread ]<br>
<br>LeftThread: Boolean 。True表Lchild是左引線, False表Lchild是左子  有子點 --&gt; False
<br>RightThread: 類上
<br>額外新加一個Head node，規定如下：<br>
<img alt="../img/截圖 2022-10-01 下午7.44.53.jpg" src="/lib/media/截圖-2022-10-01-下午7.44.53.jpg" style="width: 300px; max-width: 100%;"><br>
<img alt="../img/截圖 2022-10-01 下午7.44.40.jpg" src="/lib/media/截圖-2022-10-01-下午7.44.40.jpg" style="width: 300px; max-width: 100%;">
<br><br>
<br>Insuc(x)/Inpre(x):找出x的中序後繼者/先行者
<br>簡化的中序追蹤
<br>Insert t node 成為S的右子點/左子點
<br><br>找出x的中序後 下一個 Node<br>
規則：<br>
<br>若x的RightThread = True（沒右子），則x-&gt;Rchild則是
<br>若x的RightThread = False（有右子），沿著右子開始往左下尋找，直到某個Node的LeftThread是True，其Rchild則是。
<br>Insuc(Head) = ?<br>Insuc(x){
	temp = x-&gt;Rchild;
	if(x-&gt;RightThread == False)
		while(temp-&gt;leftThread != True)
			temp = temp-&gt;Lchild;//往左子移動
	return temp;
}
複製<br><br>對稱於Insuc(x)<br><br>規則<br>
<br>從Head node開始Incus(x)，直到回到Head node。
<br>Inorder(T: Head node){
	temp = T;
	repeat{
		temp = Insuc(temp);
		if(temp!= T)
			print(temp-&gt; Data);
	}until(temp == T);
}
複製<br><br>
<br>case 1: S原無右子點<br>
<img alt="../img/截圖 2022-10-01 下午8.32.04.jpg" src="/lib/media/截圖-2022-10-01-下午8.32.04.jpg" style="width: 400px; max-width: 100%;">
<br>case 2: S原本有右子點。則原本的右子變成t的右子。<br>
<img alt="../img/截圖 2022-10-01 下午8.31.47.jpg" src="/lib/media/截圖-2022-10-01-下午8.31.47.jpg" style="width: 400px; max-width: 100%;">
<br>//t的線先連好（［1］［2］）
//更新S
//原本有無子點（有則中序的後一個連到t)
Insert(S, t){
	//case1
	//[1]
	t-&gt;RightThread = S-&gt;RightThread;
	t-&gt;Rchild = S-&gt;Rchild;
	//[2]
	t-&gt;LeftThread = True;
	t-&gt;Lchild = S;
	//[3]
	S-&gt;RightThread = False;
	S-&gt;Rchild = t;
	//[4] in case 2
	if(t-&gt;RightThread == False){
		temp = Insuc(t);//找出S原本的中序後繼者
		temp-&gt;Lchild = t;
	}
	
}
複製<br>note:若是插入t為S的左子呢？Left &lt;-&gt; Right<br>
Insuc -&gt; Inpre<br><br><br>link往上指的tree喔！！<br>
定義：一堆互斥的sets組成
<br><br>
每一個集合均用一顆Tree表示，從set中任取一個元素作為Root，其餘為Root的子點
<br><br><br>Node設計：[ Data | Parent ]<br>
Parent: pointer to 父點<br>（root可指向自己或Nil）<br><br>作法：<br><br>Parent:若有父親則紀錄父親的No.<br><br>
<br>Union聯集(等同於Merge 2個sets)
<br>Find(x)找出x元素所在set之root，傳回root
<br><br>
<br><a class="internal-link" data-href="../CH6 Graph/Kruskal's Algo.md" href="/考研筆記/資料結構/ch6-graph/kruskal's-algo.html" target="_self" rel="noopener">kruskal's algo</a> 求MST 判斷邊(u, v)加入是否會形成cycle
<br>依照等價關係配對找出<a class="internal-link" data-href="等位集合.md" href="/考研筆記/資料結構/ch5-tree-and-binary-tree/等位集合.html" target="_self" rel="noopener">等位集合</a>
<br><a href=".?query=tag:ch6" class="tag" target="_blank" rel="noopener">#ch6</a> 求無相圖之Connected component 方法之一
<br><br>在面對十分大的graph時，Union and Find比DFS, BFS還要好<br><br><a class="internal-link" data-href="Union(i, j).md" href="/考研筆記/資料結構/ch5-tree-and-binary-tree/union(i,-j).html" target="_self" rel="noopener">Union(i, j)</a><br>
<a class="internal-link" data-href="Simple-Find(x).md" href="/考研筆記/資料結構/ch5-tree-and-binary-tree/simple-find(x).html" target="_self" rel="noopener">Simple-Find(x)</a><br>分析<br>
可能會創造出O(n)高度之tree結構，導致Find(x)  = O(n) time（例：n個單一元素的sets Union起來）<br><br>避免組合一的問題，降低樹高<br><a class="internal-link" data-href="Union-by-Height(i, j).md" href="/考研筆記/資料結構/ch5-tree-and-binary-tree/union-by-height(i,-j).html" target="_self" rel="noopener">Union-by-Height(i, j)</a><br>分析：<br>
若一開始n個單一元素sets經過n-1次union後，創造的tree高度=O(logn)，故Find(x)平均一次花O(logn) time<br>定理：創造出Tree之高度頂多是 log₂n+1 (or ⎡log₂(n+1)⎤)
<br>n=1時，高度log₂1 +1 = 1，初值成立。
<br>假設node數&lt;n-1時成立
<br>node數 = n時，假設最後一次union是union(k, j)<br>
tree j的node數= m<br>
tree k的node數= n-m<br>
不失一般性假設1&lt;=m&lt;=n/2

<br>m&lt; n/2 : union後以n/2的高度為準=&gt;新樹高&lt;= log₂(n-m)+1 &lt;= log₂n +1
<br>m= n/2 : union後新樹高度= treej or treek 高度+1 =&gt;  &lt;= log₂(n/2)+1+1 &lt;= log₂n +1


<br>由數學歸納得證
<br><br><a class="internal-link" data-href="Find(x)-with-path-Compression.md" href="/考研筆記/資料結構/ch5-tree-and-binary-tree/find(x)-with-path-compression.html" target="_self" rel="noopener">Find(x)-with-path-Compression</a><br>分析<br>
此種組合Findㄧ次的時間=O(𝞪(m, n)), 𝞪(m, n)是Ackerman's反函數，成長數率極緩= O(log*n)，趨近於O(1)]]></description><link>考研筆記/資料結構/ch5-tree-and-binary-tree/ch5-tree-and-binary-tree.html</link><guid isPermaLink="false">考研筆記/資料結構/CH5 Tree and Binary Tree/CH5 Tree and Binary Tree.md</guid><pubDate>Mon, 04 Mar 2024 08:07:16 GMT</pubDate><enclosure url="lib/media/截圖-2022-09-27-下午7.31.00.jpg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib/media/截圖-2022-09-27-下午7.31.00.jpg&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Copy a B.T]]></title><description><![CDATA[ 
 <br><br>easy<br>
觀念:<br>
走某一種序的順序複製<br>
steps（前序）:

<br>assign Top Root
<br>Copy(L)
<br>Copy(R)

<br>Copy(orig : BinaryTree):
	if(orig == None):
		t = None;
	else{
		new(t);
		t-&gt;Data = orig-&gt;Data;
		t-&gt;Lchild = Copy(orig-&gt;Lchid);
		t-&gt;Rchild = Copy(orig-&gt;Rchid);
	}
	return t;
複製]]></description><link>考研筆記/資料結構/ch5-tree-and-binary-tree/copy-a-b.t.html</link><guid isPermaLink="false">考研筆記/資料結構/CH5 Tree and Binary Tree/Copy a B.T.md</guid><pubDate>Wed, 13 Mar 2024 09:23:18 GMT</pubDate></item><item><title><![CDATA[Count B.T Node總數]]></title><description><![CDATA[ 
 <br><br>
以某一種序遞迴計數
<br>int Count(T){
	if(T == Nil)
		return 0;
	else{
		int ln += Count(T-&gt;Lchild);
		int rn += Count(T-&gt;Rchild);
		return ln+ rn+ 1;
	}
}
複製]]></description><link>考研筆記/資料結構/ch5-tree-and-binary-tree/count-b.t-node總數.html</link><guid isPermaLink="false">考研筆記/資料結構/CH5 Tree and Binary Tree/Count B.T Node總數.md</guid><pubDate>Wed, 13 Mar 2024 09:20:23 GMT</pubDate></item><item><title><![CDATA[Delete-MAX in  MAX-Heap]]></title><description><![CDATA[ 
 <br><br>
末端拉到第一個，再從上往下重新排序
<br>steps:<br>
<br>remove Root資料
<br>把最後的Node資料移到Root
<br>從Root(x)往下調整。x向下移動到符合的位置

<br>找出左右子點最大值
<br>if x &lt; M then M往上x往下
<br>重複b.直到x &gt;= M


<br>Time分析:同Insert]]></description><link>考研筆記/資料結構/ch5-tree-and-binary-tree/delete-max-in-max-heap.html</link><guid isPermaLink="false">考研筆記/資料結構/CH5 Tree and Binary Tree/Delete-MAX in  MAX-Heap.md</guid><pubDate>Wed, 13 Mar 2024 09:16:01 GMT</pubDate></item><item><title><![CDATA[Equal(S, T)]]></title><description><![CDATA[ 
 <br><br>
觀念：<br>
以某一種序遞迴比較（類似<a class="internal-link" data-href="Copy a B.T.md" href="/考研筆記/資料結構/ch5-tree-and-binary-tree/copy-a-b.t.html" target="_self" rel="noopener">Copy a B.T</a>)，但傾向用前序
<br>Equal(S:B.T, T:B.T){
	res = False
	if(S==Nil and T == Nil)
		res = True;
	else if(S!=Nil and T!= Nil)
		if(S-&gt;Data == T-&gt;Data)
			if(Equal(S-&gt;Lchild, T-&gt;Lchild))
				res = Equal(S-&gt;Rchild, T-&gt;Rchild);
	return res;
}
複製]]></description><link>考研筆記/資料結構/ch5-tree-and-binary-tree/equal(s,-t).html</link><guid isPermaLink="false">考研筆記/資料結構/CH5 Tree and Binary Tree/Equal(S, T).md</guid><pubDate>Wed, 13 Mar 2024 09:22:53 GMT</pubDate></item><item><title><![CDATA[Find(x)-with-path-Compression]]></title><description><![CDATA[ 
 <br>Find(x)-with-path-Compression<br>
定義：除了去找到Root,傳回Root之外，另外，將x的Parent上所有Nodes(包含x)的Parent pointer皆改成指向Root<br>
縮短x到Root的路徑
<br>Find(x){ //遞迴版本
	if(x!=x-&gt;Parent)
		x-&gt;Parent=Find(x-&gt;Parent);
	return x-&gt;Parent
}
複製]]></description><link>考研筆記/資料結構/ch5-tree-and-binary-tree/find(x)-with-path-compression.html</link><guid isPermaLink="false">考研筆記/資料結構/CH5 Tree and Binary Tree/Find(x)-with-path-Compression.md</guid><pubDate>Mon, 04 Mar 2024 08:06:51 GMT</pubDate></item><item><title><![CDATA[Insert x into MAX-Heap]]></title><description><![CDATA[ 
 <br><br>
x放末端，向上比大小到輸
<br>steps:<br>
<br>x先放在末端後一個位置
<br>x向上挑戰父點（比大小，比父大就對換）
<br>重複2.到失敗
<br>Time分析:因為x最大移動從底到高，即為樹高。又Heap是Complete B.T -&gt; O(logn)]]></description><link>考研筆記/資料結構/ch5-tree-and-binary-tree/insert-x-into-max-heap.html</link><guid isPermaLink="false">考研筆記/資料結構/CH5 Tree and Binary Tree/Insert x into MAX-Heap.md</guid><pubDate>Wed, 13 Mar 2024 09:16:18 GMT</pubDate></item><item><title><![CDATA[Merge two Heap into a Heap]]></title><description><![CDATA[ 
 <br><br>steps<br>
<br>兩個array接在一起
<br>針對接在一起的array以Bottom-up的方式建Heap
<br>Time: O(n)]]></description><link>考研筆記/資料結構/ch5-tree-and-binary-tree/merge-two-heap-into-a-heap.html</link><guid isPermaLink="false">考研筆記/資料結構/CH5 Tree and Binary Tree/Merge two Heap into a Heap.md</guid><pubDate>Mon, 04 Mar 2024 08:07:02 GMT</pubDate></item><item><title><![CDATA[Simple-Find(x)]]></title><description><![CDATA[ 
 <br>Simple-Find(x)<br>
沿著x的parent link 一直往上直到Root 為止，傳回root<br>Simple-Find(x){
temp = x;
while(temp-&gt;Parent!= temp)
	temp = temp-&gt;Parent;
return temp;
}
複製<br>O(h)。h是樹高]]></description><link>考研筆記/資料結構/ch5-tree-and-binary-tree/simple-find(x).html</link><guid isPermaLink="false">考研筆記/資料結構/CH5 Tree and Binary Tree/Simple-Find(x).md</guid><pubDate>Wed, 13 Mar 2024 09:21:41 GMT</pubDate></item><item><title><![CDATA[Swap a B.T]]></title><description><![CDATA[ 
 <br><br>
定義：B.T中每個Node之左右子點互換<br>
觀念：左子swap，右子swap，左右子swap
<br>
Swap(T){
	if(T == Nil){
		Swap(T-&gt;Lchild);
		Swap(T-&gt;Rchild);
		temp = T-&gt;Lchild;
		T-&gt;Lchild = T-&gt;Rchild;
		T-&gt;Rchild = temp;
	}
}
複製]]></description><link>考研筆記/資料結構/ch5-tree-and-binary-tree/swap-a-b.t.html</link><guid isPermaLink="false">考研筆記/資料結構/CH5 Tree and Binary Tree/Swap a B.T.md</guid><pubDate>Wed, 13 Mar 2024 09:23:19 GMT</pubDate></item><item><title><![CDATA[Union-by-Height(i, j)]]></title><description><![CDATA[ 
 <br>Union-by-Height(i, j)<br>
樹較高的做New Root。若高度相同，則任意<br>
也就是矮的塞到高的tree裡<br>
只有兩個高度同的tree union起來，高度才會增加（加一)
<br><img alt="../img/截圖 2022-10-12 下午2.20.46.jpg" src="/lib/media/截圖-2022-10-12-下午2.20.46.jpg" style="width: 400px; max-width: 100%;"><br>Union-by-Height(i, j){
   if(Height(i) &gt;= Height(j)){
	   if(Height(i) == Height(j))
		   Height(i)++;
		j-&gt;Parent = i;
   }
   else{
	   i-&gt;Parent = j;
   }
}
複製<br>O(1)<br>分析：<br>
若一開始n個單一元素sets經過n-1次union後，創造的tree高度=O(logn)<br>故Find(x)平均一次花O(logn) time]]></description><link>考研筆記/資料結構/ch5-tree-and-binary-tree/union-by-height(i,-j).html</link><guid isPermaLink="false">考研筆記/資料結構/CH5 Tree and Binary Tree/Union-by-Height(i, j).md</guid><pubDate>Wed, 13 Mar 2024 09:17:48 GMT</pubDate><enclosure url="lib/media/截圖-2022-10-12-下午2.20.46.jpg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib/media/截圖-2022-10-12-下午2.20.46.jpg&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Union(i, j)]]></title><description><![CDATA[ 
 <br>任意的Union(i, j)<br>
令i, j為root<br>
任取一個i作為New root, 另一個為其子樹<br>Union(i, j){
	j-&gt;Parent = i;
}
複製]]></description><link>考研筆記/資料結構/ch5-tree-and-binary-tree/union(i,-j).html</link><guid isPermaLink="false">考研筆記/資料結構/CH5 Tree and Binary Tree/Union(i, j).md</guid><pubDate>Wed, 13 Mar 2024 09:22:58 GMT</pubDate></item><item><title><![CDATA[Adjacency List]]></title><description><![CDATA[ 
 <br>
vertex[1..n]  of pointer表示<br>
vertex[i]紀錄i的所有相鄰頂點
<br><img alt="../img/截圖 2022-10-28 下午2.42.40.jpg" src="/lib/media/截圖-2022-10-28-下午2.42.40.jpg" style="width: 400px; max-width: 100%;"><br>無向圖：Node總數 = |E| * 2<br>
有向圖：Node總數 = |E| ]]></description><link>考研筆記/資料結構/ch6-graph/adjacency-list.html</link><guid isPermaLink="false">考研筆記/資料結構/CH6 Graph/Adjacency List.md</guid><pubDate>Wed, 13 Mar 2024 09:37:11 GMT</pubDate><enclosure url="lib/media/截圖-2022-10-28-下午2.42.40.jpg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib/media/截圖-2022-10-28-下午2.42.40.jpg&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Adjacency Matrix]]></title><description><![CDATA[ 
 <br>
n x n矩陣紀錄相鄰狀況
<br><img alt="../img/截圖 2022-10-28 下午2.32.19.jpg" src="/lib/media/截圖-2022-10-28-下午2.32.19.jpg" style="width: 300px; max-width: 100%;">]]></description><link>考研筆記/資料結構/ch6-graph/adjacency-matrix.html</link><guid isPermaLink="false">考研筆記/資料結構/CH6 Graph/Adjacency Matrix.md</guid><pubDate>Wed, 13 Mar 2024 09:36:19 GMT</pubDate><enclosure url="lib/media/截圖-2022-10-28-下午2.32.19.jpg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib/media/截圖-2022-10-28-下午2.32.19.jpg&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Adjacency Multilist]]></title><description><![CDATA[ 
 <br>
每一邊用一個Node表示
<br>space需求O(n+e)<br>Node structure : [vi | vj | 指向vi的link | 指向vj的link]<br><img alt="../img/截圖 2022-10-28 下午3.23.44.jpg" src="/lib/media/截圖-2022-10-28-下午3.23.44.jpg" style="width: 400px; max-width: 100%;">]]></description><link>考研筆記/資料結構/ch6-graph/adjacency-multilist.html</link><guid isPermaLink="false">考研筆記/資料結構/CH6 Graph/Adjacency Multilist.md</guid><pubDate>Wed, 13 Mar 2024 09:28:07 GMT</pubDate><enclosure url="lib/media/截圖-2022-10-28-下午3.23.44.jpg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib/media/截圖-2022-10-28-下午3.23.44.jpg&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[AOE Network]]></title><description><![CDATA[ 
 <br>Activity On Edge<br>
定義：以有向圖G=&lt;V, E&gt;表示，其中

<br>vertex：代表Event
<br>edge：代表Activity(工作)
<br>edge之數字：代表此工作所需的工作時長

意義：

<br>所有射入事件(V)的工作皆完成，此事件V才會發生
<br>事件發生後，所有從此事件射出的工作(edge)才可開工

<br>應用<br>
Project Management<br>例<br>Example

Q1. 完成此project 最快需要？天<br>
Ans:求s到e之最長path長度<br>
每輪選擇時間最長的-&gt;30days

 Q2. critical path有哪？條<br>
Ans:

<br>S-&gt;A-&gt;B-&gt;x-&gt;E
<br>S-&gt;A-&gt;B-&gt;y-&gt;E


 Q3.列出所有critical tasks?<br>
Ans:<br>
critical tasks：不可delay的工作 = 最早和最晚開工是同一天的task  = 所有critical path的工作 = {a1, a5, a7, a8, a10, a11}

Q4. 哪些是Bottleneck task?。或者加速哪些功做方可有效縮短Project 完工天數？<br>
Ans:所有critical path的共同工作 = {a1, a5}

Q5. 求出每個工作的最早開工和最晚開工之時間，判斷哪些工作可以delay?且delay?天不至於影響進度。<br>
Ans:

key:

<br>Event最早發生時間 = S到該event之最長路徑
<br>Event最晚發生時間 = 從End往回推，求最小值



<br>先求出各事件之最早發生(ee)以及最晚發生(le)之時間

]]></description><link>考研筆記/資料結構/ch6-graph/aoe-network.html</link><guid isPermaLink="false">考研筆記/資料結構/CH6 Graph/AOE Network.md</guid><pubDate>Wed, 13 Mar 2024 09:47:58 GMT</pubDate><enclosure url="lib/media/截圖-2022-10-29-下午4.48.36.jpg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib/media/截圖-2022-10-29-下午4.48.36.jpg&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[AOV Network]]></title><description><![CDATA[ 
 <br>AOV Network<br>
(Activity On Vertex Network)<br>
定義：其中

<br>頂點：工作
<br>邊：工作之間先後執行關係(i-&gt;j代表i 工作需優先於 j 工作執行)

應用：找出 &gt;= 組合理的工作順序
]]></description><link>考研筆記/資料結構/ch6-graph/aov-network.html</link><guid isPermaLink="false">考研筆記/資料結構/CH6 Graph/AOV Network.md</guid><pubDate>Wed, 13 Mar 2024 09:48:01 GMT</pubDate></item><item><title><![CDATA[Articulation point]]></title><description><![CDATA[ 
 <br><br>（關節點）<br>
定義：在Connected 無向圖中，若將某點及其連接邊刪除，會造成剩下的子圖變成unconnected，則此頂點稱之
<br><img alt="../img/截圖 2022-10-29 下午5.33.53.jpg" src="/lib/media/截圖-2022-10-29-下午5.33.53.jpg" style="width: 300px; max-width: 100%;"><br>計算<br>
如何找出Articulation point<br>
Ans:<br>
<br>先用<a class="internal-link" data-href="../../演算法/CH4 Graph Algorithms/DFS.md" href="/考研筆記/演算法/ch4-graph-algorithms/dfs.html" target="_self" rel="noopener">DFS</a>求出個頂點的dfn(<a class="internal-link" data-href="../../演算法/CH4 Graph Algorithms/DFS.md" href="/考研筆記/演算法/ch4-graph-algorithms/dfs.html" target="_self" rel="noopener">DFS</a> Number)(從任何點開始做皆可)
<br>畫出<a class="internal-link" data-href="../../演算法/CH4 Graph Algorithms/DFS.md" href="/考研筆記/演算法/ch4-graph-algorithms/dfs.html" target="_self" rel="noopener">DFS</a> <a class="internal-link" data-href="spanning Tree.md" href="/考研筆記/資料結構/ch6-graph/spanning-tree.html" target="_self" rel="noopener">spanning Tree</a> 且標出BACK edge
<br>求出個頂點的 Low 值<br>
<img alt="../img/截圖 2022-10-29 下午6.10.12.jpg" src="/lib/media/截圖-2022-10-29-下午6.10.12.jpg" style="width: 300px; max-width: 100%;"><br>
<img alt="../img/截圖 2022-10-29 下午6.09.32.jpg" src="/lib/media/截圖-2022-10-29-下午6.09.32.jpg" style="width: 200px; max-width: 100%;">
low(x) = min{dfn(x), dfn(y)}, y是x的後代，最多經過一條Back edge所到的頂點
複製

<br>判斷規則：

<br>針對spanning tree之root：若root有&gt;= 2個子點，則root是Articulation point
<br>針對非root之頂點x：存在一個x的子點y，若low(y) &gt;= dfn(x)，則x是articulation point


]]></description><link>考研筆記/資料結構/ch6-graph/articulation-point.html</link><guid isPermaLink="false">考研筆記/資料結構/CH6 Graph/Articulation point.md</guid><pubDate>Wed, 13 Mar 2024 09:30:34 GMT</pubDate><enclosure url="lib/media/截圖-2022-10-29-下午5.33.53.jpg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib/media/截圖-2022-10-29-下午5.33.53.jpg&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Biconnected component]]></title><description><![CDATA[ 
 <br><br>
定義：G = (V, E)為連通無向圖。<br>
令G'為G的Biconnected component代表G'為G之子圖，且滿足：

<br>G'本身是Biconnected
<br>沒有其他子圖可以包涵G'且該子圖是Biconnected

<br>用 <a class="internal-link" data-href="Articulation point.md" href="/考研筆記/資料結構/ch6-graph/articulation-point.html" target="_self" rel="noopener">Articulation point</a> 切割<br>
<img alt="../img/截圖 2022-10-29 下午5.51.55.jpg" src="/lib/media/截圖-2022-10-29-下午5.51.55.jpg" style="width: 400px; max-width: 100%;">]]></description><link>考研筆記/資料結構/ch6-graph/biconnected-component.html</link><guid isPermaLink="false">考研筆記/資料結構/CH6 Graph/Biconnected component.md</guid><pubDate>Wed, 13 Mar 2024 09:25:22 GMT</pubDate><enclosure url="lib/media/截圖-2022-10-29-下午5.51.55.jpg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib/media/截圖-2022-10-29-下午5.51.55.jpg&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Biconnected Graph]]></title><description><![CDATA[ 
 <br>
定義：不具有任何articulation point 之connected 無向圖
]]></description><link>考研筆記/資料結構/ch6-graph/biconnected-graph.html</link><guid isPermaLink="false">考研筆記/資料結構/CH6 Graph/Biconnected Graph.md</guid><pubDate>Wed, 13 Mar 2024 09:35:55 GMT</pubDate></item><item><title><![CDATA[CH6 Graph]]></title><description><![CDATA[<a class="tag" href="?query=tag:⭐️⭐️⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️⭐️⭐️</a> <a class="tag" href="?query=tag:⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️</a> <a class="tag" href="?query=tag:⭐️⭐️⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️⭐️⭐️</a> <a class="tag" href="?query=tag:⭐️⭐️⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️⭐️⭐️</a> <a class="tag" href="?query=tag:⭐️⭐️⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️⭐️⭐️</a> <a class="tag" href="?query=tag:⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️</a> <a class="tag" href="?query=tag:⭐️⭐️⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️⭐️⭐️</a> <a class="tag" href="?query=tag:⭐️⭐️⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️⭐️⭐️</a> <a class="tag" href="?query=tag:⭐️⭐️⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️⭐️⭐️</a> <a class="tag" href="?query=tag:⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️</a> <a class="tag" href="?query=tag:⭐️⭐️⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️⭐️⭐️</a> <a class="tag" href="?query=tag:⭐️⭐️⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️⭐️⭐️</a> <a class="tag" href="?query=tag:⭐️⭐️⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️⭐️⭐️</a> <a class="tag" href="?query=tag:⭐️⭐️⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️⭐️⭐️</a> <a class="tag" href="?query=tag:⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️</a> <a class="tag" href="?query=tag:⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️</a> <a class="tag" href="?query=tag:⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️</a> 
 <br>資工所要配合 <a href=".?query=tag:離散數學" class="tag" target="_blank" rel="noopener">#離散數學</a> 一起念<br><br>
圖形用G=&lt;V, E&gt;表示
<br><br>以邊具不具有方向性做分類<br>
<br>Undirected Graph（無向圖）
<br>Directed Graph（有向圖）
<br><br>
<br><a class="internal-link" data-href="Eularian cycle.md" href="/考研筆記/資料結構/ch6-graph/eularian-cycle.html" target="_self" rel="noopener">Eularian cycle</a>
<br><a class="internal-link" data-href="Eularian chain.md" href="/考研筆記/資料結構/ch6-graph/eularian-chain.html" target="_self" rel="noopener">Eularian chain</a>
<br>其他術語<br>
<br><a class="internal-link" data-href="Complete graph.md" href="/考研筆記/資料結構/ch6-graph/complete-graph.html" target="_self" rel="noopener">Complete graph</a>
<br>Subgraph
<br>path（路徑）
<br>path length
<br><a class="internal-link" data-href="simple path.md" href="/考研筆記/資料結構/ch6-graph/simple-path.html" target="_self" rel="noopener">simple path</a>
<br><a class="internal-link" data-href="cycle.md" href="/考研筆記/資料結構/ch6-graph/cycle.html" target="_self" rel="noopener">cycle</a>
<br><a class="internal-link" data-href="Connected.md" href="/考研筆記/資料結構/ch6-graph/connected.html" target="_self" rel="noopener">Connected</a> <a href=".?query=tag:⭐️⭐️⭐️⭐️⭐️" class="tag" target="_blank" rel="noopener">#⭐️⭐️⭐️⭐️⭐️</a>
<br>Connected Component (連通子圖)
<br><a class="internal-link" data-href="Strongly Connected.md" href="/考研筆記/資料結構/ch6-graph/strongly-connected.html" target="_self" rel="noopener">Strongly Connected</a> <a href=".?query=tag:⭐️⭐️" class="tag" target="_blank" rel="noopener">#⭐️⭐️</a>
<br><a class="internal-link" data-href="../../演算法/CH4 Graph Algorithms/strongly connected component.md" href="/考研筆記/演算法/ch4-graph-algorithms/strongly-connected-component.html" target="_self" rel="noopener">strongly connected component</a>（強連通子圖）
<br><a class="internal-link" data-href="Degree.md" href="/考研筆記/資料結構/ch6-graph/degree.html" target="_self" rel="noopener">Degree</a>（分支度）
<br><br>（五種）<br>
<br><a class="internal-link" data-href="Adjacency Matrix.md" href="/考研筆記/資料結構/ch6-graph/adjacency-matrix.html" target="_self" rel="noopener">Adjacency Matrix</a> <a href=".?query=tag:⭐️⭐️⭐️⭐️⭐️" class="tag" target="_blank" rel="noopener">#⭐️⭐️⭐️⭐️⭐️</a>
<br><a class="internal-link" data-href="Adjacency List.md" href="/考研筆記/資料結構/ch6-graph/adjacency-list.html" target="_self" rel="noopener">Adjacency List</a> <a href=".?query=tag:⭐️⭐️⭐️⭐️⭐️" class="tag" target="_blank" rel="noopener">#⭐️⭐️⭐️⭐️⭐️</a>
<br><br>
<br><a class="internal-link" data-href="Adjacency Multilist.md" href="/考研筆記/資料結構/ch6-graph/adjacency-multilist.html" target="_self" rel="noopener">Adjacency Multilist</a> <a href=".?query=tag:⭐️⭐️⭐️" class="tag" target="_blank" rel="noopener">#⭐️⭐️⭐️</a>
<br><a class="internal-link" data-href="Index Array.md" href="/考研筆記/資料結構/ch6-graph/index-array.html" target="_self" rel="noopener">Index Array</a>
<br><a class="internal-link" data-href="Incidence Matrix" href="/考研筆記/資料結構/ch6-graph/incidence-matrix.html" target="_self" rel="noopener">Incidence Matrix</a>
<br><br><br><br><br><br>
給ㄧ個Connected無向圖G=(V, E)且邊上有成本(weight)，則具有最少的成本總和之<a class="internal-link" data-href="spanning Tree" href="/考研筆記/資料結構/ch6-graph/spanning-tree.html" target="_self" rel="noopener">spanning Tree</a>，稱之。
<br>可能有多個MST(if成本皆一樣小)<br>應用<br>
框架：有n個點要接通，如何以最小的成本使其連通<br>
<br>電路佈局成本最小化
<br>n個城市要連通，求最小交通建設/票價成本
<br>u -&gt; v 所有path中，哪條path具有最小的bottleneck
<br><br><br><br><br>不一定是MST<br><br><br>
<br><a class="internal-link" data-href="../../演算法/CH4 Graph Algorithms/DAG-Shortest-path.md" href="/考研筆記/演算法/ch4-graph-algorithms/dag-shortest-path.html" target="_self" rel="noopener">DAG-Shortest-path</a>
<br><a class="internal-link" data-href="../../演算法/CH4 Graph Algorithms/Dijkstra's algorithm.md" href="/考研筆記/演算法/ch4-graph-algorithms/dijkstra's-algorithm.html" target="_self" rel="noopener">Dijkstra's algorithm</a>
<br><a class="internal-link" data-href="../../演算法/CH4 Graph Algorithms/Bellman-Ford algorithm.md" href="/考研筆記/演算法/ch4-graph-algorithms/bellman-ford-algorithm.html" target="_self" rel="noopener">Bellman-Ford algorithm</a>
<br><br>也可以使用single-source-to-other-Destinations，並對所有的點跑一次<br>
但是：<br><br>
<br><a class="internal-link" data-href="../../演算法/CH4 Graph Algorithms/Floyd-Warshall algorithm.md" href="/考研筆記/演算法/ch4-graph-algorithms/floyd-warshall-algorithm.html" target="_self" rel="noopener">Floyd-Warshall algorithm</a>
<br><br><br><br><br><br><br><br>
<br><a class="internal-link" data-href="Articulation point.md" href="/考研筆記/資料結構/ch6-graph/articulation-point.html" target="_self" rel="noopener">Articulation point</a>
<br><a class="internal-link" data-href="Biconnected Graph.md" href="/考研筆記/資料結構/ch6-graph/biconnected-graph.html" target="_self" rel="noopener">Biconnected Graph</a>
<br><a class="internal-link" data-href="Biconnected component.md" href="/考研筆記/資料結構/ch6-graph/biconnected-component.html" target="_self" rel="noopener">Biconnected component</a>
]]></description><link>考研筆記/資料結構/ch6-graph/ch6-graph.html</link><guid isPermaLink="false">考研筆記/資料結構/CH6 Graph/CH6 Graph.md</guid><pubDate>Wed, 13 Mar 2024 09:48:18 GMT</pubDate></item><item><title><![CDATA[Complete graph]]></title><description><![CDATA[ 
 <br>
圖形具有最多邊數稱之

<br>無向圖：若|V| = n(n個點)，最多邊數 = C(n, 2)
<br>有向圖：n(n-1)

]]></description><link>考研筆記/資料結構/ch6-graph/complete-graph.html</link><guid isPermaLink="false">考研筆記/資料結構/CH6 Graph/Complete graph.md</guid><pubDate>Wed, 13 Mar 2024 09:37:10 GMT</pubDate></item><item><title><![CDATA[Connected]]></title><description><![CDATA[ 
 <br>
對無向圖而言，所有的頂點對 之間皆有path存在<br>
任兩點之間皆至少有一路徑
]]></description><link>考研筆記/資料結構/ch6-graph/connected.html</link><guid isPermaLink="false">考研筆記/資料結構/CH6 Graph/Connected.md</guid><pubDate>Wed, 13 Mar 2024 09:48:18 GMT</pubDate></item><item><title><![CDATA[cycle]]></title><description><![CDATA[ 
 <br>
起點終點一樣的<a class="internal-link" data-href="simple path.md" href="/考研筆記/資料結構/ch6-graph/simple-path.html" target="_self" rel="noopener">simple path</a>
]]></description><link>考研筆記/資料結構/ch6-graph/cycle.html</link><guid isPermaLink="false">考研筆記/資料結構/CH6 Graph/cycle.md</guid><pubDate>Wed, 13 Mar 2024 09:48:58 GMT</pubDate></item><item><title><![CDATA[Degree]]></title><description><![CDATA[ 
 <br>
無向圖，連接的邊數<br>
有向圖:

<br>out degree:連出去的邊數
<br>in degree:連進來的邊數

]]></description><link>考研筆記/資料結構/ch6-graph/degree.html</link><guid isPermaLink="false">考研筆記/資料結構/CH6 Graph/Degree.md</guid><pubDate>Wed, 13 Mar 2024 09:48:46 GMT</pubDate></item><item><title><![CDATA[Eularian chain]]></title><description><![CDATA[ 
 <br>
一個無向圖，從某一點出發，經過每個邊個一次，最後沒有回到原出發點。<br>
只有2個頂點的Degree是奇數，其他為偶數。
]]></description><link>考研筆記/資料結構/ch6-graph/eularian-chain.html</link><guid isPermaLink="false">考研筆記/資料結構/CH6 Graph/Eularian chain.md</guid><pubDate>Wed, 13 Mar 2024 09:37:11 GMT</pubDate></item><item><title><![CDATA[Eularian cycle]]></title><description><![CDATA[ 
 <br>
一個無向圖，從某一點出發，經過每個邊個一次，最後回到原出發點。<br>
每一個點的degree必須是偶數
]]></description><link>考研筆記/資料結構/ch6-graph/eularian-cycle.html</link><guid isPermaLink="false">考研筆記/資料結構/CH6 Graph/Eularian cycle.md</guid><pubDate>Wed, 13 Mar 2024 09:37:11 GMT</pubDate></item><item><title><![CDATA[Incidence Matrix]]></title><description><![CDATA[ 
 <br>無向圖<br>
準備一個n * e的矩陣<br>
有那一條邊就填1<br>
其餘0
<br><img alt="../img/截圖 2022-10-28 下午3.33.22.jpg" src="/lib/media/截圖-2022-10-28-下午3.33.22.jpg" style="width: 400px; max-width: 100%;"><br>有向圖<br>
有那一條出去的邊填-1<br>
有那一條近來的邊填1<br>
其餘0
<br><img alt="../img/截圖 2022-10-28 下午3.35.55.jpg" src="/lib/media/截圖-2022-10-28-下午3.35.55.jpg" style="width: 400px; max-width: 100%;">]]></description><link>考研筆記/資料結構/ch6-graph/incidence-matrix.html</link><guid isPermaLink="false">考研筆記/資料結構/CH6 Graph/Incidence Matrix.md</guid><pubDate>Wed, 13 Mar 2024 09:36:20 GMT</pubDate><enclosure url="lib/media/截圖-2022-10-28-下午3.33.22.jpg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib/media/截圖-2022-10-28-下午3.33.22.jpg&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Index Array]]></title><description><![CDATA[ 
 <br><img alt="../img/截圖 2022-10-28 下午3.28.27.jpg" src="/lib/media/截圖-2022-10-28-下午3.28.27.jpg" style="width: 400px; max-width: 100%;">]]></description><link>考研筆記/資料結構/ch6-graph/index-array.html</link><guid isPermaLink="false">考研筆記/資料結構/CH6 Graph/Index Array.md</guid><pubDate>Wed, 13 Mar 2024 09:48:01 GMT</pubDate><enclosure url="lib/media/截圖-2022-10-28-下午3.28.27.jpg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib/media/截圖-2022-10-28-下午3.28.27.jpg&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Kruskal's Algo]]></title><description><![CDATA[<a class="tag" href="?query=tag:⭐️⭐️⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️⭐️⭐️</a> 
 <br><br>挑最小的到完成<br>
<a href=".?query=tag:⭐️⭐️⭐️⭐️⭐️" class="tag" target="_blank" rel="noopener">#⭐️⭐️⭐️⭐️⭐️</a><br>
找出G中的<a class="internal-link" data-href="spanning Tree.md" href="/考研筆記/資料結構/ch6-graph/spanning-tree.html" target="_self" rel="noopener">spanning Tree</a>的一種演算法<br>
令G=(V, E)為Connected 無向圖
<br>steps<br>
<br>自E中挑出最小成本的邊(u, v)
<br>檢查(u, v)加入後是否會出現cycle

<br>出現cycle:放棄此邊
<br>沒有cycle:加入S


<br>Repeat 1. ~ 2. n-1次 or E為空
<br>Time 分析<br>
假設G的頂點數:V，邊數:E<br>
<br>令E中各成本值以<a class="internal-link" data-href="../CH5 Tree and Binary Tree/CH5 Tree and Binary Tree.md## Heap #⭐️⭐️⭐️⭐️⭐️" href="/考研筆記/資料結構/ch5-tree-and-binary-tree/ch5-tree-and-binary-tree.html#" target="_self" rel="noopener">min Heap</a>維護
<br>最多執行E回合
<br>每一回合執行

<br>Delete min edge from E: O(log E)
<br>判斷cycle：利用<a class="internal-link" data-href="../CH5 Tree and Binary Tree/CH5 Tree and Binary Tree.md#Union(i, j)與Find(x)運作之3種組合,討論" href="/考研筆記/資料結構/ch5-tree-and-binary-tree/ch5-tree-and-binary-tree.html#Union(i,_j)與Find(x)運作之3種組合,討論" target="_self" rel="noopener">Disjoint Sets 中的Union &amp;Find</a>運作。
if(Find(u)!= Find(v)){
	//if 採"Union-by-weight", "Find-with-path-compression"
	Add(u, v)edge into S;
	Union(u, v) 
}
複製
   Find(u), Find(v): O(1)<br>
Union(u, v): O(1)


<br>-&gt; O(logE)+O(1)<br>
-&gt; O(logE)<br>
執行E回合 -&gt; O(ElogE)<br><br>Kruskal(G, w){
	A = {};
	for each vertex v in G.V{
		MakeSet(v);//頂點各自為一個集合
	}
	G.E = Sort(G.E)//成本由小-&gt;大排序
	for each edge(u, v) in G.E{
		if(Find(u)!=Find(v)){
			A = A ∪{u, v};
			Union(u, v);
		}
	}
	return A;
}
複製<br>Time 分析<br>
O(V)+O(ElogE)+O(E)<br>
-&gt; O(Elog E)<br>
此外由於E &lt;&lt; V² (E最多C(V, 2))<br>
所以O(Elog E) &lt;= O(Elog V²) = O(2ElogV)<br>
-&gt; O(Elog V)]]></description><link>考研筆記/資料結構/ch6-graph/kruskal&apos;s-algo.html</link><guid isPermaLink="false">考研筆記/資料結構/CH6 Graph/Kruskal&apos;s Algo.md</guid><pubDate>Wed, 13 Mar 2024 09:37:14 GMT</pubDate></item><item><title><![CDATA[Prim's Algo[DS版本]]]></title><description><![CDATA[<a class="tag" href="?query=tag:⭐️⭐️⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️⭐️⭐️</a> 
 <br><a href=".?query=tag:⭐️⭐️⭐️⭐️⭐️" class="tag" target="_blank" rel="noopener">#⭐️⭐️⭐️⭐️⭐️</a><br>
從“已開拓的周圍”找最小<br>
找“跨越的”邊<br><br>
令G=(V, E)為Connected無向圖<br>
令V = {1, 2, 3, 4, 5, ..., n}<br>
令U= {1}。" 1 " 表起點
<br>steps<br>
<br>挑出最小的邊(u, v)其中u∈U and v∈ V
<br>(u, v)加入S，且v自V-U中移除移到U中
<br>repeat 1 ~ 2直到U=V or E為空
<br><img alt="../img/截圖 2022-10-28 下午8.35.20.jpg" src="/lib/media/截圖-2022-10-28-下午8.35.20.jpg" style="width: 200px; max-width: 100%;"><br>
最後一步是(4, 5)<br><br>MSTPrim(G, w, r){
	for each u in G.V{
		u.key = ♾;
		u.𝝅 = Nil;
	}
	r.key = 0;
	Q = G.V; //依照key值建立priority queue: Q
	while(!isEmpty(Q)){
		u = Extract-min(Q);//就是找鄰近成本最低的頂點
		//而Extract出來的會影響周圍
		for each v in G.adj[u]{//u的相鄰
			if(v ∈ Q and w(u, v)&lt; v.key){//刷新周遭v的價值
				v.𝝅 = u;
				v.key = w(u, v);
			}
		}
	}
}
複製<br>Time分析<br>
Init: O(V)<br>
建立Queue(Heap):O(V)<br>
Extract-min : O(logV) ，做V次-&gt;O(VlogV)<br>
for loop共檢視 2E個頂點 -&gt; O(2E* logV)(使用Heap)<br>此動作相當於一個Decrease-Key(Heap:<a class="internal-link" data-href="../CH5 Tree and Binary Tree/CH5 Tree and Binary Tree.md#operations 及 Time" href="/考研筆記/資料結構/ch5-tree-and-binary-tree/ch5-tree-and-binary-tree.html#operations_及_Time" target="_self" rel="noopener">Heap</a>, Fib Heap:<a class="internal-link" data-href="../CH9 Advanced Tree/CH9 Advanced Tree.md#Fibonacci Heap" href="/考研筆記/資料結構/ch9-advanced-tree/ch9-advanced-tree.html#Fibonacci_Heap" target="_self" rel="noopener">Fibonacci Heap</a><br>-&gt; O(V) +O(V)+O(VlogV)+O(Elog V)<br>
-&gt;O(ElogV)與<a class="internal-link" data-href="Kruskal's Algo.md" href="/考研筆記/資料結構/ch6-graph/kruskal's-algo.html" target="_self" rel="noopener">Kruskal's Algo</a>相同<br>若要加速改用<a class="internal-link" data-href="../CH9 Advanced Tree/Fibonacci Heap.md" href="/考研筆記/資料結構/ch9-advanced-tree/fibonacci-heap.html" target="_self" rel="noopener">Fibonacci Heap</a><br>
-&gt; O(V) +O(V)+O(VlogV)+O(E)<br>
-&gt;O(VlogV + E)]]></description><link>考研筆記/資料結構/ch6-graph/prim&apos;s-algo.html</link><guid isPermaLink="false">考研筆記/資料結構/CH6 Graph/Prim&apos;s Algo.md</guid><pubDate>Wed, 13 Mar 2024 09:48:02 GMT</pubDate><enclosure url="lib/media/截圖-2022-10-28-下午8.35.20.jpg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib/media/截圖-2022-10-28-下午8.35.20.jpg&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[simple path]]></title><description><![CDATA[ 
 <br>
除了起點和終點相同，中間經過的點皆不相同
]]></description><link>考研筆記/資料結構/ch6-graph/simple-path.html</link><guid isPermaLink="false">考研筆記/資料結構/CH6 Graph/simple path.md</guid><pubDate>Wed, 13 Mar 2024 09:48:04 GMT</pubDate></item><item><title><![CDATA[Sollin's Algo]]></title><description><![CDATA[ 
 <br><br>每個頂點向外延伸<br>
一開始各頂點視為獨立的Root
<br>steps:<br>
<br>各tree挑出最小的cost 之樹邊
<br>刪除重複挑出的樹邊，保留一份即可
<br>repeat 1 ~ 2直到剩下一顆樹
]]></description><link>考研筆記/資料結構/ch6-graph/sollin&apos;s-algo.html</link><guid isPermaLink="false">考研筆記/資料結構/CH6 Graph/Sollin&apos;s Algo.md</guid><pubDate>Wed, 13 Mar 2024 09:46:51 GMT</pubDate></item><item><title><![CDATA[spanning Tree]]></title><description><![CDATA[<a class="tag" href="?query=tag:⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️</a> 
 <br>spanning Tree<br><a href=".?query=tag:⭐️" class="tag" target="_blank" rel="noopener">#⭐️</a><br>
用某種搜尋法(BFS, DFS)建出來的Tree<br>
給一個Connected, 無向圖G= (V, E)，令S=(V, T)為G的其中一個spanning Tree，則S滿足下列性質：

<br>E = T + B：T為拜訪經過的edges，B為未經過的edges
<br>自B中任取一邊加入S中，必定會形成一個unique cycle
<br>在S中，任何頂點之間存在一條unique "simple path"

<br>若G is unconnected則無spanning tree]]></description><link>考研筆記/資料結構/ch6-graph/spanning-tree.html</link><guid isPermaLink="false">考研筆記/資料結構/CH6 Graph/spanning Tree.md</guid><pubDate>Wed, 13 Mar 2024 09:46:48 GMT</pubDate></item><item><title><![CDATA[Strongly Connected]]></title><description><![CDATA[ 
 <br>
在有向圖中，任意兩點i, j之間，存在i-&gt;j 以及j-&gt; i 的兩個路徑
]]></description><link>考研筆記/資料結構/ch6-graph/strongly-connected.html</link><guid isPermaLink="false">考研筆記/資料結構/CH6 Graph/Strongly Connected.md</guid><pubDate>Wed, 13 Mar 2024 09:30:36 GMT</pubDate></item><item><title><![CDATA[Topological sort]]></title><description><![CDATA[ 
 <br>
給予一個不具<a class="internal-link" data-href="cycle.md" href="/考研筆記/資料結構/ch6-graph/cycle.html" target="_self" rel="noopener">cycle</a>的AOV Network, 則至少有&gt;= 1組頂點拜訪順序滿足：“若i有path到 j ，則在此排序中, i必定出現在j之前“，此種順序稱之
<br>有cycle則無Topological sort<br>求Topological sort[DS]<br>
<br>找出In-Degree = 0之頂點 i
<br>輸出 i，且假設有i -&gt; j，則j之In-Degree--
<br>repeat 1, 2直到所有點均輸出 or 沒有In-Degree = 0的點
<br>若非所有點皆輸出，則無Topological sort
<br><a class="internal-link" data-href="../../演算法/CH4 Graph Algorithms/Topological Sort.md" href="/考研筆記/演算法/ch4-graph-algorithms/topological-sort.html" target="_self" rel="noopener">Topological Sort[Algo]</a>]]></description><link>考研筆記/資料結構/ch6-graph/topological-sort.html</link><guid isPermaLink="false">考研筆記/資料結構/CH6 Graph/Topological sort.md</guid><pubDate>Wed, 13 Mar 2024 09:36:20 GMT</pubDate></item><item><title><![CDATA[Bubble sort]]></title><description><![CDATA[<a class="tag" href="?query=tag:stable" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#stable</a> 
 <br><br><a href=".?query=tag:stable" class="tag" target="_blank" rel="noopener">#stable</a> <br>
觀念：

<br>由左而右/有而左，兩兩比較，若前者(左邊)&gt;後者(有邊)，SWAP(前, 後)
<br>每一回合完，當時的sublist中最大值回到最高位置
<br>最多做(n-1)回合。若某一回合未發生任何SWAP則提前結束。

Stable
<br>Algo<br>BubbleSort(A[], n){
	for i = 1 to (n-1) do{
		flag = False;//表示有無SWAP
		for j = i to n-i do{
			if(A[j] &gt; A[j+1]){
				Swap(A[j], A[j+1]);
				flag = True;
			}
		}
		if(!flag)return;
	}
}
複製<br>分析Time Complexity（類似<a class="internal-link" data-href="Insertion sort.md" href="/考研筆記/資料結構/ch7-search-and-sort/insertion-sort.html" target="_self" rel="noopener">Insertion sort</a>)<br>
<br>Best Case:O(n)<br>
情況：input data 小-&gt;大<br>
說明：

<br>量化比較/Swap次數，在pass1中，經過n-1次的兩兩相互比較，沒有Swap發生-&gt; 完成 -&gt; O(n)
<br>recursive Time function：T(n) = n-1 + 0 = O(n)


<br>Worst Case:O(n²)<br>
情況：input data是反序（大-&gt;小）<br>
說明：

<br>量化：第一回合swap(n-1)次、第二回合swap(n-2)次，總共n(n-1)/2 -&gt; O(n²)
<br>Recursive Time function：T(n) = T(n-1) + n-1 = n(n-1)/2 = O(n²)


<br>Avg.<br>
說明：T(n) = c n + T(n-1), c為常數
<br>Space Complexity: O(1)]]></description><link>考研筆記/資料結構/ch7-search-and-sort/bubble-sort.html</link><guid isPermaLink="false">考研筆記/資料結構/CH7 Search and Sort/Bubble sort.md</guid><pubDate>Wed, 13 Mar 2024 09:25:23 GMT</pubDate></item><item><title><![CDATA[CH7 Search and Sort]]></title><description><![CDATA[<a class="tag" href="?query=tag:⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️</a> <a class="tag" href="?query=tag:⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️</a> <a class="tag" href="?query=tag:⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️</a> <a class="tag" href="?query=tag:⭐️⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️⭐️</a> <a class="tag" href="?query=tag:stable" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#stable</a> <a class="tag" href="?query=tag:⭐️⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️⭐️</a> <a class="tag" href="?query=tag:⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️</a> <a class="tag" href="?query=tag:⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️</a> 
 <br><br><br><br>從左到右一一搜尋直到找到為止or找不到為止<br><br>
資料必須事先排序<br>
資料須保存於<a class="internal-link" data-href="../../作業系統/CH9 Disk Management/Random(Direct) Access.md" href="/考研筆記/作業系統/ch9-disk-management/random(direct)-access.html" target="_self" rel="noopener">Random(Direct) Access</a>機制上
<br>O(logn)<br><br><br><br>可否一次全部放在記憶體內。常見的外部排序方法，<a class="internal-link" data-href="#Merge sort" href="/#Merge_sort" target="_self" rel="noopener">Merge sort</a>,<a class="internal-link" data-href="../CH9 Advanced Tree/CH9 Advanced Tree.md#m-way search Tree" href="/考研筆記/資料結構/ch9-advanced-tree/ch9-advanced-tree.html#m-way_search_Tree" target="_self" rel="noopener">m-way search tree</a> , <a class="internal-link" data-href="../CH5 Tree and Binary Tree/CH5 Tree and Binary Tree.md#Binary tree" href="/考研筆記/資料結構/ch5-tree-and-binary-tree/ch5-tree-and-binary-tree.html#Binary_tree" target="_self" rel="noopener">B Tree</a>, B+ Tree等<br><br>
通常Input data中常會有一些具有相同鍵值的資料，若A, B, C, ...經過排序(過程中）後仍為A, B, C, ...，則稱此方法為Stable，否則Unstable
<br>
<br>Stable: <a class="internal-link" data-href="#Insertion sort" href="/#Insertion_sort" target="_self" rel="noopener">Insertion Sort</a>, <a class="internal-link" data-href="#Bubble sort" href="/#Bubble_sort" target="_self" rel="noopener">Bubble Sort</a>, <a class="internal-link" data-href="#Merge sort" href="/#Merge_sort" target="_self" rel="noopener">Merge Sort</a>, Radix sort, Bucket sort, counting sort
<br>Unstable: <a class="internal-link" data-href="#Selection sort" href="/#Selection_sort" target="_self" rel="noopener">Selection sort</a>, Shell, Quick, Heap sort
<br>Unstable會比Stable多了不必要的交換<br>
不代表Unstable比較差<br><br>
An in-place algorithm is an algorithm that does not need an extra space and produces an output in the same memory that contains the data by transforming the input 'in place'<br>
=&gt; 排序過程中會不會利用到額外空間(包含遞迴的stack)
<br>高等以及初等排序方法中，只有<a class="internal-link" data-href="Merge Sort.md" href="/考研筆記/資料結構/ch7-search-and-sort/merge-sort.html" target="_self" rel="noopener">Merge Sort</a>不是sorting in-place，其餘都是。<br>
但若不考慮遞迴的stack空間，Quick Sort也是 in-place<br><br>都是屬於Comparison-based<br><br>將每個元素依序丟入，元素會「落」到對應的位置<br><br>找出剩餘集合中最小的，往前放<br><br><br>少考<br><br><br>最快速<br>
跟pivot key比大小，往左右堆起來，然後pivot塞中間。<br><br><a href=".?query=tag:stable" class="tag" target="_blank" rel="noopener">#stable</a><br><br><br><br>
<br>在限定使用"Comparison-based" skill，則最快𝝮(n log n)
<br>初等及高等排序皆是Comparison-based<br>
<br>若果未限定使用此技巧，則排序時間有可能達到linear time: O(n)
<br>Any sorting method 最快可達𝝮(nlogn)? Ans :False<br>Any sorting method that based on Comparison, 最快可達𝝮(nlogn)? Ans :True<br><br>總排序有n!種
Decision Tree 高度必≧⎡log(n!)⎤+1
-&gt;比較次數≧⎡log(n!)⎤ ~= nlogn
𝜴(n log n)
複製<br><img alt="../img/截圖 2022-10-24 下午3.39.38.jpg" src="/lib/media/截圖-2022-10-24-下午3.39.38.jpg" style="width: 300px; max-width: 100%;"><br>
由上述Desision Tree知<br>
<br>It's a Binary Tree
<br>Non-Leaf 表_比較_Node
<br>Leaf表某排序結果
<br>n個Data之排序可能結果有n!種
<br>最多比較次數=高度-1
<br>證明：<br>
n個Data做Sorting, 有n!個可能的排序結果，以描述比較過程的Desision Tree而言，即有n!個Leaves，他又是Binary Tree，高度至少 &gt;= ⎡log(n!)⎤<br>
比較次數 = 高度-1 &gt;= ⎡log(n!)⎤ &gt;= c n logn -&gt; 𝝮(n log n)
<br>5個Data以Comparison-based skill doing sorting，最少比較次數?不可用nlogn = 5log₂5<br>
要用⎡log(n!)⎤  = ⎡log(5!)⎤ =7<br>雖然題目是說「最少」，但通常依然使用⎡log(n!)⎤<br><br>這裡的都是屬於Counting-based<br>
Linear-Time Sorting methods<br>
當排序技巧並非採用Comparison-based, 則有機會突破𝝮(nlogn)限制，來到O(n)time
<br><br><br><br><br>限制0~k排序，記錄出現次數，姐此找出出現起始位置<br><br><br><br><br><br><br>steps:<br>
<br>先經過(n-1)次比較後，即可找到min
<br>在剩下(n-1)個Data中，再經過(n-2)次比較即可找到Max
<br>總共比較次數=(n-1)+(n-2) = 2n-3次<br>有沒有其他方法，比較次數&lt; 2n-3 ?<br><br>steps:<br>
<br>比較A[1], A[2] 1 次及可知誰小誰大（不失一般性令A[1]小）
<br>遞迴針對剩下(n-2)個data，找出min (x) &amp; Max (y)
<br>比較A[1]與x 1次，即可知道整體的min;比較A[2]與y 1次，即可知道整體的Max
<br>T(n) = T(n-2)+ 3, T(0) =0, T(1) = 0, T(2) = 1
T(n) = 3n/2 &lt; 2n-3 當n很大
複製<br><br>n個unsorted data 找出第i小的data<br><br>steps: <br>
<br>將n個data做Sorting
<br>return Array[i];
<br>Total time = O(nlog n)<br>有沒有其他方法在O(n) Avg time 達成?<br><br>利用<a class="internal-link" data-href="Quick Sort.md" href="/考研筆記/資料結構/ch7-search-and-sort/quick-sort.html" target="_self" rel="noopener">Quick Sort</a>中的Partition副程式<br>Algo<br>Select(A[], p, r, i){
	//在A[p]~A[r]中找出ith小元素
	if(p&lt;r){
		q = Partition(A, p, r);
		k = q-p+1; //pk是A[p]~A[r]中kth 小的data
		if(i==k)return A[q]
		else if(i&lt;k)return Select(A, p, q-1, i);
		else return Select(A, q+1, r, i-k); //i在q右邊
	}
}
複製<br>Time 分析:<br>
<br>Best case:完美分兩半<br>
T(n) = T(n/2)+O(n)<br>
-&gt; T(n) =O(n) or 𝝷(n)
<br>Avg. case:O(n)
<br>Worst case: 切割沒有效果（若pk剛好是最大or最小值）<br>
-&gt; O(n²)
<br><br><a class="internal-link" data-href="../../演算法/CH2 Divide-and-Conquer/CH2 Divide-and-Conquer.md#The selection algorithm" href="/考研筆記/演算法/ch2-divide-and-conquer/ch2-divide-and-conquer.html#The_selection_algorithm" target="_self" rel="noopener">The Selection algorithm</a><br>
希望可以在Worst case下，找ith 小元素可以在O(n)time完成<br>原則：慎選pk<br>
先前：<br>
<br>middle-of-three
<br>以"median-of-medians"為pk進行切割
<br>Select(A, p, r, i){
	1. data切割成⎡n/5⎤個groups，每個group內有5個data（最後一個group可能不到5個）//O(n)
	2. 每個group各自排序好//T(⎡n/5⎤)*O(1) = O(n)
	3. 取每一個group的3th資料（中間），在這些中間值中找出中間值，以它作為pk。//T(⎡n/5⎤)
	q = Partition(A, p, r) //O(n)
	k = q-p+1;
	if(i == k)return A[q];
	else if(i&lt;k)return Select(A, p, q-1, i);
	else return Select(A, q+1, r, i-k);
}
複製<br>Time:<br>
T(n) = O(n)+O(n)+T(⎡n/5⎤)+O(n)+ T(⎡7n/10⎤+6)<br>
-&gt; T(n) = T(⎡n/5⎤)+O(n)+ T(⎡7n/10⎤)<br>
~= T(n/5)+ T(7n/10)+ cn<br>
&lt;= cn*常數 -&gt; O(n)<br>也可以7, 9, ...個一組，唯獨不能&lt;5個為一組(會變成O(nlogn))<br>若每個group元素數量 = 3，T(n)= ?“../img/截圖 2022-10-25 下午9.14.47.jpg” could not be found.]]></description><link>考研筆記/資料結構/ch7-search-and-sort/ch7-search-and-sort.html</link><guid isPermaLink="false">考研筆記/資料結構/CH7 Search and Sort/CH7 Search and Sort.md</guid><pubDate>Wed, 13 Mar 2024 09:21:39 GMT</pubDate><enclosure url="lib/media/截圖-2022-10-24-下午3.39.38.jpg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib/media/截圖-2022-10-24-下午3.39.38.jpg&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Counting Sort]]></title><description><![CDATA[<a class="tag" href="?query=tag:stable" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#stable</a> 
 <br>Counting Sort<br>
<a href=".?query=tag:stable" class="tag" target="_blank" rel="noopener">#stable</a> <br>假設n= Data 個數, or 值域0~k<br>8個data, 值域:0~5，給 2, 5, 3, 0, 2, 3, 0, 3 實施Counting Sortsteps:

<br>統計各個值域之出現次數，紀錄在Count[0..k]中。
<br>求各鍵值知未來排序好之起始位置，紀錄在start[0..k]中
<br>依照各鍵值之start位置將，input data置入output array中的正確位置，且對應的start加1

“../img/截圖 2022-10-25 下午6.44.07.jpg” could not be found.
for i = 0 to k
	count[i] = 0;
for i = 1 to n
	count[A[i]]++;
start[0] = 1;
for i = 1 to k
	start[i] = start[i-1] + Count[i-1]
for i=1 to n{
	output[start[A[i]]] = A[i];
	start[A[i]]++;
}
複製<br>分析：<br>
<br>Time Complexity: O(k)+O(n)+O(k)+O(n) = O(n+k)
<br>Space Complexity: 額外空間需求-&gt; Count[0..k], start[0..k]及output[1..n] -&gt;O(n+k)
<br>為何TimeO(n+k)是linear time?
<br>說法一<br>
若值域range 0~k而k是O(n)等級，則O(n+k) = O(n+O(n)) ∈ O(n)
<br>說法二<br>
因為值域k受到限制，可視為常數c -&gt; O(n)
<br>經典問題(Counting Sort Bible問題)已知O(n+k)是linear time if k belong to degree of O(n)<br>
但是如果k belong to degree of O(n²)，則O(n+k) = O(n+O(n²)) != O(n)<br>
請問是否仍可創造出linear time Sorting 呢？

Ans: True<br>
“../img/截圖 2022-10-25 下午6.58.36.jpg” could not be found.<br>
原則：利用<a class="internal-link" data-href="LSD Radix Sort.md" href="/考研筆記/資料結構/ch7-search-and-sort/lsd-radix-sort.html" target="_self" rel="noopener">LSD</a>觀念<br>
分成兩個回合完成排序

<br>以 Data[i]%n 為排序依據實施Counting Sort。因為值域在o~(n-1), k∈O(n)等級 -&gt; 此回合花O(n+k) ∈O(n)等級
<br>以 (Data[i]/n)%n為排序依據且以1.之output為input實施Counting Sort。也是O(n)time

依據<a class="internal-link" data-href="LSD Radix Sort.md" href="/考研筆記/資料結構/ch7-search-and-sort/lsd-radix-sort.html" target="_self" rel="noopener">LSD Radix Sort</a>的概念，加上Counting Sort is stable，所以可以排序正確結果<br>
=&gt; 這兩回合2 * O(n) time 仍為linear time
擴充：O(n^k) k&gt;2 也可以創造linear time sorting]]></description><link>考研筆記/資料結構/ch7-search-and-sort/counting-sort.html</link><guid isPermaLink="false">考研筆記/資料結構/CH7 Search and Sort/Counting Sort.md</guid><pubDate>Wed, 13 Mar 2024 09:24:32 GMT</pubDate></item><item><title><![CDATA[Heap Sort]]></title><description><![CDATA[<a class="tag" href="?query=tag:unstable" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#unstable</a> 
 <br><br><a href=".?query=tag:unstable" class="tag" target="_blank" rel="noopener">#unstable</a><br>
steps<br>
<br>先用Bottom-up方式<a class="internal-link" data-href="../CH5 Tree and Binary Tree/Build a Heap with n nodes.md" href="/考研筆記/資料結構/ch5-tree-and-binary-tree/build-a-heap-with-n-nodes.html" target="_self" rel="noopener">建立Max-Heap</a>-&gt;Time:O(n)
<br>執行(n-1)回合，每一回合執行類似<a class="internal-link" data-href="../CH5 Tree and Binary Tree/Delete-MAX in  MAX-Heap.md### Delete-MAX in  MAX-Heap" href="/考研筆記/資料結構/ch5-tree-and-binary-tree/delete-max-in-max-heap.html#" target="_self" rel="noopener">Delete-MAX</a>運作。及Root與當時the last Node做Swap, 針對剩下的Data, adjust 成Heap
<br>給3, 7, 1, 5, 9, 8, 10, 2, 6實施之
<br>先建立Heap
<br>尾補到Root（頭放入排序的Max），再做adjust
<br>一直拿走Root直到Heap為空
<br>Algo<br>
分成<br>
<br><a class="internal-link" data-href="../CH5 Tree and Binary Tree/Build a Heap with n nodes.md##### Adjust(tree, i, n)" href="/考研筆記/資料結構/ch5-tree-and-binary-tree/build-a-heap-with-n-nodes.html#" target="_self" rel="noopener">Adjust(tree, i, n)</a>
<br>HeapSort(tree, n)
HeapSort(tree, n){
	for(i=n/2; i&gt;=1; i--)//Build
		Adjust(tree, i, n);
	for(i=n-1; i&gt;=1; i--){
		Swap(tree[1], tree[i+1]);
		Adjust(tree, 1, i);//對剩下的資料重新整理
	}
}
複製

<br>分析<br>
<br>Time Complexity: Avg./ worst/ Best case : O(nlogn)<br>
建立：O(n<br>
(n-1)回合，每回合花O(logn)，共花O(nlogn)<br>
-&gt;O(nlogn)
<br>Space Complexity:O(1)<br>
例如：5, 5*, 1
]]></description><link>考研筆記/資料結構/ch7-search-and-sort/heap-sort.html</link><guid isPermaLink="false">考研筆記/資料結構/CH7 Search and Sort/Heap Sort.md</guid><pubDate>Wed, 13 Mar 2024 09:28:04 GMT</pubDate></item><item><title><![CDATA[Insertion sort]]></title><description><![CDATA[<a class="tag" href="?query=tag:stable" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#stable</a> 
 <br><br><a href=".?query=tag:stable" class="tag" target="_blank" rel="noopener">#stable</a><br>
觀念：<br>
將第[i]筆Data插入到前面(i-1)筆以排序好的串列中之正確位置，使之成為i筆已排序好的串列<br>
i = 2 to n，做n-1回合
<br>Algo 由下列兩項組成<br>
<br>Insert(A[], r, i)副程式
<br>Insort(A[], n)主程式
<br>Insert(A[], r, i){
	//資料r插入到A[0]~A[i]以排序的串列。r是A[i+1]的data
	j = i;
	while(r &lt; A[j]){
		A[j+1] = A[j];
		j = j-1;
	}
	A[j+1] = r
}
複製<br>Insort(A[], n){
	//排序A[1]~A[n] n筆data
	//會多一個額外空間
	
	A[0] = -無限; //防止r的湧入
	for i = 2 to n  do
		Insert(A[], A[i], i-1);
}
複製<br>複雜度分析<br>
<br>Best case:O(n) （Input data剛好是小-&gt;大排序）<br>
說明：

<br>量化：每回合比較一次後就找出正確位置-&gt;n-1回合。
<br>recursive funciton：T(n) = T(n-1)+{第n比要插入的最小比較次數 = 1次} = n-1
<br>(很少用)Inversion(x):在input Data中出現在x左邊sublist 中大於的Data 數目


<br>Worst case : O(n²) （input data是反序給予，大-&gt;小）<br>
說明：

<br>直接舉例
<br>recursive Time function：T(n) = T(n-1) + n-1 = (n-1)(n)/2


<br>Avg. case：O(n²)<br>
T(n) = T(n-1)+{O(n) or c n or n/2}
<br>Space Complexity -&gt; O(1)<br>
額外空間需求（除了input data外）是固定的，與資料量n無關。<br><br>原本的每一回合做兩個工作<br><br>每一回合花O(n), 做(n-1)回合 -&gt; O(n²) <br>常見之變形：<br><br><br>因此improve the Comparison 次數但未improve data movement 次數-&gt;  <br><br><br>因此improve the data movement 次數但未improve Comparison 次數-&gt;  ]]></description><link>考研筆記/資料結構/ch7-search-and-sort/insertion-sort.html</link><guid isPermaLink="false">考研筆記/資料結構/CH7 Search and Sort/Insertion sort.md</guid><pubDate>Wed, 13 Mar 2024 09:23:49 GMT</pubDate></item><item><title><![CDATA[LSD Radix Sort]]></title><description><![CDATA[<a class="tag" href="?query=tag:⭐️⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️⭐️</a> <a class="tag" href="?query=tag:stable" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#stable</a> 
 <br><br><a href=".?query=tag:⭐️⭐️⭐️⭐️" class="tag" target="_blank" rel="noopener">#⭐️⭐️⭐️⭐️</a> 考計算題<br><a href=".?query=tag:stable" class="tag" target="_blank" rel="noopener">#stable</a> <br>
<br>假設基底(or 進制)為r -&gt;準備r個桶子，編號0~(r-1)
<br>令input data 中最大值之位數個數= d，代表要執行d回合，才可完成sorting
如何知道MAX值位數個數？（等於回合數）
<br>[法一]：先花O(n) time找出MAX值
<br>[法二]：已知（規定;限制）input data“值域範圍”此即為Radix sort關鍵

卡住/固定 回合數

<br>LSD：從最低位數開始，到最高位數執行各回合之工作。（例：pass1:個位數, pass2:十位數, ...）
<br>每一回合之2 個主要工作

<br>分派：依資料某位數值分派到對應Bucket中
<br>合併：依照Bucket No:0~(r-1)合併所有Buckets 之Data lists


<br>LSD Radix Sort, 基底十進制。179, 208, 306, 93, 859, 984, 55, 9, 271, 33“../../img/截圖 2022-12-31 下午2.59.16.jpg” could not be found.<br>d是最大值位數個數
r是bucket數量
複製<br>分析<br>
<br>
Time Complexity: O(d*(n+r))<br>
說明：要執行d回合<br>
每回合：

<br>分派O(n)
<br>合併O(r)

-&gt;每回合O(n+r)故total = O(d(r+n))<br>
基底r可視為常數c1，因為值域受限d也可視為常數c2<br>
-&gt; O(c2*(n+c1)) -&gt; O(n)

<br>
Space Complexity:O(r* n)<br>
-&gt;額外空間需求=Bucket's total size<br>
-&gt;要準備r個Buckets, 每個Bucket's size = n

]]></description><link>考研筆記/資料結構/ch7-search-and-sort/lsd-radix-sort.html</link><guid isPermaLink="false">考研筆記/資料結構/CH7 Search and Sort/LSD Radix Sort.md</guid><pubDate>Wed, 13 Mar 2024 09:23:45 GMT</pubDate></item><item><title><![CDATA[Merge Sort]]></title><description><![CDATA[<a class="tag" href="?query=tag:stable" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#stable</a> 
 <br><br><a href=".?query=tag:stable" class="tag" target="_blank" rel="noopener">#stable</a><br>複製<br>常用於"External sorting"<br>
術語<br>
<br>Run :排序好的片段串列
<br>Run的長度：Run中之Data個數
<br>k-way merge(k&gt;=2)<br>
一次是合併k個Runs成一個Run
<br><br><br>考計算題<br>
(以2-way為例)<br>
<img alt="../img/截圖 2022-10-24 下午3.40.17.jpg" src="/lib/media/截圖-2022-10-24-下午3.40.17.jpg" style="width: 300px; max-width: 100%;"><br>
合併2個Runs的algo<br>while(Run1和Run2尚未掃描完){
	//小的先放入新的陣列
	if(p.data &lt;= q.data){
		output p.data to New Run
		p = p+1;
	}else{
		output q.data to New Run
		q = q+1;
	}
}
while(Run1尚未掃描完){
	copy Run1 剩下的到New Run
}
while(Run2尚未掃描完){
	copy Run2 剩下的到New Run
}
複製<br>分析<br>
合併Run1, Run2<br>
Run1 長度=n<br>
Run2 長度=m<br>
<br>最少比較次數= n or m<br>
（若某個Run之Data均比另一個Run的Data 小/大）A全部比B的大or小
<br>最多比較次數= n+m-1<br>
（有1個Run scan over，另一個只剩一個資料）全部都比對到，除了最後一個
<br>如果Run1, Run2長度皆為n，比較次數-&gt;O(n)。每回合(層)花O(n)合併<br>Tree高度為⎡log₂n⎤+1，而合併的層數是 高度-1 -&gt;⎡log₂n⎤<br>Merge Sort Time = ⎡log₂n⎤回合* O(n)time -&gt; O(nlogn)<br><br><br>(以2-way merge 為例)<br>採取<a class="internal-link" data-href="../../演算法/CH2 Divide-and-Conquer/CH2 Divide-and-Conquer.md" href="/考研筆記/演算法/ch2-divide-and-conquer/ch2-divide-and-conquer.html" target="_self" rel="noopener">Divide-and-Conquer</a>策略<br>steps<br>
<br>一律將list分成2等份之sublists。對半切O(1)
<br>左右各半自merge sort，得到左右半(Run1, Run2) 2T(n/2)
<br>合併左右Runs成為一個RunO(n)
<br>Algo.<br>
排序x[l]~x[u]，結果Run: p<br>RMSort(x, l, u, p){
	if(l &gt;= u)p = l;
	else{
		mid = (l+u)/2;
		RMSort(x, l, mid, Q);
		//排序左半得到Run Q
		RMSort(x, mid+1, u, R);
		MergeTwoRuns(Q, R, p);
	}
}
複製<br>分析<br>
<br>Time Complexity: Avg./Best/worst case 皆O(nlogn)<br>
T(n) = 2T(n/2)+cn
<br>Space Complexity:O(n)<br>
額外空間來自於必須保持每一回合之合併排序結果-&gt;需要O(n)的空間
<br><br>k-way merge on m個Runs,資料總數=n，Time=O(nlog m)與k無關，證明之“../img/截圖 2022-10-24 下午7.58.48.jpg” could not be found.<br>
每個Runs的資料數= n/m，每次合併k個Runs成一個Run(假設有用<a class="internal-link" data-href="Selection Tree.md" href="/考研筆記/資料結構/ch7-search-and-sort/selection-tree.html" target="_self" rel="noopener">Selection Tree</a>加速)<br>
-&gt; 每次合併花O(kn/mlog₂k)
有m/k組k-way merge<br>
每一回合(層）之時間<br>
= m/k  O(kn/m*log₂k)<br>
= O(nlog₂k)
高度 = ⎡logk m⎤+1<br>
回合數 = 高度-1 = ⎡logk m⎤<br>
而要做⎡logk m⎤回合完成排序
Total Time<br>
~= logkm*O(nlog₂k)<br>
= O(nlogkm*log₂k)<br>
= O(nlog₂m)]]></description><link>考研筆記/資料結構/ch7-search-and-sort/merge-sort.html</link><guid isPermaLink="false">考研筆記/資料結構/CH7 Search and Sort/Merge Sort.md</guid><pubDate>Wed, 13 Mar 2024 09:25:50 GMT</pubDate><enclosure url="lib/media/截圖-2022-10-24-下午3.40.17.jpg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib/media/截圖-2022-10-24-下午3.40.17.jpg&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[MSD Radix Sort]]></title><description><![CDATA[<a class="tag" href="?query=tag:⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️</a> 
 <br><a href=".?query=tag:⭐️" class="tag" target="_blank" rel="noopener">#⭐️</a><br>steps:<br>
<br>將n個Data一最高位數進行分派到對應的Bucket中
<br>每個Bucket 自行排序
<br>合併
<br>與<a class="internal-link" data-href="LSD Radix Sort.md" href="/考研筆記/資料結構/ch7-search-and-sort/lsd-radix-sort.html" target="_self" rel="noopener">LSD</a>最大不同在於MSD的分派＆合併動作只做1次而已<br>每個Bucket內的data數目 = n/r<br>
大家都一樣的data數目-&gt;可視為常數 c<br>
所以每個Bucket各自排序之時間 = O(c²) or O(clogc) -&gt; O(1)<br>r個 buckets sort time = r * O(1) = O(r)<br><br><br>(就是MSD Radix Sort)<br>基底十進制。給78, 17, 39, 26, 72, 94, 21, 12, 23, 68實施Ans:<br>
最大值位數2位，所以個Data先除以10² = r² （或是用mod取十位數）<br>
得：<br>
0.78, 0.17, 0.39, 0.26, 0.72, 0.94, 0.21, 0.12, 0.23, 0.68<br>
依照小數點後第一位數進行分派到Bucket去，每個Bucket各自實施<a class="internal-link" data-href="Insertion sort.md" href="/考研筆記/資料結構/ch7-search-and-sort/insertion-sort.html" target="_self" rel="noopener">Insertion sort</a><br>
“../img/截圖 2022-10-25 下午6.19.38.jpg” could not be found.]]></description><link>考研筆記/資料結構/ch7-search-and-sort/msd-radix-sort.html</link><guid isPermaLink="false">考研筆記/資料結構/CH7 Search and Sort/MSD Radix Sort.md</guid><pubDate>Wed, 13 Mar 2024 09:23:49 GMT</pubDate></item><item><title><![CDATA[Quick Sort]]></title><description><![CDATA[ 
 <br>Example“../../img/截圖 2022-12-24 下午6.01.02.jpg” could not be found.<br><br>平均case下 actual exec. Time最快速<br>
採用"<a class="internal-link" data-href="../../演算法/CH2 Divide-and-Conquer/CH2 Divide-and-Conquer.md" href="/考研筆記/演算法/ch2-divide-and-conquer/ch2-divide-and-conquer.html" target="_self" rel="noopener">CH2 Divide-and-Conquer</a>"策略<br>
觀念：<br>
排序A[l]~A[u]<br>
假設A[l]為pivot key(p.k)，經過partition後，即將pk放到“正確的”位置上，令為'q'<br>
{q左邊的} &lt; q &lt; {q右邊的}<br>
核心:Partition
<br>Algo<br>
KEY:i從左邊往右(-&gt;)，j從右邊往左(&lt;-)。<br>
先找A[j] &lt;= pk, 再找A[i] &gt;= pk ，然後swap<br>
中途交會就Swap(A[j], p.k)。<br>
end
<br>26, 5, 37, 1, 61, 11, 59, 15, 48, 19“../img/截圖 2022-10-20 下午5.05.06.jpg” could not be found.<br>write down the result of Pass 1 of Quick Sort
<br>5, 8, 9, 1, 4, 7, 2, 3, 6<br>
“../img/截圖 2022-10-20 下午5.11.11.jpg” could not be found.
<br>1, 2, 3, 4, 5<br>
“../img/截圖 2022-10-20 下午5.11.29.jpg” could not be found.
<br>5, 4, 3, 2, 1, 無限<br>
“../img/截圖 2022-10-20 下午5.11.43.jpg” could not be found.
<br>5*, 5, 5, 5, 5<br>
“../img/截圖 2022-10-20 下午5.12.01.jpg” could not be found.
<br>Time Complexity分析：O(nlogn)<br>
<br>Avg. Case:<br>
說明：{s個元素} pk {n-s個元素}，s = 1~n<br>
<img alt="../img/截圖 2022-10-20 下午5.24.33.jpg" src="/lib/media/截圖-2022-10-20-下午5.24.33.jpg" style="width: 400px; max-width: 100%;"><br>
-&gt; nT(n) - (n-1)T(n-1) = 2T(n-1)+T(n)-T(n-1)+c(n²-(n-1)²)<br>
-&gt; nT(n)- nT(n-1)+ T(n-1)= T(n-1)+ T(n)+ c(2n-1)<br>
-&gt; (n-1)T(n) = nT(n-1)+ c(2n-1)<br>
-&gt; T(n)/n = T(n-1)/(n-1)+ c/n+ c/n-1<br>
--&gt; T(n) = T(1) / 1 + c(1/2+ 1/3+ ... + 1/n) + c(1/1+ 1/2+ ... + 1/(n-1))<br>
--&gt; T(n) = c(Hn -1) + c(Hn - 1/n)<br>
--&gt; T(n) = 2 c n Hn -cn -c<br>
--&gt; T(n) ~= 2 c n logn - cn - c &lt;=2 c n log n &lt;= O(nlogn)
<br>Worst Case:<br>
遇到pivot key剛好是最小-&gt;沒有分割的效果<br>
遇到已排序的input -&gt; 使用隨機(or midddle-fo three or mediam-of-mediam)取pivot key
<br>Best Case:<br>
5, 5, 5, 5, 5*（切割一半）
<br>空間複雜度<br>
<br>位於 O(log n) ~ O(n) 之間。額外空間需求來自於遞迴所需的 Stack 空間，而 Stack Size 取決於 Recursive Call 的次數。
<br><br>QuickSort(A, p, r){
//排序A[p] ~ A[r]
	if(p&lt;r){
		q = Partition(A, p, r);//傳回pk的正確位置給q
		//遞迴左右半
		Quicksort(A, p, q-1);
		Quicksort(A, q+1, r);
	}
}
Partition(A, p, r){
	x = A[r];
	//i, j都從左邊出發，但是i只有在交換前回右移。
	//key:i是紀錄左半的最右index
	i = p-1;
	for j = p to (r-1){
		if(A[j] &lt;= x){
			i = i+1;
			Swap(A[i], A[j]);
		}
	}
	Swap(A[i+1], A[r]);
	return (i+1);
}
複製<br><img alt="../img/截圖 2022-10-24 下午2.43.42.jpg" src="/lib/media/截圖-2022-10-24-下午2.43.42.jpg" style="width: 300px; max-width: 100%;"><br>遇到相同key值會使效益變差。使用Hoare partition解決<br>分析<br>
<br>Worst Case O(n²): 5, 5, 5, 5, 5*（沒有切割效果）

<br>解法1. 先花O(n) Time check 是否所有elements are equal，若是，則可exits，否則才做Qsort。
<br>解法2. 改用[Hoare] partition


<br>Randomized Quick sort's worst case still O(n²)]]></description><link>考研筆記/資料結構/ch7-search-and-sort/quick-sort.html</link><guid isPermaLink="false">考研筆記/資料結構/CH7 Search and Sort/Quick Sort.md</guid><pubDate>Wed, 13 Mar 2024 09:25:50 GMT</pubDate><enclosure url="lib/media/截圖-2022-10-20-下午5.24.33.jpg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib/media/截圖-2022-10-20-下午5.24.33.jpg&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Radix Sort]]></title><description><![CDATA[<a class="tag" href="?query=tag:DS版" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#DS版</a> <a class="tag" href="?query=tag:⭐️⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️⭐️</a> <a class="tag" href="?query=tag:⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️</a> 
 <br><br>如果已知data的value範圍且已知data個數，很大機率是用Radix Sort<br><a href=".?query=tag:DS版" class="tag" target="_blank" rel="noopener">#DS版</a><br>
定義：又叫Bucket Sort<br>
採取"Distribution and Merge"之排序技巧<br>
分成：

<br><a class="internal-link" data-href="LSD Radix Sort.md" href="/考研筆記/資料結構/ch7-search-and-sort/lsd-radix-sort.html" target="_self" rel="noopener">LSD Radix Sort</a> <a href=".?query=tag:⭐️⭐️⭐️⭐️" class="tag" target="_blank" rel="noopener">#⭐️⭐️⭐️⭐️</a>  考計算題
<br><a class="internal-link" data-href="MSD Radix Sort.md" href="/考研筆記/資料結構/ch7-search-and-sort/msd-radix-sort.html" target="_self" rel="noopener">MSD Radix Sort</a> <a href=".?query=tag:⭐️" class="tag" target="_blank" rel="noopener">#⭐️</a>

]]></description><link>考研筆記/資料結構/ch7-search-and-sort/radix-sort.html</link><guid isPermaLink="false">考研筆記/資料結構/CH7 Search and Sort/Radix Sort.md</guid><pubDate>Wed, 13 Mar 2024 09:25:58 GMT</pubDate></item><item><title><![CDATA[Selection sort]]></title><description><![CDATA[<a class="tag" href="?query=tag:unstable" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#unstable</a> 
 <br><br><a href=".?query=tag:unstable" class="tag" target="_blank" rel="noopener">#unstable</a><br>
觀念：<br>
自第i~n筆資料找出最小值:A[m]<br>
然後swap(A[i], A[m])
eg: input 3, 3*,  2
降低swap 次數
<br>Algo <br>SelectionSort(A, n){
	for i = 1 to n-1 do{
		min = i;
		for j  = i+1 to n do{//找後面(剩餘的)最小值，並保存index
			if(A[j] &lt; A[min])
				min = j
		} 
		if(min != j)
			swap(A[min], A[i])
	}
}
複製<br>分析 Time Complexity: Best/Worst/Avg.皆為O(n²)<br>
一psudo Code中 A[j] &lt; A[min]中比較次數<br>
共為 =(n-1)+(n-2)+...+1 = (n(n-1))/2次<br>
-&gt; O(n²)<br>Space Complexity -&gt; O(1)<br>
min變數、swap函式中的temp變數。<br>其他討論：<br>
Selection Sort適用於“大型紀錄”（紀錄由很多欄位組成）排序<br>
insertion sort搬移的成本較高，selection sort 只需紀錄欄位位置，成本較低<br>if(min != i)是否省略<br>
<br>省略：多出不必要的自己對自己交換-&gt;適合大多數都不落在正確位置的
<br>不省略：
]]></description><link>考研筆記/資料結構/ch7-search-and-sort/selection-sort.html</link><guid isPermaLink="false">考研筆記/資料結構/CH7 Search and Sort/Selection sort.md</guid><pubDate>Wed, 13 Mar 2024 09:23:49 GMT</pubDate></item><item><title><![CDATA[Selection Tree]]></title><description><![CDATA[ 
 <br><br>
目的：加速k-way merge 之過程(k&gt;2)<br>
如何合併k個Runs?
<br><br>Time 分析<br>
<br>建立Winner Tree<img alt="../img/截圖 2022-10-24 下午5.11.04.jpg" src="/lib/media/截圖-2022-10-24-下午5.11.04.jpg" style="width: 300px; max-width: 100%;">

<br>將k個Run中最小Data copy as a leaf -&gt; O(n)time
<br>歷經k-1次的比較決定出Root -&gt;O(k)


<br>輸出Root的資料到New Run，並從其所屬的run補上資料(到tree裏)
<br>重新排Tree。經過⎡log₂k⎤次比較決定出下一個Root
比較次數= selection tree 高度-1，若有k個Leaves。
高度 = ⎡log₂k⎤+1
比較次數 = 高度-1 = ⎡log₂k⎤
複製

<br>依此，共要做n-2回合挑Root之動作
<br>-&gt; O(n logk)<br>比傳統的O(nk)快<br><br>同上<br>
<br>建立Loser Tree<img alt="../img/截圖 2022-10-24 下午5.31.22.jpg" src="/lib/media/截圖-2022-10-24-下午5.31.22.jpg" style="width: 300px; max-width: 100%;">（圖中winner是2）

<br>將k個Run中最小Data copy as a leaf -&gt; O(n)time
<br>歷經k-1次的比較(比贏家、填輸家）決定出Root -&gt;O(k)


<br>輸出Winner的資料到New Run，並從其所屬的run補上資料(到tree裏)
<br>重新排Tree。<img alt="../img/截圖 2022-10-24 下午5.35.56.jpg" src="/lib/media/截圖-2022-10-24-下午5.35.56.jpg" style="width: 300px; max-width: 100%;">經過⎡log₂k⎤次比較決定出下一個Root&amp;Winner
<br>Time complexity: 同winner tree O(n logk)<br><br>
Loser is BETTER<br>
比較的過程較為輕鬆（參與比較的Node數較少）
]]></description><link>考研筆記/資料結構/ch7-search-and-sort/selection-tree.html</link><guid isPermaLink="false">考研筆記/資料結構/CH7 Search and Sort/Selection Tree.md</guid><pubDate>Wed, 13 Mar 2024 09:23:52 GMT</pubDate><enclosure url="lib/media/截圖-2022-10-24-下午5.11.04.jpg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib/media/截圖-2022-10-24-下午5.11.04.jpg&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Shell sort]]></title><description><![CDATA[<a class="tag" href="?query=tag:unstable" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#unstable</a> 
 <br><br><a href=".?query=tag:unstable" class="tag" target="_blank" rel="noopener">#unstable</a> <br>
定義：

<br>
每一回合, i = 1 to (n-span)比較A[i]&amp; A[i+span]，若前者&gt;後者，則Swap(A[i], A[i+span])

<br>
每一回合需持續執行到No Swap發生，才可進入下一回合

<br>
回合數目由span型式決定

<br>n/2^k型(span = n/2, n/4, n/8, ...)
<br>2^k -1型(span = 15, 7, 3, 1)
<br>其他
<br>自定型(eg. span = 5, 3, 1)

Unstable


<br>效果<br>
若某回合span值= k，則代表有k調sublists要排序好，每條sublist 之Data量 ~= n/k<br>例：給予10, 13, 15, 2, 7, 6, 4, 12, 18, 3。span採⎡n/2^k⎤型，實施shell sort“../img/截圖 2022-10-20 下午4.09.20.jpg” could not be found.<br>Algo<br>ShellSort(A, n){
	//排序A[1]~A[n]
	//span採n/2^k型
	span = n/2;
	while(span &gt; 1){
		do{
			flag = 0;
			for i to (n-span){
				if(A[i] &gt; A[i+span]){
					Swap(A[i], A[i+span]);
					flag = 1;
				}
			}
		}until(flag == 0)
		span = span/2;
	}
} 
複製<br>Time Complexity: O(n²)]]></description><link>考研筆記/資料結構/ch7-search-and-sort/shell-sort.html</link><guid isPermaLink="false">考研筆記/資料結構/CH7 Search and Sort/Shell sort.md</guid><pubDate>Wed, 13 Mar 2024 09:26:02 GMT</pubDate></item><item><title><![CDATA[除法Division or Mod]]></title><description><![CDATA[ 
 <br>除法Division or Mod<br>
H(x) = x mod M, 其中M的選擇宜是：

<br>M是質數
<br>R^k +/- a不宜整除M

]]></description><link>考研筆記/資料結構/ch8-hashing/除法division-or-mod.html</link><guid isPermaLink="false">考研筆記/資料結構/CH8 Hashing/除法Division or Mod.md</guid><pubDate>Wed, 13 Mar 2024 09:28:14 GMT</pubDate></item><item><title><![CDATA[CH8 Hashing]]></title><description><![CDATA[<a class="tag" href="?query=tag:⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️</a> <a class="tag" href="?query=tag:⭐️⭐️⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️⭐️⭐️</a> 
 <br>複製<br><br><br>
定義：是一種data儲存與搜尋之機制，欲存取資料時，需先經過Hashing function 計算，求出Hash address，依此位址到Hash Table中對應的Bucket 存入或找出資料x
而Hash Table 結構主要是由B個Buckets組成，每個在由S個slots（槽）組成，每個slot可存一筆Data<br>
Hash table size = B * S<br>
<img alt="../img/截圖 2022-10-26 下午2.35.23.jpg" src="/lib/media/截圖-2022-10-26-下午2.35.23.jpg" style="width: 300px; max-width: 100%;">
<br><br>
<br>Idenetifier density(識別字密度):n/T &amp; Loading density(負載密度):n/(B*S) = 𝞪<br>
𝞪越高Table利用度越高，但相對collision也多


<br>T為identifier總數
<br>n為目前用到的identifier個數
<br>B * S 為hash table size



<br>collision(碰撞)

不同的data，經由hashing function計算後，得出相同的hash address，謂知碰撞


<br>overflow(溢位)

當collision發生且對應的Bucket中無空間可存，稱之。
Note
<br>有collision，不一定會overflow
<br>有overflow，必定有collision
<br>若每一個Bucket只有一個slot，則collision = overflow



<br><br>
<br>以searching 而言，data不需事先排序，且若每有collision下，search for xi之time = O(1)，與資料量n無關。
<br>保密性高，若不知Hashing function，則無法取得資料。
<br>可做資料壓縮、密碼學、Block-chain等應用。
<br><br>一個良好的Hashing function Design，宜滿足：<br>
<br>計算宜簡單
<br>collision宜少
<br>不要造成Hash Table局部儲存之情況（分布均勻）
<br>名詞：<br>
<br>Perfect Hashing function:此函數保證不會發生collision
<br>Uniform Hashing function:此函數保證每個Bucket內Data數約莫相等(~= n/B)
<br>
<br><br><a href=".?query=tag:⭐️" class="tag" target="_blank" rel="noopener">#⭐️</a><br><br>（四種）<br>
<br><a class="internal-link" data-href="middle square.md" href="/考研筆記/資料結構/ch8-hashing/middle-square.html" target="_self" rel="noopener">middle square</a>
<br><a class="internal-link" data-href="除法Division or Mod.md" href="/考研筆記/資料結構/ch8-hashing/除法division-or-mod.html" target="_self" rel="noopener">除法Division or Mod</a>
<br><a class="internal-link" data-href="Folding Addition.md" href="/考研筆記/資料結構/ch8-hashing/folding-addition.html" target="_self" rel="noopener">Folding Addition</a>
<br><a class="internal-link" data-href="Digits Analysis.md" href="/考研筆記/資料結構/ch8-hashing/digits-analysis.html" target="_self" rel="noopener">Digits Analysis</a>
<br><br><a href=".?query=tag:⭐️⭐️⭐️⭐️⭐️" class="tag" target="_blank" rel="noopener">#⭐️⭐️⭐️⭐️⭐️</a><br><br>線性探測<br>
當H(x)發生overflow，則探測(H(x)+i)%B Bucket，其中B是Bucket數目(i = 1~B-1)，直到有空的Bucket或表格全滿。
<br>Example例：hash function: H(x)= x%10 採取linear probing處理overflow，今有下列Data依序存入empty Hash Table(Hash Table有10個，每個Bucket只有1個slot)<br>
Data = 33, 13, 19, 23, 15, 10, 29, 25<br>
求table內容？找23, 15個字需比較幾次才能找到？

“../img/截圖 2022-10-26 下午4.00.13.jpg” could not be found.<br>分析<br>
<br>優點:

<br>simple
<br>保證table空間可以充分利用


<br>缺點:

<br>容易形成<a class="internal-link" data-href="Primary clustering.md" href="/考研筆記/資料結構/ch8-hashing/primary-clustering.html" target="_self" rel="noopener">Primary clustering</a> 現象，造成平均searching x時間大幅增加之不良效應


<br><br>(二次方探測)<br>
當H(x)發生overflow，則探測(H(x)± i²)Bucket  (i = 1~B/2)，直到有空的Bucket or 探測的都滿了。
<br>Example例：hash function: H(x)= x%10 Quadratic probing處理overflow，今有下列Data依序存入empty Hash Table(Hash Table有10個，每個Bucket只有1個slot)<br>
Data = 33, 13, 19, 23, 15, 10, 29, 25<br>
求table內容？

“../img/截圖 2022-10-26 下午4.00.56.jpg” could not be found.<br>分析<br>
<br>優點：<br>
解決<a class="internal-link" data-href="Primary clustering.md" href="/考研筆記/資料結構/ch8-hashing/primary-clustering.html" target="_self" rel="noopener">Primary clustering</a>問題
<br>缺點：

<br>表格空間不見得充分利用（有些探測不到）
<br>會有<a class="internal-link" data-href="Secondary clustering.md" href="/考研筆記/資料結構/ch8-hashing/secondary-clustering.html" target="_self" rel="noopener">Secondary clustering</a>問題，造成search time增加。


<br><br>
令H1為Hashing function，當H1(x)發生overflow，則探測(H1(x)+i*H2(x))%B，其中H2(x)函數在求探測距離/間隔 (i= 1,2,3...直到有空Bucket or 探測格子)<br>
此外H2之格式為(R-x%R)，R為質數(依題目為主)
<br>Example例：hash function: H1(x)= x%10, H2(x)=7-(x%7) Double Hashing處理overflow，今有下列Data依序存入empty Hash Table(Hash Table有10個，每個Bucket只有1個slot)<br>
Data = 33, 13, 19, 23, 15, 10, 29, 25<br>
求table內容？

“../img/截圖 2022-10-26 下午4.20.11.jpg” could not be found.<br>分析<br>
<br>優點：<br>
解決<a class="internal-link" data-href="Secondary clustering.md" href="/考研筆記/資料結構/ch8-hashing/secondary-clustering.html" target="_self" rel="noopener">Secondary clustering</a>以及<a class="internal-link" data-href="Primary clustering.md" href="/考研筆記/資料結構/ch8-hashing/primary-clustering.html" target="_self" rel="noopener">Primary clustering</a>問題
<br>缺點：<br>
不保證table空間可以充分利用
<br><br>
具有相同hashing adress之資料均放到同一個Bucket中，而Bucket內之Data是以link list串接<br>
是屬於"close" addressing mode<br>
(其他則是open)
<br>ExampleData = 33, 13, 19, 23, 15, 10, 29, 25<br>
求table內容？

“../img/截圖 2022-10-26 下午4.29.14.jpg” could not be found.<br>補充<br>
<img alt="../img/截圖 2022-10-26 下午4.46.00.jpg" src="/lib/media/截圖-2022-10-26-下午4.46.00.jpg" style="width: 40px; max-width: 100%;"><br><br>
提供一系列的Hashing function，使用Hi發生overflow，則改用Hi+1
]]></description><link>考研筆記/資料結構/ch8-hashing/ch8-hashing.html</link><guid isPermaLink="false">考研筆記/資料結構/CH8 Hashing/CH8 Hashing.md</guid><pubDate>Wed, 13 Mar 2024 09:46:54 GMT</pubDate><enclosure url="lib/media/截圖-2022-10-26-下午2.35.23.jpg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib/media/截圖-2022-10-26-下午2.35.23.jpg&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Digits Analysis]]></title><description><![CDATA[ 
 <br><br>
假設data事先已知，我們可以分析這些data的各個位數的值域分佈情況

<br>很分散：使用該位數
<br>很集中：不使用該位數

挑選之位數為Hash address
]]></description><link>考研筆記/資料結構/ch8-hashing/digits-analysis.html</link><guid isPermaLink="false">考研筆記/資料結構/CH8 Hashing/Digits Analysis.md</guid><pubDate>Wed, 13 Mar 2024 09:35:56 GMT</pubDate></item><item><title><![CDATA[Folding Addition]]></title><description><![CDATA[ 
 <br><br>
將資料值切割成n個相同長度的片段，再將這些片段加總得出Hash address
<br>
<br>shift 加總
<br>Boundary 相加（偶數片段反向）
<br><img alt="../img/截圖 2022-10-26 下午3.27.24.jpg" src="/lib/media/截圖-2022-10-26-下午3.27.24.jpg" style="width: 300px; max-width: 100%;">]]></description><link>考研筆記/資料結構/ch8-hashing/folding-addition.html</link><guid isPermaLink="false">考研筆記/資料結構/CH8 Hashing/Folding Addition.md</guid><pubDate>Wed, 13 Mar 2024 09:30:40 GMT</pubDate><enclosure url="lib/media/截圖-2022-10-26-下午3.27.24.jpg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib/media/截圖-2022-10-26-下午3.27.24.jpg&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[middle square]]></title><description><![CDATA[ 
 <br>middle square<br>
(平方值取中間位數)<br>
將資料值平方後，取中間適當位數作為Hash address.
Note
<br>不取最高（左邊）幾位數 -&gt; 變化太少
<br>不取右邊幾位數 -&gt; 具規律性、無啥變化、甚至有些對應不到

]]></description><link>考研筆記/資料結構/ch8-hashing/middle-square.html</link><guid isPermaLink="false">考研筆記/資料結構/CH8 Hashing/middle square.md</guid><pubDate>Wed, 13 Mar 2024 09:36:35 GMT</pubDate></item><item><title><![CDATA[Primary clustering]]></title><description><![CDATA[ 
 <br>
具有相同hash address之data極易存放在連續的Buckets中，形成群聚。
]]></description><link>考研筆記/資料結構/ch8-hashing/primary-clustering.html</link><guid isPermaLink="false">考研筆記/資料結構/CH8 Hashing/Primary clustering.md</guid><pubDate>Wed, 13 Mar 2024 09:26:02 GMT</pubDate></item><item><title><![CDATA[Secondary clustering]]></title><description><![CDATA[ 
 <br>
具有相同Hash address之資料，其探測方式皆相同，具有規律性。
]]></description><link>考研筆記/資料結構/ch8-hashing/secondary-clustering.html</link><guid isPermaLink="false">考研筆記/資料結構/CH8 Hashing/Secondary clustering.md</guid><pubDate>Wed, 13 Mar 2024 09:24:52 GMT</pubDate></item><item><title><![CDATA[AVL Tree]]></title><description><![CDATA[<a class="tag" href="?query=tag:⭐️⭐️⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️⭐️⭐️</a> <a class="tag" href="?query=tag:balancedBST之一" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#balancedBST之一</a> 
 <br><br><a href=".?query=tag:balancedBST之一" class="tag" target="_blank" rel="noopener">#balancedBST之一</a><br>
緣由：BST在面對"Dynamic Data Set(資料插入、刪除等異動頻繁)時。BST有可能形成skewed情況，造成Insert/Delete/search x之time變成O(n)之worst case，故需要有一種BST可以動態維持高度最小化，使得上述運作在worst cas下任為O(logn)，此即AVL Tree的目的
<br>
定義：是一種高度平衡化的BST<br>
滿足： 任意節點的左右子樹差&lt;= 1

<br>|HL - HR| &lt;= 1, HL, HR是Root左右子數的高度
<br>Root之左右子樹也是AVL Tree

<br>定義：<br>
<br>Node的平衡係數(Balance Factor) = Node左子樹高 - Node右子樹高度
<br>In AVL Tree，任何一個點的B.F值只有 -1, 0 , +1 , 3種
<br>AVL Tree之不平衡狀況分成：LL, LR, RL, RR四種。判斷原則：<br>
<br>Insert 新點後，看哪一個離新點最近的Node(往上找)變成不平衡且新點 在此 不平衡點 之"什麼子樹"方向分出
<br>AVL Tree不平衡之調整(rotation)<br>
兩大原則: 依照BST的大小放就對了<br>
<br>中間鍵值往上拉，小放左，大放右（LL, LR, RL, RR連到的三個node）
<br>孤兒之Node or子樹一BST結構，即可置入正確位置。
<br><img alt="../img/截圖 2022-10-13 下午9.19.26.jpg" src="/lib/media/截圖-2022-10-13-下午9.19.26.jpg" style="width: 200px; max-width: 100%;"><br>
<img alt="../img/截圖 2022-10-13 下午9.19.38.jpg" src="/lib/media/截圖-2022-10-13-下午9.19.38.jpg" style="width: 200px; max-width: 100%;"><br><img alt="../img/截圖 2022-10-14 下午2.21.21.jpg" src="/lib/media/截圖-2022-10-14-下午2.21.21.jpg" style="width: 300px; max-width: 100%;"><br><br>（令Root level = 1）形成高度h之AVL Tree，所需之最小Node數=F(h+2)-1<br>Note:Node數≤ 2^h -1=Full BST<br>
Note:Node數≧F(h+2)-1<br>Space Complexity : O(n)<br>
Insert Complexity : O(logn)<br><img src="/lib/media/截圖-2023-01-31-下午4.17.43.jpg"><br>
<img src="/lib/media/截圖-2023-01-31-下午4.27.45.jpg"><br>
！！1/c在log裏面<br>數學歸納法證明最少Node數= F(h+2)-1
<br>當高度 = 0，empty。F(0+2)-1 = 0
<br>令高度 &lt;= h-1時定理成立。
<br>當高度= h時，要最少Node數必定發生在左右子樹高度差1的情況。

不失一般性，令左子數高 = h-1，右h-2<br>
F(h-1+2)-1 = F(h+1)-1<br>
F(h-2+2)-1 = F(h)-1<br>
整棵樹的最少Node樹 = (F(h+1)-1)+ (F(h)-1) +1<br>
=&gt;F(h+2)-1<br>形成高度5之AVL Tree所需最少節點數？(並畫Tree)。所需最多節點數？(並畫Tree)F(h+2)-1 = 12<br>
讓每個非leaf的Node 的左右子數高度差一即可<br>
“../img/截圖 2022-10-14 下午3.13.37.jpg” could not be found.<br>AVL Tree Node數=200。求最小高度？最大高度？2^h -1 = 200<br>
h = ⎡log 200+1⎤ = 8

F(h+2)-1求出在高度h下最少Node數。<br>
h=10時透過F(h+2)-1可得&gt;143個Node<br>
h=11時透過F(h+2)-1可得232<br>
所以200個node最高只能建成h=10的Tree<br>令Nh代表形成高度H之AVL Tree的最少Node數。(1)write the recursive definition of Nh 。(2)Based on (1)求出N5=?Key:最少Node數必定發生在左右子樹高度差1的情況<br>
“../../img/截圖 2022-12-31 下午3.35.44.jpg” could not be found.<br>
N(h) = N(h-1) + N(h-2) + 1

類似費氏數列<br>
ANS = 12]]></description><link>考研筆記/資料結構/ch9-advanced-tree/avl-tree.html</link><guid isPermaLink="false">考研筆記/資料結構/CH9 Advanced Tree/AVL Tree.md</guid><pubDate>Wed, 13 Mar 2024 09:36:20 GMT</pubDate><enclosure url="lib/media/截圖-2022-10-13-下午9.19.26.jpg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib/media/截圖-2022-10-13-下午9.19.26.jpg&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[B-Tree with minimum degree t]]></title><description><![CDATA[ 
 <br>等同於<a class="internal-link" data-href="Binary Tree of order m.md" href="/考研筆記/資料結構/ch9-advanced-tree/binary-tree-of-order-m.html" target="_self" rel="noopener">Binary Tree of order 2t</a><br>B-Tree 具備如下特性：<br>

<br>每一棵 B-Tree 都需要在建立前指定好 Minimal Degree ，&nbsp;t&nbsp;。
<br>樹上的每個節點內存放最少&nbsp;t-1&nbsp;個 keys ，最多&nbsp;2t-1&nbsp;個 Keys。
<br>Root Node 較為特殊，允許存放最少&nbsp;1&nbsp;個 Key ，最多&nbsp;2t-1&nbsp;個 Keys。
<br>每個節點當下擁有的子節點數為&nbsp;節點當下擁有的 key 數 + 1
<br>每個節點上的 Keys 都是以升序（ Increasing Order ）排列，相隔的兩 Key ，K1、&nbsp;K2&nbsp;，之間的任一子節點上的任一 Key ，其值必落在&nbsp;K1&nbsp;-&nbsp;K2之間。
<br>所有葉節點 （Leaf Node ）的深度（ Depth ）必定相同。

<br>高度h時，最大node數為(2t)^h +1]]></description><link>考研筆記/資料結構/ch9-advanced-tree/b-tree-with-minimum-degree-t.html</link><guid isPermaLink="false">考研筆記/資料結構/CH9 Advanced Tree/B-Tree with minimum degree t.md</guid><pubDate>Wed, 13 Mar 2024 09:17:54 GMT</pubDate></item><item><title><![CDATA[Binary Tree of order m]]></title><description><![CDATA[<a class="tag" href="?query=tag:⭐️⭐️⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️⭐️⭐️</a> 
 <br><br>
定義：是一顆Balanced m-way search Tree，主要用於<a class="internal-link" data-href="../CH9 Advanced Tree/external search or sort.md" href="/考研筆記/資料結構/ch9-advanced-tree/external-search-or-sort.html" target="_self" rel="noopener">External search/sort</a><br>
若不為空，則滿足

<br>Root至少有&gt;=2個子點，即2&lt;= Root's Degree &lt;= m
<br>扣除Root即Failure Node之外，其餘Node's Degree 介於⎡m/2⎤與m之間。即⎡m/2⎤&lt;= Node's Degree &lt;= m
<br>所有的failure nodes 皆位於同一level 此即為"balanced" 之意

<br><img alt="../img/截圖 2022-10-14 下午4.30.33.jpg" src="/lib/media/截圖-2022-10-14-下午4.30.33.jpg" style="width: 400px; max-width: 100%;"><br>
<img alt="../img/截圖 2022-10-14 下午4.35.48.jpg" src="/lib/media/截圖-2022-10-14-下午4.35.48.jpg" style="width: 400px; max-width: 100%;"><br>計算高度為h的B-tree of order m，求(1)最多Node數(2)最多Key數(3)最少Node數(4)最少key數m^0+m^2+...= (m^h-1)/(m-1)

m^h -1

“../img/截圖 2022-10-14 下午4.40.18.jpg” could not be found.

= 1 + {最少node數(不包含Root)}*(⎡m/2⎤-1)<br>
= 2*⎡m/2⎤^(h-1) -1<br>B tree of order 3 with n個 Data/key，求(1)最小高度(2)最大高度<br>Insert x<br>
<br>search for x, 找出適當置入Node並將x置入 置入後再做檢查
<br>check if Node overflow

<br>沒有overflow，放入，結束～
<br>有overflow，需要做"split"處理，且針對父節點goto step2.(往上檢查)


<br>
split處理：把中間(⎡m/2⎤)的key拉到父親，左半和右半各自成Node
<br>給予2,3,5,7,1,8,4,6,9，建立2-3Tree<br>Delete x<br>
<br>search for x, 找出位於哪個Node
<br>分為兩大情況

<br>x位於Leaf：

<br>刪x
<br>check Node是否underflow（key數&lt;⎡m/2⎤-1） 是否破產

<br>沒有underflow（沒破產），結束～
<br>有underflow，先看能否用"Rotation"(跟兄弟借錢)處理 -&gt;結束。若不可(兄弟可能也沒錢)，則"conbine"，然後回到ii.檢查父點。若一直到root也破產就移除root。




<br>x位於Non-Leaf

<br>刪x
<br>左子樹最大or 右子樹最小 作為y，將y自leaf中刪掉並取代x，所以leaf少一個key=&gt;回到a.處理




<br>
Rotation：跟兄弟借（兄弟給爸，爸給自己）<br>
Combine：跟爸爸要錢，並且和兄弟合併
<br>解題技巧：父破產，先移除該下面level的所有撫養關係，往上同理，直到平衡後在連起來。<br>綜合T or F(1)若BST之Root的左右子樹是<a class="internal-link" data-href="CH9 Advanced Tree.md##AVL Tree" href="/考研筆記/資料結構/ch9-advanced-tree/ch9-advanced-tree.html#" target="_self" rel="noopener">AVL Tree</a>, 則此BST也是<a class="internal-link" data-href="AVL Tree.md" href="/考研筆記/資料結構/ch9-advanced-tree/avl-tree.html" target="_self" rel="noopener">AVL Tree</a><br>
F<br>
(2)B tree of order m 之insert &amp; delete x動作時間為O(logn)<br>
T<br>
(3)In <a class="internal-link" data-href="AVL Tree.md" href="/考研筆記/資料結構/ch9-advanced-tree/avl-tree.html" target="_self" rel="noopener">AVL Tree</a>，任何Leaf之level值之差值皆&lt;= 1<br>
F<br>
(4)<a class="internal-link" data-href="AVL Tree.md" href="/考研筆記/資料結構/ch9-advanced-tree/avl-tree.html" target="_self" rel="noopener">AVL Tree</a> 之inset x, Delete x, search for x 之worst case Time 皆O(logn)<br>
T<br>
(5)<a class="internal-link" data-href="AVL Tree.md" href="/考研筆記/資料結構/ch9-advanced-tree/avl-tree.html" target="_self" rel="noopener">AVL Tree</a> Inset x時，最多發生1 種rotation<br>
T (因為rotation完就結束了)<br>
(6)<a class="internal-link" data-href="AVL Tree.md" href="/考研筆記/資料結構/ch9-advanced-tree/avl-tree.html" target="_self" rel="noopener">AVL Tree</a> 使用Postorder traversal 可得到 大-&gt;小 order<br>
F<br>
(7)<a class="internal-link" data-href="AVL Tree.md" href="/考研筆記/資料結構/ch9-advanced-tree/avl-tree.html" target="_self" rel="noopener">AVL Tree</a>及B Tree 皆是Balanced search Tree<br>
T]]></description><link>考研筆記/資料結構/ch9-advanced-tree/binary-tree-of-order-m.html</link><guid isPermaLink="false">考研筆記/資料結構/CH9 Advanced Tree/Binary Tree of order m.md</guid><pubDate>Wed, 13 Mar 2024 09:20:50 GMT</pubDate><enclosure url="lib/media/截圖-2022-10-14-下午4.30.33.jpg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib/media/截圖-2022-10-14-下午4.30.33.jpg&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Binary+ Tree of order m]]></title><description><![CDATA[<a class="tag" href="?query=tag:⭐️⭐️⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️⭐️⭐️</a> 
 <br>Binary+ Tree of order m <a href=".?query=tag:⭐️⭐️⭐️⭐️⭐️" class="tag" target="_blank" rel="noopener">#⭐️⭐️⭐️⭐️⭐️</a><br>
定義：是B Tree之變種，主要支持 ISAM(Index Sequential Access Method) 方法，常用於DBMS之內層製作
分為兩大layer:

<br>Index Layer(索引)：採B Tree結構
<br>Data Block：以link list 串連，所有Data均放在Data Blocks(不一定要遵守B Tree數量)

<img alt="../img/截圖 2022-10-14 下午8.19.32.jpg" src="/lib/media/截圖-2022-10-14-下午8.19.32.jpg" style="width: 400px; max-width: 100%;">
<br>Insert x<br>
!!不能用B Tree的想法，不會有DATA往上移，只有往上Copy<br>
<br>search 正確Node並放入x
<br>兩狀況：

<br>是Leaf（在Data區域）。檢查overflow類似B Tree of order m，只是不能實際上移

<br>有overflow：中間COPY往上放，作為索引。&lt;⎡m/2⎤的為新的左Node，&gt;=⎡m/2⎤的為新的右Node，且針對父節點goto step2.(往上檢查，這部分就是存粹B Tree)
<br>沒overflow：結束




<br>不是Leaf：同<a class="internal-link" data-href="CH9 Advanced Tree.md##Binary Tree of order m" href="/考研筆記/資料結構/ch9-advanced-tree/ch9-advanced-tree.html#" target="_self" rel="noopener">B Tree of order m</a>
<br><img src="/lib/media/截圖-2022-10-14-下午8.39.08.jpg"><br>
Delete x 索引要一起刪<br><img src="/lib/media/截圖-2022-10-14-下午8.47.12.jpg"><br><img src="/lib/media/截圖-2022-10-14-下午8.47.30.jpg"><br>在Data Layer層的時候要注意不要做出奇怪的動作，該加的要留下，該刪的要刪掉。]]></description><link>考研筆記/資料結構/ch9-advanced-tree/binary+-tree-of-order-m.html</link><guid isPermaLink="false">考研筆記/資料結構/CH9 Advanced Tree/Binary+ Tree of order m.md</guid><pubDate>Wed, 13 Mar 2024 09:20:28 GMT</pubDate><enclosure url="lib/media/截圖-2022-10-14-下午8.19.32.jpg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib/media/截圖-2022-10-14-下午8.19.32.jpg&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Binomial Heap]]></title><description><![CDATA[ 
 <br>Binomial Heap<br>Binomial Forest<br>
定義：是由<a class="internal-link" data-href="Binomial Tree.md" href="/考研筆記/資料結構/ch9-advanced-tree/binomial-tree.html" target="_self" rel="noopener">Binomial Tree</a>一堆形成之集合(or forest)，且每一顆Tree也必須是min. Tree
<br>相關數學Binomial Heap有13個Data(nodes)<br>
是由 ? Binomial Tree組成。<br>
Ans: (13)十進制 -&gt; (1101)二進制 -&gt;B3, B2, B0組成

32個nodes =&gt; 一個B5

若n= 2^k -&gt;一顆Bk組成<br>
若n= (2^k) -1 -&gt; 由k顆組成]]></description><link>考研筆記/資料結構/ch9-advanced-tree/binomial-heap.html</link><guid isPermaLink="false">考研筆記/資料結構/CH9 Advanced Tree/Binomial Heap.md</guid><pubDate>Wed, 13 Mar 2024 09:25:23 GMT</pubDate></item><item><title><![CDATA[Binomial Tree]]></title><description><![CDATA[ 
 <br>Binomial Tree<br>
定義：

<br>高度為０之Binomial Tree記為B0，只有Root 1個點
<br>高度=k...記為Bk，是由兩顆Bk-1所合成。

<br><img alt="../img/截圖 2022-10-17 下午7.08.52.jpg" src="/lib/media/截圖-2022-10-17-下午7.08.52.jpg" style="width: 200px; max-width: 100%;"><br>相關數學(台大考過 <a href=".?query=tag:⭐️⭐️⭐️⭐️⭐️" class="tag" target="_blank" rel="noopener">#⭐️⭐️⭐️⭐️⭐️</a> )
<br>Bk 中第i level之Node樹 = C(k, i)<br>
pf(數學歸納法):<br>
Bk 第i層 = Bk-1中第i層 + Bk-1中第i-1層<br>
...
<br>Bk之Node總數 = 2^k<br>
pf:

<br>歸納法
<br>利用C(k, i)


]]></description><link>考研筆記/資料結構/ch9-advanced-tree/binomial-tree.html</link><guid isPermaLink="false">考研筆記/資料結構/CH9 Advanced Tree/Binomial Tree.md</guid><pubDate>Wed, 13 Mar 2024 09:25:28 GMT</pubDate><enclosure url="lib/media/截圖-2022-10-17-下午7.08.52.jpg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib/media/截圖-2022-10-17-下午7.08.52.jpg&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Binomial Tree, Binomial Heap]]></title><description><![CDATA[<a class="tag" href="?query=tag:⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️</a> 
 <br>Binomial Tree, Binomial Heap <a href=".?query=tag:⭐️⭐️⭐️" class="tag" target="_blank" rel="noopener">#⭐️⭐️⭐️</a><br><br><br><br><img alt="../img/截圖 2022-10-19 下午2.22.40.jpg" src="/lib/media/截圖-2022-10-19-下午2.22.40.jpg" style="width: 400px; max-width: 100%;"><br><br>Lazy merge<br>
作法：Root間雙向鏈結串接即可，min重設<img alt="../img/截圖 2022-10-19 下午2.25.38.jpg" src="/lib/media/截圖-2022-10-19-下午2.25.38.jpg" style="width: 200px; max-width: 100%;">
<br>“勤勞”合併<br>
Time:O(log n)<br>steps:<br>
<br>具有相同高度的Binomial Tree要合併
<br>repeat直到沒有相同高度的Tree
<br><img alt="../img/截圖 2022-10-19 下午2.37.26.jpg" src="/lib/media/截圖-2022-10-19-下午2.37.26.jpg" style="width: 400px; max-width: 100%;"><br>
因為最多log(n+1)棵要合，兩棵Tree合併O(1)<br>
=&gt; O(log(n+1))<br>Delete-min in Binomial Heap<br>steps:<br>
<br>找出Roots為最小值的Tree為T，其他Tree集合稱為Binomial Heap: (H1)
<br>刪T之Root，得到T之子樹集合，另為H2
<br>Merge(H1, H2) (勤勞合併)
<br><img alt="../img/截圖 2022-10-19 下午2.44.39.jpg" src="/lib/media/截圖-2022-10-19-下午2.44.39.jpg" style="width: 200px; max-width: 100%;"><br>
Time: O(log n)<br>Insert x into Binomial Heap H1<br>
steps:<br>
<br>x自己成為一個B.Heap H2
<br>Merge(H1, H2)

<br>Lazy [DS], [Algo]
<br>勤勞 [Weiss]  （分擔成本=O(1)）


<br>給1,2,3,4,5,6,7建立Binomial Heap(勤勞合併)“../img/截圖 2022-10-19 下午2.50.08.jpg” could not be found.<br>大部分的情況都是O(1)<br>
少部分的情況是O(log n):n=2^k -1(也就是log(n+1)棵樹)變成n = 2^k(一棵樹)<br>
分攤成本-&gt; O(1)<br>]]></description><link>考研筆記/資料結構/ch9-advanced-tree/binomial-tree,-binomial-heap.html</link><guid isPermaLink="false">考研筆記/資料結構/CH9 Advanced Tree/Binomial Tree, Binomial Heap.md</guid><pubDate>Wed, 13 Mar 2024 09:17:58 GMT</pubDate><enclosure url="lib/media/截圖-2022-10-19-下午2.22.40.jpg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib/media/截圖-2022-10-19-下午2.22.40.jpg&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[CH9 Advanced Tree]]></title><description><![CDATA[<a class="tag" href="?query=tag:⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️</a> <a class="tag" href="?query=tag:⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️</a> <a class="tag" href="?query=tag:⭐️⭐️⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️⭐️⭐️</a> <a class="tag" href="?query=tag:⭐️⭐️⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️⭐️⭐️</a> <a class="tag" href="?query=tag:⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️</a> <a class="tag" href="?query=tag:⭐️⭐️⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️⭐️⭐️</a> <a class="tag" href="?query=tag:⭐️⭐️⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️⭐️⭐️</a> <a class="tag" href="?query=tag:⭐️⭐️⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️⭐️⭐️</a> <a class="tag" href="?query=tag:⭐️⭐️⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️⭐️⭐️</a> <a class="tag" href="?query=tag:⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️</a> <a class="tag" href="?query=tag:⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️</a> <a class="tag" href="?query=tag:⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️</a> <a class="tag" href="?query=tag:⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️</a> 
 <br><br><br><br><br>min, max level交錯的Tree<br><br>左min右max，要跟對面比大小<br><br>~~x會在祖父的左子(min)右子(max)的範圍內 ~~<br><br><a class="internal-link" data-href="../../演算法/CH3 Dynamic Programming/Greedy Algorithm.md" href="/考研筆記/演算法/ch3-dynamic-programming/greedy-algorithm.html" target="_self" rel="noopener">Greedy Algorithm</a><br>
定義：n個nodes之B.T若以link list 表示，則會有 n+1 條Nil links。在這些Nil links 以一個特殊節點表示（☐），叫External nodes，其餘Nodes叫Internal nodes，此種B.T稱之。
外部結點數 = Nil link數 = n+1 = 比內部節點數多一
另外，考試或其他版本定義不同於Horowitz
I: Internal path Length(到所有內部Node的路徑長總和)<br>
E: External path Length(到所有外部Node的路徑長總和)<br>
<img alt="../img/截圖 2022-10-13 下午6.35.09.jpg" src="/lib/media/截圖-2022-10-13-下午6.35.09.jpg" style="width: 250px; max-width: 100%;"><br>
<a class="internal-link" data-href="Weighted External path Length.md" href="/考研筆記/資料結構/ch9-advanced-tree/weighted-external-path-length.html" target="_self" rel="noopener">WEPL</a>: Weighted External path Length<br>
<a class="internal-link" data-href="min.WEPL.md" href="/考研筆記/資料結構/ch9-advanced-tree/min.wepl.html" target="_self" rel="noopener">min.WEPL</a>：建立一顆樹，具有最小的WEPL
<br><br>E與I成正比<br>數高越小E, I值越小（反之越大）<br><br>
<br>
當Node數= 0時，此為empty，符合E = I+2N= 0+2*0 = 0。初值成立

<br>
令Node數&lt;= n-1時此定理成立

<br>
若Node數=n時，令Root左子樹有(右子樹同理)

<br>nL個內部節點
<br>IL為其Internal path length
<br>EL為其External path length

所以總共的I = IL + IR + nL + nR<br>
所以總共的E = EL + ER + (nL+1) + (nR+1)
因為nL, nR &lt;= (n-1)，依2假設EL = IL+2nL, ER = IR+2_nR<br>
E = _IL+2_nL + IR+2_nR + (nL+1) + (nR+1)<br>
E = (IL+IR+nL+nR)+2(nL+nR+1)<br>
E = I + 2N
數規法得證

<br><br><br>n個Runs之最佳合併方式 <a href=".?query=tag:ch7" class="tag" target="_blank" rel="noopener">#ch7</a><br>n個messages之編碼/解碼之平均編碼位元長度最小（or平均解碼時間）的Encoding 方式例1：<br>
有39個messages，其中只有6種不同的messages: m1~m6，且出現頻率分別是：<br>
m1 = 2/39, m2 = 3/39, m3 = 5/39, m4 = 7/39, m5 = 9/39, m6 = 13/39<br>
今希望平均Encoding Bit Length 最小。則：

<br>畫出Encoding/Decoding Tree
<br>各message之編碼內容
<br>Avg. Encoding Bit length = ?
<br>這39個messages之total Bit 數 ?

ANS:<br>
messages=&gt;外部結點<br>
頻率=&gt;加權值

<br>利用Huffman建立Tree...<br>
“../img/截圖 2022-10-13 下午8.00.50.jpg” could not be found.
<br>m1 = 1010, m2 = 1011, m3 = 100, m4 = 00, m5 = 01, m6 = 11<br>
Note:編碼內容以自己的Tree為準
<br>要考慮機率<br>
(4*2 + 4*3+3*5+2*7+2*9+2*13)/39 = 93/39
<br>93


例2:<br>
有一字串ABBBAACCDEFGFEAC<br>
有A~G不同字母<br>
求最小Encoding Bits length?
ANS:<br>
求出<a class="internal-link" data-href="Huffman Algorithm.md" href="/考研筆記/資料結構/ch9-advanced-tree/huffman-algorithm.html" target="_self" rel="noopener">Huffman Algorithm</a> Tree 的<a class="internal-link" data-href="Weighted External path Length.md" href="/考研筆記/資料結構/ch9-advanced-tree/weighted-external-path-length.html" target="_self" rel="noopener">WEPL</a>即為解。<br>
43 Bits<br>Huffman code是optimal Prefix Code<br><br><br><br><br><br><br><br><br><br><br>左<a class="internal-link" data-href="shortest.md" href="/考研筆記/資料結構/ch9-advanced-tree/shortest.html" target="_self" rel="noopener">shortest</a>大於等於右<a class="internal-link" data-href="shortest.md" href="/考研筆記/資料結構/ch9-advanced-tree/shortest.html" target="_self" rel="noopener">shortest</a><br><br>左斜排（root 比較小的）一排一排移過去<br><br>]]></description><link>考研筆記/資料結構/ch9-advanced-tree/ch9-advanced-tree.html</link><guid isPermaLink="false">考研筆記/資料結構/CH9 Advanced Tree/CH9 Advanced Tree.md</guid><pubDate>Wed, 13 Mar 2024 09:23:21 GMT</pubDate><enclosure url="lib/media/截圖-2022-10-13-下午6.35.09.jpg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib/media/截圖-2022-10-13-下午6.35.09.jpg&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Deap(Double-ended Heap)]]></title><description><![CDATA[<a class="tag" href="?query=tag:⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️</a> <a class="tag" href="?query=tag:⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️</a> 
 <br>Deap(Double-ended Heap)<br>min heap &amp; max heap合起來。對面的data符合min max的大小關係<br>
定義：是一顆 <a class="internal-link" data-href="CH5 Tree and Binary Tree.md###Complete Binary Tree" href="/考研筆記/資料結構/ch5-tree-and-binary-tree/ch5-tree-and-binary-tree.html#" target="_self" rel="noopener">Complete B.T</a> ，且滿足：

<br>Root 不存Data
<br>Root之左子樹是min-Heap
<br>Root之右子樹是Max-Heap
<br>令i是min-Heap中某Node編號，令j是i在Max-Heap中對應Node編號 則Deap[i] &lt;= Deap[j]

<br><img alt="../img/截圖 2022-10-12 下午4.49.52.jpg" src="/lib/media/截圖-2022-10-12-下午4.49.52.jpg" style="width: 400px; max-width: 100%;"><br><a class="internal-link" data-href="CH5 Tree and Binary Tree.md## Binary tree三個基本定理" href="/考研筆記/資料結構/ch5-tree-and-binary-tree/ch5-tree-and-binary-tree.html#" target="_self" rel="noopener">Binary tree三個基本定理</a><br>
j =  i+ 2^(upper(log₂(i+1))-2)<br>
if(j&gt;n){j = j/2} //用爸爸代替<br>Insert X 跟對面的比大小<br>左右比（交換），然後往上檢查min/max heap正確性<br>
<br>x先暫時置於the last Node之下一個位置(n)
<br>分成下列2個cases: 右邊的要比左邊的大，否則換！

<br>x在Min-Heap：令j為在Max-Heap之對應位置
if(x&gt; Deap[j]){ //x比對面的（min-Heap裡的）大
    Deap[n] = Deap[j];//j放到n
    InsertMax-Heap(Deap, j, x);//把x放在j的Heap然後往上檢查Heap
}else{
    InsertMin-Heap(Deap, n, x);//把x保留，然後往上檢查Heap
}
複製

<br>x在Max-Heap<br>
與case a相反


<br>Delete-min<br>last node移走，min heap調整，insert x<br>
<br>remove Root之左子點之Data，形成空Node
<br>remove the last Node，並將其data設記在x
<br>左子樹Root（空格）依序由其左右子點最小值往上遞補，直到降到leaf(編號為i) <a href=".?query=tag:⭐️⭐️⭐️" class="tag" target="_blank" rel="noopener">#⭐️⭐️⭐️</a>
<br>執行一個Deap的Insert =&gt; Insert x at i position <a href=".?query=tag:⭐️⭐️⭐️" class="tag" target="_blank" rel="noopener">#⭐️⭐️⭐️</a>
]]></description><link>考研筆記/資料結構/ch9-advanced-tree/deap(double-ended-heap).html</link><guid isPermaLink="false">考研筆記/資料結構/CH9 Advanced Tree/Deap(Double-ended Heap).md</guid><pubDate>Wed, 13 Mar 2024 09:20:36 GMT</pubDate><enclosure url="lib/media/截圖-2022-10-12-下午4.49.52.jpg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib/media/截圖-2022-10-12-下午4.49.52.jpg&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[external search/sort]]></title><description><![CDATA[ 
 <br><br><a class="internal-link" data-href="../CH7 Search and Sort/CH7 Search and Sort.md#Sort" href="/考研筆記/資料結構/ch7-search-and-sort/ch7-search-and-sort.html#Sort" target="_self" rel="noopener">CH7 Search and Sort</a><br>
定義：在Data量很大，無法一次全部置於memory進行search，只能借助外部儲存體保存Data，再行分批載入memory 中search
]]></description><link>考研筆記/資料結構/ch9-advanced-tree/external-search-or-sort.html</link><guid isPermaLink="false">考研筆記/資料結構/CH9 Advanced Tree/external search or sort.md</guid><pubDate>Wed, 13 Mar 2024 09:20:37 GMT</pubDate></item><item><title><![CDATA[Fibonacci Heap]]></title><description><![CDATA[<a class="tag" href="?query=tag:⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️</a> <a class="tag" href="?query=tag:⭐️⭐️⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️⭐️⭐️</a> 
 <br><a rel="noopener" class="external-link" href="https://hackmd.io/@vRN1CwEsTLyHOsG4mC0d4Q/B1xRTOC24" target="_blank">https://hackmd.io/@vRN1CwEsTLyHOsG4mC0d4Q/B1xRTOC24</a><br><a href=".?query=tag:⭐️⭐️" class="tag" target="_blank" rel="noopener">#⭐️⭐️</a><br>
<a class="internal-link" data-href="../CH1演算法/數學/Fibonacci Number ⭐️⭐️⭐️⭐️⭐️.md" href="/考研筆記/資料結構/ch1演算法/數學/fibonacci-number-⭐️⭐️⭐️⭐️⭐️.html" target="_self" rel="noopener">Fibonacci Number </a><br>
定義：是<a class="internal-link" data-href="Binomial Heap.md" href="/考研筆記/資料結構/ch9-advanced-tree/binomial-heap.html" target="_self" rel="noopener">Binomial Heap</a>之擴充版(懶惰版）。<br>
除了Insert x, Delete-min, merge之外，增加：

<br>Delete x
<br>Decrease-key of a Node (Time: O(1)) <a href=".?query=tag:⭐️⭐️⭐️⭐️⭐️" class="tag" target="_blank" rel="noopener">#⭐️⭐️⭐️⭐️⭐️</a>

<br><br>Delete x in Fib. Heap<br>steps:<br>
<br>若x = min, 則執行Delete-min運作
<br>否則，從所屬雙向link list中刪x，將x之各子樹之雙向link list 與roots間雙向link list串接，具有相同高度之Binomial Tree不用合併。
<br>Decrease-key of a Node<br>
（針對某點減少鍵值）<br><img alt="../../演算法/img/截圖 2022-10-27 下午2.49.57.jpg" src="/lib/media/截圖-2022-10-27-下午2.49.57.jpg" style="width: 400px; max-width: 100%;"><br>
<img src="/lib/media/截圖-2023-01-10-下午11.25.49.jpg"><br>
O(1)]]></description><link>考研筆記/資料結構/ch9-advanced-tree/fibonacci-heap.html</link><guid isPermaLink="false">考研筆記/資料結構/CH9 Advanced Tree/Fibonacci Heap.md</guid><pubDate>Wed, 13 Mar 2024 09:24:53 GMT</pubDate><enclosure url="lib/media/截圖-2022-10-27-下午2.49.57.jpg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib/media/截圖-2022-10-27-下午2.49.57.jpg&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Huffman Algorithm]]></title><description><![CDATA[<a class="tag" href="?query=tag:⭐️⭐️⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️⭐️⭐️</a> 
 <br>Huffman Algorithm<br>求<a class="internal-link" data-href="min.WEPL.md" href="/考研筆記/資料結構/ch9-advanced-tree/min.wepl.html" target="_self" rel="noopener">min.WEPL</a><br>
<a href=".?query=tag:⭐️⭐️⭐️⭐️⭐️" class="tag" target="_blank" rel="noopener">#⭐️⭐️⭐️⭐️⭐️</a><br><a class="internal-link" data-href="../../演算法/CH3 Dynamic Programming/Greedy Algorithm.md" href="/考研筆記/演算法/ch3-dynamic-programming/greedy-algorithm.html" target="_self" rel="noopener">Greedy Strategy</a><br>令W = n個外部結點加權值集合<br>
<br>從W中取出2個最小的加權值，建Tree
<br>並將他的合(WEPL)視為新權值，加入W中
<br>repeat 1, 2直到W只剩一個值  （n-1回合）
<br>建完的Tree叫Huffman Tree，其WEPL值即為min
<br>W = {2,3,5,7,9,13}，求<a class="internal-link" data-href="min.WEPL.md" href="/考研筆記/資料結構/ch9-advanced-tree/min.wepl.html" target="_self" rel="noopener">min.WEPL</a>ANS:<br>
“../img/截圖 2022-10-13 下午7.31.13.jpg” could not be found.<br>
“../../img/截圖 2022-12-31 下午2.44.45.jpg” could not be found.<br>
min. WEPL = 2*7+2*9+3*5+ 4*2+ 4*3 + 2*13 = 93<br>Node struct [ Lchild | weight | Rchild ]<br>Huffman(W:加權值集合, n:加權值個數){
	for i = 1 to n-1{
		new(t);
		t-&gt;Lchild = Del-min(w);
		t-&gt;Rchild = Del-min(w);
		t-&gt;weight = t-&gt;Lchild-&gt;weight + t-&gt;Rchild-&gt;weight;
		Insert(W, t-&gt;weight);
	}
}
複製<br>Time: W適合用<a class="internal-link" data-href="../CH5 Tree and Binary Tree/CH5 Tree and Binary Tree.md#Heap ⭐️⭐️⭐️⭐️⭐️" href="/考研筆記/資料結構/ch5-tree-and-binary-tree/ch5-tree-and-binary-tree.html#Heap_⭐️⭐️⭐️⭐️⭐️" target="_self" rel="noopener">min-Heap</a>來maintain =&gt; Insert &amp; Del-min 均分別花O(logn)，所以<br>
Huffman Algo. Time = O(nlogn)]]></description><link>考研筆記/資料結構/ch9-advanced-tree/huffman-algorithm.html</link><guid isPermaLink="false">考研筆記/資料結構/CH9 Advanced Tree/Huffman Algorithm.md</guid><pubDate>Wed, 13 Mar 2024 09:23:25 GMT</pubDate></item><item><title><![CDATA[Leftist Heap]]></title><description><![CDATA[ 
 <br>Leftist Heap<br>
定義：是一顆<a class="internal-link" data-href="#Leftist Tree" href="/#Leftist_Tree" target="_self" rel="noopener">Leftist Tree</a>且min. Tree。
<br>關鍵基礎運作<br>
Merge two Leftist Heap H1 &amp; H2<br>
steps:root較小的Heap就保留其左子樹到New Heap<br>
<br>比較H1, H2之roots找出最小值，不失一般性假設H1's root較小
<br>H1's root當作new root，且H1's root(較小的root的左子樹保留)左子樹保留成New root 之左子樹
<br>（遞迴）Merge H1's Root之右樹及H2成為New Root 之右子樹。上述repeat成為一顆min. Tree
<br>檢查每一個點的shortest是否符合<a class="internal-link" data-href="#Leftist Tree" href="/#Leftist_Tree" target="_self" rel="noopener">Leftist Tree</a>?若有違反，則swap its左右子樹。
<br>root比大小，小的root的左子樹放到新樹的右側，repeat。最後檢查shortest&amp;swap<br>Example“../img/截圖 2022-10-17 下午6.46.57.jpg” could not be found.<br>Delete-min in Leftist Heap<br>
steps:<br>
<br>將root刪除得到兩顆子樹(H1, H2)
<br>Merge(H1, H2)
<br>Insert x<br>
steps:<br>
<br>x自己成為一個Leftist Heap:H2
<br>Merge(H1, H2)
]]></description><link>考研筆記/資料結構/ch9-advanced-tree/leftist-heap.html</link><guid isPermaLink="false">考研筆記/資料結構/CH9 Advanced Tree/Leftist Heap.md</guid><pubDate>Wed, 13 Mar 2024 09:26:07 GMT</pubDate></item><item><title><![CDATA[Leftist Tree]]></title><description><![CDATA[<a class="tag" href="?query=tag:⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️</a> 
 <br> Leftist Tree<br><a href=".?query=tag:⭐️⭐️⭐️" class="tag" target="_blank" rel="noopener">#⭐️⭐️⭐️</a><br>緣由<br><br>
定義：針對每一個internal node x，<a class="internal-link" data-href="shortest.md" href="/考研筆記/資料結構/ch9-advanced-tree/shortest.html" target="_self" rel="noopener">shortest</a>(x-&gt;Lchild) &gt;= <a class="internal-link" data-href="shortest.md" href="/考研筆記/資料結構/ch9-advanced-tree/shortest.html" target="_self" rel="noopener">shortest</a>(x-&gt;Rchild)。左半大於右半
]]></description><link>考研筆記/資料結構/ch9-advanced-tree/leftist-tree.html</link><guid isPermaLink="false">考研筆記/資料結構/CH9 Advanced Tree/Leftist Tree.md</guid><pubDate>Wed, 13 Mar 2024 09:26:11 GMT</pubDate></item><item><title><![CDATA[m-way search Tree]]></title><description><![CDATA[<a class="tag" href="?query=tag:⭐️⭐️⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️⭐️⭐️</a> 
 <br>m-way search Tree <a href=".?query=tag:⭐️⭐️⭐️⭐️⭐️" class="tag" target="_blank" rel="noopener">#⭐️⭐️⭐️⭐️⭐️</a><br>(Tree's Degree = m)<br>
緣由：在"<a class="internal-link" data-href="../CH9 Advanced Tree/external search or sort.md" href="/考研筆記/資料結構/ch9-advanced-tree/external-search-or-sort.html" target="_self" rel="noopener">external search/sort</a>"，效能關鍵在於降低I/O次數，通常在Disk內資料區塊，一般都用search Tree結構維護，而其高度 = 最多的I/O次數<br>
=&gt;降低seach Tree高度才可降低I/O次數，而有效辦法即是加大Tree's Degree*
<br>m-way search Tree高度 = h。(1)求最多Node數(2)最多key(or Data)數“../img/截圖 2022-10-14 下午4.18.22.jpg” could not be found.<br>
= (m^h-1)/(m-1)

= (m^h-1)/(m-1) * (m-1) = m^h - 1<br>m-way search tree Node數 = n，求最小高度=?m^h -1 = n<br>
h =  ⎡log𝚖 n+1⎤]]></description><link>考研筆記/資料結構/ch9-advanced-tree/m-way-search-tree.html</link><guid isPermaLink="false">考研筆記/資料結構/CH9 Advanced Tree/m-way search Tree.md</guid><pubDate>Wed, 13 Mar 2024 09:23:23 GMT</pubDate></item><item><title><![CDATA[Min-Max Heap]]></title><description><![CDATA[ 
 <br>Min-Max Heap<br>
定義：是一顆 <a class="internal-link" data-href="CH5 Tree and Binary Tree.md###Complete Binary Tree" href="/考研筆記/資料結構/ch5-tree-and-binary-tree/ch5-tree-and-binary-tree.html#" target="_self" rel="noopener">Complete B.T</a>,且滿足

<br>其level是min-Level與Max-Level 交互出現
<br>Root位於min-Level 從min作為頭
<br>若x位於min-Level/Max-Level，代表以x為root之子樹中，x具有最小值/最大值。

<br><img alt="../img/截圖 2022-10-12 下午4.03.05.jpg" src="/lib/media/截圖-2022-10-12-下午4.03.05.jpg" style="width: 400px; max-width: 100%;"><br>VerifyMax<br>
檢查在所有Max levels中，最大的會在最上層的Max level
<br>VerifyMin同理<br>Insert X<br>parent level的node和新的node大小關係正確（只往上一層看）<br>
在用Verify去往上修正<br>
<br>x先暫時放在最末端的下一個位置(n)
<br>令x的parent稱為p。分成下列兩case

<br>p位於min-level：
if x&lt;= H[p]{
    H[n] = H[p]; // p值下移
    VerifyMin(H, p, x)
}else{
    VerifyMAX(H, n, x)
}
複製

<br>p 位於Max-Level<br>
與case a相反


<br>Time: O(log n)
<br>Delete-min<br>令last node是x
1. (root跟max level比較) root's左右子存在比x小，和左右子的min交換 
2. (root跟min level比較) 若此時有交換，以交換的node為root繼續遞迴
複製<br>找出下兩層的min，在子node交換就結束了。在孫子，交換之後遞迴<br>
<br>remove root data（因為root最小）
<br>將the last Node刪除，設給x變數
<br>x要插入到一個root為空的min-Max Heap中。分成下列case 往下找最小的看最小的在第幾層

<br>root下無子點：x置入root，結束
<br>root的子孫中最小值位於root左子or右子（下一層）中（令為k）<br>
if x&lt;= k: x放到root<br>
else: x放到k的位置，k放到root
<br>Root之最小值在Root的孫子中（下下層）之其中一個（令為k），且k之父點為p<br>
if x&lt;= k: x放入root<br>
else: k放到root，if x&gt; p: x, p互換，goto step 3這一個case有遞迴


]]></description><link>考研筆記/資料結構/ch9-advanced-tree/min-max-heap.html</link><guid isPermaLink="false">考研筆記/資料結構/CH9 Advanced Tree/Min-Max Heap.md</guid><pubDate>Wed, 13 Mar 2024 09:26:20 GMT</pubDate><enclosure url="lib/media/截圖-2022-10-12-下午4.03.05.jpg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib/media/截圖-2022-10-12-下午4.03.05.jpg&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[min.WEPL]]></title><description><![CDATA[ 
 <br><br>應用找出最適合的 merging sort方法（每個leaf長度不一樣的情況下）<br>
定義：若有n個內部Node，給予(n+1)個外部節點加權值，則在1/(n+1)C(2n, n)顆不同B.T中，求出min.WEPL<br>
！利用<a class="internal-link" data-href="Huffman Algorithm.md" href="/考研筆記/資料結構/ch9-advanced-tree/huffman-algorithm.html" target="_self" rel="noopener">Huffman Algorithm</a>
]]></description><link>考研筆記/資料結構/ch9-advanced-tree/min.wepl.html</link><guid isPermaLink="false">考研筆記/資料結構/CH9 Advanced Tree/min.WEPL.md</guid><pubDate>Wed, 13 Mar 2024 09:36:26 GMT</pubDate></item><item><title><![CDATA[OBST(optimal BST)]]></title><description><![CDATA[<a class="tag" href="?query=tag:⭐️⭐️⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️⭐️⭐️</a> 
 <br>OBST(optimal BST)<br><a href=".?query=tag:⭐️⭐️⭐️⭐️⭐️" class="tag" target="_blank" rel="noopener">#⭐️⭐️⭐️⭐️⭐️</a><br>
定義：給予n個內部Nodes加權值:

<br>pi, 1&lt;=i&lt;=n
<br>qj, 0&lt;=j&lt;=n

則在所有不同的BST中，具有最小的搜尋總成本_之BST稱為<a class="internal-link" data-href="../../演算法/CH3 Dynamic Programming/CH3 Dynamic Programming.md#3.5 Optimal binary search trees" href="/考研筆記/演算法/ch3-dynamic-programming/ch3-dynamic-programming.html#3.5_Optimal_binary_search_trees" target="_self" rel="noopener">OBST</a>
<br>成功成本<br>
內部Nodei之level＊pi(i = 1~n)<br>失敗成本<br>
外部Nodej之level＊qj(j = 0~n)<br><br><a class="internal-link" data-href="../../演算法/CH3 Dynamic Programming/CH3 Dynamic Programming.md# 3.5 Optimal binary search trees" href="/考研筆記/演算法/ch3-dynamic-programming/ch3-dynamic-programming.html#_3.5_Optimal_binary_search_trees" target="_self" rel="noopener">CH3 Dynamic Programming's OBST</a><br>
<br><a class="internal-link" data-href="../../演算法/CH3 Dynamic Programming/CH3 Dynamic Programming.md#3.1 Introduction" href="/考研筆記/演算法/ch3-dynamic-programming/ch3-dynamic-programming.html#3.1_Introduction" target="_self" rel="noopener">D.P方法</a>
<br>假設：

<br>T[i, j]表由 a[i+1]~a[j] 所組成的OBST
<br>C[i, j]代表T[i, j]的ESC。演算法中的s[i, j]的功能
<br>W[i, j]代表T[i, j]內 外部nodes weights加總
<br>r[i, j]表T[i, j]之Root No.


<br>C[i, j] = W[i, j]+ min{C[i, k-1]+C[k, j]}<br><br>
<br>失敗成本的定義不同。在演算法中，失敗node的level沒有-1<br>
解法：Algo答案 = 資結答案 + 外部加權值總和
<br>T[i, j]在兩個版之間不同
<br>所以考試時必須先定義所有公式，可以的話重新推導]]></description><link>考研筆記/資料結構/ch9-advanced-tree/obst(optimal-bst).html</link><guid isPermaLink="false">考研筆記/資料結構/CH9 Advanced Tree/OBST(optimal BST).md</guid><pubDate>Wed, 13 Mar 2024 09:23:28 GMT</pubDate></item><item><title><![CDATA[Red-Black Tree]]></title><description><![CDATA[<a class="tag" href="?query=tag:⭐️⭐️⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️⭐️⭐️</a> <a class="tag" href="?query=tag:balancedBST之一" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#balancedBST之一</a> 
 <br>Red-Black Tree<br><a href=".?query=tag:⭐️⭐️⭐️⭐️⭐️" class="tag" target="_blank" rel="noopener">#⭐️⭐️⭐️⭐️⭐️</a><br>
<a href=".?query=tag:balancedBST之一" class="tag" target="_blank" rel="noopener">#balancedBST之一</a><br>[Algorithm 版]<br>
定義：是一種"balancedBST"，若不為空，則滿足：

<br>Node之color非黑即紅
<br>root一律是黑色
<br>Nil也視為黑色
<br>紅色Node之子點必為黑色（path上不可出現連續的紅色Nodes）
<br>Root 到任何Leaf之path上必定有相同數目之黑色

<br>Insert x<br>
[weiss: Top-Down版本]<br>search(&amp;check雙紅子) -&gt; push x -&gt; rotate -&gt; end<br>
<br>search for x
<br>在search過程中，若有經過某Node，其兩個子點是紅色，則先做"color change"，且color change之後要檢查是否有連續的紅色，若有則需用Rotation調整。
<br>此時新點標紅色
<br>檢查是否有連續的紅色Nodes，若有，則需做Rotation調整
<br>Root一律改黑色(if needed)
<br>只會出現一次/一種Rotation<br>不會回頭到上一步<br>Note
<br>RB Tree: Insert/search/Delete x之time皆O(logn)
<br>RB Tree

<br>Insert x:need O(1)rotations
<br>Delete x:need O(1)rotations(優於<a class="internal-link" data-href="AVL Tree.md" href="/考研筆記/資料結構/ch9-advanced-tree/avl-tree.html" target="_self" rel="noopener">AVL Tree</a>)


<br><br>類似<a class="internal-link" data-href="AVL Tree.md" href="/考研筆記/資料結構/ch9-advanced-tree/avl-tree.html" target="_self" rel="noopener">AVL Tree</a><br>
差別：需加上顏色調整<br>
<br>中間鍵往上拉，標黑色
<br>小放左 大放右，標紅色 (兒子標紅)
<br>LL, LR, RL, RR

<br>LL rotation<img alt="../img/截圖 2022-10-17 下午2.41.56.jpg" src="/lib/media/截圖-2022-10-17-下午2.41.56.jpg" style="width: 200px; max-width: 100%;">
<br>LR roataion<img alt="../img/截圖 2022-10-17 下午2.42.17.jpg" src="/lib/media/截圖-2022-10-17-下午2.42.17.jpg" style="width: 200px; max-width: 100%;">
<br>RR roataion<img alt="../img/截圖 2022-10-17 下午2.42.50.jpg" src="/lib/media/截圖-2022-10-17-下午2.42.50.jpg" style="width: 200px; max-width: 100%;">
<br>LR rotation<img alt="../img/截圖 2022-10-17 下午2.43.30.jpg" src="/lib/media/截圖-2022-10-17-下午2.43.30.jpg" style="width: 200px; max-width: 100%;">


<br>給3,1,2,9,6,7,4,5,8,10建立RB Tree“../img/截圖 2022-10-17 下午3.03.08.jpg” could not be found.<br>
“../../img/截圖 2022-12-31 下午4.31.31.jpg” could not be found.<br><br>
定義：是2-3-4 Tree對應的BST，若不為空，則滿足:

<br>Link之color非黑即紅
<br>若此link 在原本2-3-4 Tree中存在的，則不為黑色links否則是紅色links
<br>任何path不會出現"連續的"紅色links
<br>Root到任何不同的leaf之path皆具有相同數量的黑色

<br><br><a class="internal-link" data-href="Binary Tree of order m.md" href="/考研筆記/資料結構/ch9-advanced-tree/binary-tree-of-order-m.html" target="_self" rel="noopener">Binary Tree of order m</a><br>原Node中的關聯用紅link連起來<br><img alt="../img/截圖 2022-10-17 下午3.29.11.jpg" src="/lib/media/截圖-2022-10-17-下午3.29.11.jpg" style="width: 600px; max-width: 100%;"><br><br>pf:<br>
令h = RB-Tree且依照property 4，最長path必定是黑紅交錯*。<br>
所以至少有一半Nodes是黑色，RB tree至少包含&gt;= (2^(h/2) -1)個Nodes<br>
-&gt; n &gt;= 2^(h/2) -1 -&gt; 2^(h/2)  &lt;= n+1<br>
-&gt; h &lt;= 2log(n+1)]]></description><link>考研筆記/資料結構/ch9-advanced-tree/red-black-tree.html</link><guid isPermaLink="false">考研筆記/資料結構/CH9 Advanced Tree/Red-Black Tree.md</guid><pubDate>Wed, 13 Mar 2024 09:24:56 GMT</pubDate><enclosure url="lib/media/截圖-2022-10-17-下午2.41.56.jpg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib/media/截圖-2022-10-17-下午2.41.56.jpg&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[shortest]]></title><description><![CDATA[ 
 <br><br>
定義：令x是<a class="internal-link" data-href="#Extended Binary Tree" href="/#Extended_Binary_Tree" target="_self" rel="noopener">Extended B.T</a>中某Node，則
shortest(x)
= 0, if x is External node
= 1+min{shortest(x-&gt;Lchild), shortest(x-&gt;Rchild)}
複製
<img alt="../img/截圖 2022-10-17 下午6.25.17.jpg" src="/lib/media/截圖-2022-10-17-下午6.25.17.jpg" style="width: 200px; max-width: 100%;">
]]></description><link>考研筆記/資料結構/ch9-advanced-tree/shortest.html</link><guid isPermaLink="false">考研筆記/資料結構/CH9 Advanced Tree/shortest.md</guid><pubDate>Wed, 13 Mar 2024 09:36:27 GMT</pubDate><enclosure url="lib/media/截圖-2022-10-17-下午6.25.17.jpg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib/media/截圖-2022-10-17-下午6.25.17.jpg&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[SMMH(Symmetric Min-Max Heap)]]></title><description><![CDATA[ 
 <br>SMMH(Symmetric Min-Max Heap)<br>
x和x的兄弟的子點的值會介於x和x的兄弟的值之間<br>
定義：是一顆 <a class="internal-link" data-href="CH5 Tree and Binary Tree.md###Complete Binary Tree" href="/考研筆記/資料結構/ch5-tree-and-binary-tree/ch5-tree-and-binary-tree.html#" target="_self" rel="noopener">Complete B.T</a>，且Root不存Data，且滿足下列3個性質：

<br>左兄弟&lt;=右兄弟值
<br>若x有祖父，則：

<br>祖父的左子點必須&lt;=x
<br>祖父的右子點必&gt;= x



<br><img alt="../img/截圖 2022-10-13 下午5.52.01.jpg" src="/lib/media/截圖-2022-10-13-下午5.52.01.jpg" style="width: 300px; max-width: 100%;"><br>Insert X<br>
<br>x暫置於最末端的下一個位置
<br>檢查條件1（左兄弟&lt;=右兄弟值），否則對調（若沒有兄弟則不動）  做為兄弟，大的站右邊
<br>檢查條件2.a和2.b，否則調整  跟祖父的左右子(parent's 和parent's兄弟])比較大小，依規則對調 
<br>重複做2, 3到祖父為root結束 往上排！！
<br>練習“../img/截圖 2022-10-13 下午6.00.40.jpg” could not be found.<br>
Ans:<br>
“../img/截圖 2022-10-13 下午6.07.47.jpg” could not be found.<br>Delete-min<br>
<br>remove Root 左子點之Data(形成空格)。令Root 左子點為E（方便後續說明）
<br>將最後的Node's Data暫時存在x，並刪除該Node
<br>檢查性質1（右兄&gt;左兄）。E（暫時用x）跟兄弟比
<br>取_min{E的左子, E兄弟的左子, x}為Y_，Y, E對調
<br>重複3, 4直到x填入E。
<br>分析<br>
min = Root 左子點<br>
Max = Root 右子點<br>
（上上層的）左子必為「所有子孫」的最小，（上上層的）右子必為「所有子孫」的最大
]]></description><link>考研筆記/資料結構/ch9-advanced-tree/smmh(symmetric-min-max-heap).html</link><guid isPermaLink="false">考研筆記/資料結構/CH9 Advanced Tree/SMMH(Symmetric Min-Max Heap).md</guid><pubDate>Wed, 13 Mar 2024 09:17:56 GMT</pubDate><enclosure url="lib/media/截圖-2022-10-13-下午5.52.01.jpg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib/media/截圖-2022-10-13-下午5.52.01.jpg&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[splay 運算]]></title><description><![CDATA[ 
 <br><br>透過一連串Rotations將splay起點變成root，兒rotation分為：<br>
<br>只有自己與父點，沒有祖父(兩點的rotation)
<br>3個點(自己、父、祖父)分成4種（LL, RR, LR, RL）注意：與<a class="internal-link" data-href="AVL Tree.md" href="/考研筆記/資料結構/ch9-advanced-tree/avl-tree.html" target="_self" rel="noopener">AVL Tree</a>不同<img alt="../img/截圖 2022-10-17 下午6.08.02.jpg" src="/lib/media/截圖-2022-10-17-下午6.08.02.jpg" style="width: 200px; max-width: 100%;"><br>
<img alt="../img/截圖 2022-10-17 下午6.08.41.jpg" src="/lib/media/截圖-2022-10-17-下午6.08.41.jpg" style="width: 200px; max-width: 100%;">
<br>Example“../img/截圖 2022-10-17 下午6.12.47.jpg” could not be found.]]></description><link>考研筆記/資料結構/ch9-advanced-tree/splay-運算.html</link><guid isPermaLink="false">考研筆記/資料結構/CH9 Advanced Tree/splay 運算.md</guid><pubDate>Wed, 13 Mar 2024 09:36:28 GMT</pubDate><enclosure url="lib/media/截圖-2022-10-17-下午6.08.02.jpg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib/media/截圖-2022-10-17-下午6.08.02.jpg&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[splay Tree]]></title><description><![CDATA[<a class="tag" href="?query=tag:⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️</a> 
 <br>splay Tree <a href=".?query=tag:⭐️" class="tag" target="_blank" rel="noopener">#⭐️</a><br>簡化的AVL tree，且splay起點會totation到root<br>緣由：<br><br>
定義：splay Tree是一顆BST，其Inset/search/Delete x操作同BST。<br>
主要差別：<br>
做完運算後必須針對*<a class="internal-link" data-href="splay起點.md" href="/考研筆記/資料結構/ch9-advanced-tree/splay起點.html" target="_self" rel="noopener">splay起點</a>執行<a class="internal-link" data-href="splay 運算.md" href="/考研筆記/資料結構/ch9-advanced-tree/splay-運算.html" target="_self" rel="noopener">splay 運算</a>（由一連串rotations組成）_，目的是要 將<a class="internal-link" data-href="splay起點.md" href="/考研筆記/資料結構/ch9-advanced-tree/splay起點.html" target="_self" rel="noopener">splay起點</a>變成New Root
]]></description><link>考研筆記/資料結構/ch9-advanced-tree/splay-tree.html</link><guid isPermaLink="false">考研筆記/資料結構/CH9 Advanced Tree/splay Tree.md</guid><pubDate>Wed, 13 Mar 2024 09:30:39 GMT</pubDate></item><item><title><![CDATA[splay起點]]></title><description><![CDATA[ 
 <br><br>
定義：

<br>search for x =&gt; x當splay 起點
<br>Insert x =&gt; x當splay 起點
<br>Delete x =&gt; x的父點當splay 起點

]]></description><link>考研筆記/資料結構/ch9-advanced-tree/splay起點.html</link><guid isPermaLink="false">考研筆記/資料結構/CH9 Advanced Tree/splay起點.md</guid><pubDate>Wed, 13 Mar 2024 09:36:36 GMT</pubDate></item><item><title><![CDATA[Weighted External path Length]]></title><description><![CDATA[ 
 <br>WEPL<br>
定義:給予n個外部Nodes加權值, gᵢ, 1&lt;= i&lt;= n，則WEPL = 每個外部node的length＊該Node的加權值 總和<br>
<img alt="../img/截圖 2022-10-13 下午7.09.33.jpg" src="/lib/media/截圖-2022-10-13-下午7.09.33.jpg" style="width: 250px; max-width: 100%;"><br>
結論：有了加權值，不見得數高越小越好。
]]></description><link>考研筆記/資料結構/ch9-advanced-tree/weighted-external-path-length.html</link><guid isPermaLink="false">考研筆記/資料結構/CH9 Advanced Tree/Weighted External path Length.md</guid><pubDate>Wed, 13 Mar 2024 09:16:23 GMT</pubDate><enclosure url="lib/media/截圖-2022-10-13-下午7.09.33.jpg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib/media/截圖-2022-10-13-下午7.09.33.jpg&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[IMG_2226.jpg]]></title><description><![CDATA[ 
 ]]></description><link>考研筆記/資料結構/img/img_2226.jpg.html</link><guid isPermaLink="false">考研筆記/資料結構/img/IMG_2226.jpg.md</guid><pubDate>Wed, 13 Mar 2024 09:48:47 GMT</pubDate></item><item><title><![CDATA[資料結構]]></title><description><![CDATA[ 
 <br><br><br><br><br><br><br><br><br><br><br>
<br>熟筆記 （老師有教的所有東西）
<br>計算
<br>背Algo/ code
<br>沒看過 -&gt; 查Google
]]></description><link>考研筆記/資料結構/⭐️資料結構.html</link><guid isPermaLink="false">考研筆記/資料結構/⭐️資料結構.md</guid><pubDate>Wed, 13 Mar 2024 09:52:19 GMT</pubDate></item><item><title><![CDATA[未命名]]></title><description><![CDATA[ 
 找不到 “資料結構/CH3 Stack and Queue/CH3 Stack and Queue.md”。建立新檔案交換檔案…移除資料結構/CH3 Stack and Queue/CH3 Stack and Queue.md找不到 “資料結構/⭐️資料結構.md”。建立新檔案交換檔案…移除資料結構/⭐️資料結構.md找不到 “資料結構/CH2 Array&amp; CH4 Link List/CH2 Array&amp; CH4 Link List.md”。建立新檔案交換檔案…移除資料結構/CH2 Array&amp; CH4 Link List/CH2 Array&amp; CH4 Link List.md]]></description><link>考研筆記/資料結構/未命名.html</link><guid isPermaLink="false">考研筆記/資料結構/未命名.canvas</guid><pubDate>Wed, 13 Mar 2024 09:52:04 GMT</pubDate></item><item><title><![CDATA[CH1 Analyzing Algorithm]]></title><description><![CDATA[ 
 <br><br><a class="internal-link" data-href="Extended Master Theorem.md" href="/考研筆記/演算法/ch1-analyzing-algorithm/extended-master-theorem.html" target="_self" rel="noopener">Extended Master Theorem</a><br><a rel="noopener" class="external-link" href="https://mropengate.blogspot.com/2015/04/algorithm-ch1-master-theorem-super.html?m=1" target="_blank">https://mropengate.blogspot.com/2015/04/algorithm-ch1-master-theorem-super.html?m=1</a>]]></description><link>考研筆記/演算法/ch1-analyzing-algorithm/ch1-analyzing-algorithm.html</link><guid isPermaLink="false">考研筆記/演算法/CH1 Analyzing Algorithm/CH1 Analyzing Algorithm.md</guid><pubDate>Wed, 13 Mar 2024 09:17:42 GMT</pubDate></item><item><title><![CDATA[Extended Master Theorem]]></title><description><![CDATA[ 
 <br><br>若T(n) = aT(n/b)+n^(log_b a * log^k n)，或f(n)/n^(log_b a) = (log n)^k，<br>
則Extended Master Theorem，否則master theorem case 3<br>
<br>

(1)
T(n) = 2T(n/2) + nlogn
Ans:
	n^(log_b a) = n^1
	而f(n)/n^(log_b a) = logn, k = 1
	Extended.M.T =&gt; 𝝷( n(logn)^2 )
	```	
複製

<br><img alt="img/截圖 2022-09-15 下午8.50.01.jpg" src="/lib/media/截圖-2022-09-15-下午8.50.01.jpg" style="width: 500px; max-width: 100%;"><br><br>T(n) = 2T(n/2)+n/log n ]]></description><link>考研筆記/演算法/ch1-analyzing-algorithm/extended-master-theorem.html</link><guid isPermaLink="false">考研筆記/演算法/CH1 Analyzing Algorithm/Extended Master Theorem.md</guid><pubDate>Wed, 13 Mar 2024 09:17:37 GMT</pubDate><enclosure url="lib/media/截圖-2022-09-15-下午8.50.01.jpg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib/media/截圖-2022-09-15-下午8.50.01.jpg&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Divide-and-Conquer]]></title><description><![CDATA[ 
 <br><br><br>Divide-and-Conquer 是一種演算法的策略<br>
<br>Divide: 將原問題切分成多個(n)獨立的子問題
<br>Conquer: 遞迴解各個子問題，子問題夠簡單就可以直接解
<br>Combine: 子問題合併成原問題
<br><br><br>給一整數陣列A[1..n], 求其中具有最大元素和之subarray?<br><br>
<br>Divide: 切成左右子陣列
<br>Conquer: 遞迴求出子陣列的最大子陣列
<br>Combine: 取左子、右子、跨越三個之中的maximum subarray
<br><img src="/lib/media/截圖-2022-09-15-下午4.34.59.jpg"><br>
T(n) = 2T(n/2)+𝝷(n)<br>
T(1) = 𝝷(1)<br>
T(n)= 𝝷(n lg n)
<br><br><img alt="img/截圖 2022-09-15 下午4.40.30.jpg" src="/lib/media/截圖-2022-09-15-下午4.40.30.jpg" style="width: 500px; max-width: 100%;"><br>Max-Subarray-DP(A):
	max = A[1]
	r = A[1]
	for i =2 to n:
		if r+A[i] &gt; A[i]: 
			r = r+A[i]
		else: 
			r = A[i]
		if r &gt; max:
			max = r
	return max
複製<br><br>使用Divide-and-Conquer<br>
切成4個大小為n/2*n/2 的矩陣<br>
<img alt="img/截圖 2022-09-15 下午4.54.49.jpg" src="/lib/media/截圖-2022-09-15-下午4.54.49.jpg" style="width: 500px; max-width: 100%;"><br>
但效果不會比暴力法好，都是𝝷(n^3)
<br><br><img alt="img/截圖 2022-09-15 下午4.54.57.jpg" height="400" src="/lib/media/截圖-2022-09-15-下午4.54.57.jpg" style="width: 300px; max-width: 100%;"><br>
T(n) = 7T(n/2)+𝝷(n²)<br>
T(1) = 𝝷(1)<br>
T(n) = 𝝷(n^lg7) = 𝝷(n^(2.81))
<br><br>給訂n個相異數，求第k小的數<br>
使用<a class="internal-link" data-href="Merge-Sort.md" href="/考研筆記/演算法/ch2-divide-and-conquer/merge-sort.html" target="_self" rel="noopener">Merge-Sort</a>然後取第k位數=&gt;O(n lg n)<br><a class="internal-link" data-href="Prune-and-search.md" href="/考研筆記/演算法/ch2-divide-and-conquer/prune-and-search.html" target="_self" rel="noopener">Prune-and-search</a><br><br><a class="internal-link" data-href="../../資料結構/CH7 Search and Sort/CH7 Search and Sort.md#### [法三]" href="/考研筆記/資料結構/ch7-search-and-sort/ch7-search-and-sort.html#" target="_self" rel="noopener">資料結構Selection problem</a><br>
<br>將input分成upper(n/5)堆
<br>每組做sorting
<br>求出P(中位數中的中位數)
<br>找出P為第幾小
<br>求S1, S2。(S1是&lt;p的、S2是&gt;p的)
<br>分析。假設p為第x小的數

<br>x = k, return p 。 找到了
<br>x &lt; k, 去掉左上，求剩餘第 k - |S1|小
<br>x &gt; k, 去掉右下，求剩餘第 k 小


<br><img alt="img/截圖 2022-09-15 下午5.27.47.jpg" src="/lib/media/截圖-2022-09-15-下午5.27.47.jpg" style="width: 500px; max-width: 100%;"><br>
T(n) = T(n/5)+T(3n/4)+O(n)<br>
T(n) = O(n)
<br>NOTE:若改成4個一堆則時間超過O(n)<br><a data-tooltip-position="top" aria-label="https://ithelp.ithome.com.tw/articles/10202330" rel="noopener" class="external-link" href="https://ithelp.ithome.com.tw/articles/10202330" target="_blank">QuickSort</a><br>
<a class="internal-link" data-href="../../資料結構/CH7 Search and Sort/Quick Sort.md" href="/考研筆記/資料結構/ch7-search-and-sort/quick-sort.html" target="_self" rel="noopener">Quick Sort</a><br>
<img alt="../../資料結構/img/截圖 2022-09-19 下午9.04.36.jpg" src="/lib/media/截圖-2022-09-19-下午9.04.36.jpg" style="width: 250px; max-width: 100%;"><br><br>在座標平面中給定n個點，其中距離最近的兩點稱為closest pair，求closest pair之距離<br>
Preprocessing<br>
<br>先將P中的點依x座標排序並存在list K
<br>Closest-Pair(P)<br>
<br>建立垂直x軸的中心分割線l。令L為l線左邊的點集合，令R為l線右邊的點集合。
<br>遞回求L,R中closest pair之距離dL, dR，令d = min{dL, dR}
<br>**依序取出K中每個滿足{到l的垂直距離 &lt;= d} l交界處，檢查K中緊接著p之後出現的7個點p'，若dist(p, p') &lt; d，d = dist(p, p') min(dL, dR, dLR)
<br>
<br>return d
<br><br>Preprocessing: O(n lg n)<br>
Closest-Pair:<br>
<br>找中心線 -&gt; O(n)
<br>遞回 -&gt; 2T(n/2)
<br>關鍵部分(divide-and-conquer的合併)，希望找到closest pair(p, p')。<img alt="img/截圖 2022-09-17 下午3.18.16.jpg" src="/lib/media/截圖-2022-09-17-下午3.18.16.jpg" style="width: 400px; max-width: 100%;"><br>
左邊方形最多4個點，右邊方形同樣4個，由於方形邊長為d (min{dL, dR})，所以與區域內的p距離&lt;d的點最多只有7個(只有這7個點可能讓距離變短)。<br>
只要掃過K一遍(O(n))，若掃到p點，則只要再往下檢查7個點(O(1))，即可找出所有距離{dist(p, p')}&lt;d。<br>
因此這部分需時𝝷(n)
<br>
T(n) = 2T(n/2)+ 𝝷(n)   = 𝝷(n lg n)<br>
preprocessing + T(n) = 𝝷(n lg n) + O(n lg n) = 𝝷(n lg n)<br>
𝝷(n lg n)
]]></description><link>考研筆記/演算法/ch2-divide-and-conquer/ch2-divide-and-conquer.html</link><guid isPermaLink="false">考研筆記/演算法/CH2 Divide-and-Conquer/CH2 Divide-and-Conquer.md</guid><pubDate>Mon, 04 Mar 2024 08:08:30 GMT</pubDate><enclosure url="lib/media/截圖-2022-09-15-下午4.34.59.jpg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib/media/截圖-2022-09-15-下午4.34.59.jpg&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Merge-Sort]]></title><description><![CDATA[ 
 <br><br>
<br>切成左右子矩陣
<br>對左右子問題遞迴做排序
<br>合併以完成排序的左右子陣列
<br>
T(n) = 2T(n/2)+ 𝝷(n)<br>
T(1) = 𝝷(1)<br>
T(n)= 𝝷(n lg n)
]]></description><link>考研筆記/演算法/ch2-divide-and-conquer/merge-sort.html</link><guid isPermaLink="false">考研筆記/演算法/CH2 Divide-and-Conquer/Merge-Sort.md</guid><pubDate>Wed, 13 Mar 2024 09:24:41 GMT</pubDate></item><item><title><![CDATA[Prune-and-search]]></title><description><![CDATA[ 
 <br><br>若遞迴程式每次在分割問題時，可以把不影響求解的instance移除，在遞迴解子問題，直到子問題小到可以在constant time 之內解決<br>
此種特殊的Divide-and-Conquer即稱為Prune-and-search<br>
Binary-search即為Prune-and-search策略的演算法]]></description><link>考研筆記/演算法/ch2-divide-and-conquer/prune-and-search.html</link><guid isPermaLink="false">考研筆記/演算法/CH2 Divide-and-Conquer/Prune-and-search.md</guid><pubDate>Wed, 13 Mar 2024 09:21:46 GMT</pubDate></item><item><title><![CDATA[CH3 Dynamic Programming]]></title><description><![CDATA[ 
 <br><br>複製<br><br>Dynamic Programming為一個解決遞迴型態問題的策略，相對於Divide-and-Conquer，傾向於直接從子問題著手，將可能會參考到的子問題皆算出並存下。<br>
<br>D.P方法三要素

<br>定義問題solution公式
<br>列表求出最終結果。此表格用來保存先前算過（子問題）的答案
<br>會reuse subproblem 之solution


<br>實用例子： <a class="internal-link" data-href="Fibonacci number.md" href="/考研筆記/演算法/ch3-dynamic-programming/fibonacci-number.html" target="_self" rel="noopener">Fibonacci number</a><br>
重要性質： <a class="internal-link" data-href="Optimal structure.md" href="/考研筆記/演算法/ch3-dynamic-programming/optimal-structure.html" target="_self" rel="noopener">Optimal structure</a><br>優缺比較<br>
～～～～<br><br>假設銷售長度為i的rod可得pi元，i = 1, 2, ..., n，如何切一條長隊為n的rod使得收入最大化<br>
KEY:怎麼切可以讓左右兩段總和收益最高
<br><br>令rn為在長為n的rod可以獲得的最大收益，則<br>
rn<br>
= max{p1 + rn-1, p2 + rn-2, p3 + rn-3, ..., pn}, if n&gt;=1<br>
= p0 = 0, if n = 0
<br>Rod-Cutting(p, n){
	if(n == 0){
		return 0;
	}
	s = -無限;
	for(int i = 1; i&lt;=n; i++){
		if(s &lt; p[i]+Rod-Cutting(p, n-i)){
			s = p[i]+Rod-Cutting(p, n-i);
		}
	}
	return s;
}
複製<br>
T(n) = 1 + T(n-1) + T(n-2) + ... + T(0)<br>
T(n-1) = 1 + T(n-2) + T(n-3) + ... + T(0)<br>
T(n) - T(n-1) = T(n-1)<br>
=&gt;T(n) = 2T(n-1)<br>
=&gt;T(n) = 2ⁿ
<br><br>Quote利用<a class="internal-link" data-href="cut-and-paste.md" href="/考研筆記/演算法/ch3-dynamic-programming/cut-and-paste.html" target="_self" rel="noopener">cut-and-paste</a>可以證明有<a class="internal-link" data-href="Optimal structure.md" href="/考研筆記/演算法/ch3-dynamic-programming/optimal-structure.html" target="_self" rel="noopener">Optimal structure</a><br>r[n]:長度為n的rod之最大收益<br>
c[n]:長度為ｎ的rod的左大段切點，用於記錄在長度為n時的所有斷點從1~n依序算出最大收益<br>
r[n] = max{p1+ r[n-1], p2+ r[n-2], ....}<br>int* RodCuttingDP(p, n){
	new r[1..n+1]
	new c[1..n+1]
	r[0] = 0;
	for(int j = 0; j&lt;= n; j++){
		s = -無限;
		for(int i = 1; i&lt;=j; i++){
			if(s &lt; r[j-i]+p[i]){ //max{p1+ r[n-1], p2+ r[n-2], ....}
				s = r[j-i]+p[i];
				c[j] = i;
			}
		}
		r[j] = s;
	}
	return r
}
複製<br>Time Complexity: 𝝷(n²)<br>
<img alt="../../資料結構/img/截圖 2022-09-21 下午1.25.29.jpg" src="/lib/media/截圖-2022-09-21-下午1.25.29.jpg" style="width: 400px; max-width: 100%;"><br><br>重要性質：<a class="internal-link" data-href="Greedy Algorithm.md" href="/考研筆記/演算法/ch3-dynamic-programming/greedy-algorithm.html" target="_self" rel="noopener">Greedy Algorithm</a><br><br>給定n件物品I[1... n]其中第i艦隻價值為v[i]重量為w[i]，總負重限制&lt;W ，如何取物(每件物品可取部分)獲利最大？<br>
只需求出每件物品的單位價值，然後從單位價值最高的開始取，直到裝滿(&gt;= W)<br>
Time Complexity: T(n) = 𝝷(n log n) O(Sorting)+O(n)
<br><br>給定n件物品I[1... n]其中第i艦隻價值為v[i]重量為w[i]，總負重限制&lt;W ，如何取物(每件物品只能取或不取)獲利最大？<br>Quote具有<a class="internal-link" data-href="Optimal structure.md" href="/考研筆記/演算法/ch3-dynamic-programming/optimal-structure.html" target="_self" rel="noopener">Optimal structure</a>(證明略），但不具有<a class="internal-link" data-href="Greedy-choice property.md" href="/考研筆記/演算法/ch3-dynamic-programming/greedy-choice-property.html" target="_self" rel="noopener">Greedy-choice property</a>，因此不可用greedy algorithm策略<br>應用（相關思路）問題Let S be a set of n positive integers, and we are interested if we can select some of the integers from S so that their sum is exactly m. Explain in details how this can be done in O(nm)
Tip:看到「O(nm)」、「sum」聯想<br>
定義出S是關鍵

Ans:<br>
S(i, j) （前i個數字的情況下，「是否」可以取出sum = j）<br>
= S(i-1, )<br>s[i, k]表示在負重限制 k 之下，取前 i 個物品可達到的最大獲利<br>s[i, k] （在前i個物品中，裝進負重為k的包包的最大獲利）
= 0,                                     if i = 0 or k = 0
= s[i-1, k],                             if i != 0 and w[i] &gt; k (新物品絕對放不下)
= max{v[i]+ s[i-1, k- w[i]], s[i-1, k]}, if i != 0 and k&gt;= w[i] (放入或不放入新物品)
複製<br>//w不用sort
01-Knapsack(n, v, w, W){
	new s[0..n, 0..W] 
	for k = 0 to W
		s[0, k] = 0
	for i = 1 to n
		s[i, 0] = 0
		for k = 1 to W
			if k &lt; w[i]
				s[i, k] = s[i-1, k] 
			else
				s[i, k] = max{v[i]+s[i-1, k-w[i]], s[i-1, k]}
	return s[n, W]
}
複製<br>
KEY（填表時）:<br>
由左而右由上而下填表<br>
往下時，若新物品可放，往左邊w[i]格再上面一格的值+v[i] v.s 上面的值，反之則=上面那一格<br>
自己寫題目很耗時間
<br>Time Complexity: 𝝷(nW)<br>
<img src="/lib/media/截圖-2022-09-21-下午2.10.34.jpg"><br>Attention
<br>其並不是polynomial time，因為假設m = lg W，則W作為input需要O(lgW) = O(m)的空間 =&gt; 𝝷(nW) = 𝝷(n2ᵐ)，是指數成長<br>
但我們探討的是n的變化關係
<br>實際上01-knapsack是[<a class="internal-link" data-href="../CH6 NP-completeness/NP-complete.md" href="/考研筆記/演算法/ch6-np-completeness/np-complete.html" target="_self" rel="noopener">NP-complete</a>]問題
<br><br>給定n個矩陣Aᵢ, i= 1~n，其中Aᵢ的大小為p[i-1]*p[i]。以何種括號法計算可使得純量乘法次數最少<br>Quote設s[i, j]為計算Aᵢ成到A𝚓所需的最少純量乘法次數，討論最後一個括號(B x C的意思，B = Aᵢ~Ak, C 是剩下的)<br>
s[i, j]<br>
= 0                                                    , if i = j<br>
= min{s[i, k]+ s[k+1, j]+ p[i-1]p[k]p[j]},其中 i&lt;=k&lt;j , if i &lt; j<br><img alt="../../資料結構/img/截圖 2022-09-21 下午3.15.25.jpg" src="/lib/media/截圖-2022-09-21-下午3.15.25.jpg" style="width: 250px; max-width: 100%;"><br>
 MatrixChain.cpp<br>void MatrixChain(int p[4]){
	for(int i=0; i&lt;4; i++){
		cout &lt;&lt; i &lt;&lt; endl;
	}
	for(int i= 1; i&lt;= n; i++){
		s[i][i] = 0;
	}
	for(int l=2; l&lt;= n; l++){ //控制一次要處理幾個矩陣
		for(int i = 1; i&lt;= n-l+1; i++){
			int j = i+l-1;
			cout &lt;&lt; i &lt;&lt; ", " &lt;&lt; j &lt;&lt; endl;
			s[i][j] = s[i][i]+s[i+1][j]+p[i-1]*𝝷p[i]*p[j];
			for(int k=i; k&lt;= j; k++){
				int r = s[i][k]+s[k+1][j]+p[i-1]*p[k]*p[j];
				if(r &lt; s[i][j])
					s[i][j] = r;
					c[i][j] = k;
			}
		}
	}
}
複製<br>Time Complexity: 𝝷(n³)<br>
<img alt="../img/截圖 2022-09-21 下午4.47.01.jpg" src="/lib/media/截圖-2022-09-21-下午4.47.01.jpg" style="width: 300px; max-width: 100%;"><br><br><a class="internal-link" data-href="../../資料結構/CH9 Advanced Tree/OBST(optimal BST).md" href="/考研筆記/資料結構/ch9-advanced-tree/obst(optimal-bst).html" target="_self" rel="noopener">OBST(optimal BST)</a><br>
給定n個keys(k1 ~ kn)以及n+1個dummy key(d0 ~ dn)，假設ki被搜尋到的頻率/機率 為pi，di被搜尋到的頻率/機率 為qi ，如何建立一個expected search cost最小的binary search tree =&gt;Optical Binary Search Tree(OBST)
<br>expected search cost(ESC):<br>
"Root到某一點所經之路徑長" ＊ "該點出現頻率" （高度＊權重） 的所有點的總和<br>
深度1 =&gt; level 2 (root是level 1)<br>
ESC = ESC(左子樹)+ESC(右子樹)+w[整棵樹]<br>
<img alt="../img/截圖 2022-09-21 下午4.56.28.jpg" src="/lib/media/截圖-2022-09-21-下午4.56.28.jpg" style="width: 400px; max-width: 100%;"><br>w[i, j] = keyi...keyj的所有頻率總和<br>w[i, j]
= q[i-1],               if j = i-1 ~~沒有key~~
= w[i, j-1]+ p[j]+ q[j],if i &lt;= j ~~往右加了一層~~
複製<br>s[i, j] = keyi...keyj的建立的OBST's cost<br>
<img alt="../img/截圖 2022-10-15 下午3.38.10.jpg" src="/lib/media/截圖-2022-10-15-下午3.38.10.jpg" style="width: 300px; max-width: 100%;"><br>s[i, j]
= q[i-1],                          if j = i-1
= min{s[i, r-1]+s[r+1, j]+w[i, j]},if i &lt;= j。(i &lt;= r &lt;= j)
複製<br>最後+w[i, j]是因為高度加一<br>（填格子順序）w:從上而下，從左而右；s從左而右，從下而上。<br><img alt="../img/截圖 2022-10-15 下午4.33.07.jpg" height="500" src="/lib/media/截圖-2022-10-15-下午4.33.07.jpg" style="width: 500px; max-width: 100%;"><br>Example“../img/截圖 2022-10-15 下午4.42.53.jpg” could not be found.<br><br>給定X= &lt;x₁, ..., x𝑚&gt;, Y = &lt;y₁, ..., y𝒏&gt;,  Z = &lt;z₁, ..., z𝒌&gt;為三個字串<br>
若存在X的子序列=Y的子序列 = Z，則稱Z為X, Y的共同子序列<br>令X= &lt;x₁, ..., xᵢ&gt;, Y = &lt;y₁, ..., y𝚓&gt;,  Z = &lt;z₁, ..., z𝒌&gt;<br>
假設s[i, j] = k為 Xᵢ 與 Y𝚓之LCS長度<br>s[i, j]
= 0                        , if i=0 or j=0
= s[i-1, j-1]+1            , if i,j &gt;0 and xᵢ = y𝚓(目前已知的LCS)
= max{s[i, j-1], s[i-1, j]}, if i,j &gt; 0 and xᵢ!=y𝚓(用於繼承，但不知道是X還是Y那邊的)
複製<br>檢查Xi, Yj是否一樣，一樣就繼承當下的LCS並長度加一，否則繼承就好。<br>LCS(X, Y){
	//X,Y第一列 = 0
	n = Y.length
	m = X.length
	for i = 0 to n
		s[i, 0] = 0
		for j = 0 to m
			if X[i] == Y[j]
				//往左上，加長LCS
				s[i, j] = s[i-1, j-1] + 1
			else if s[i-1, j] &gt; s[i, j-1]
				//往上，繼承LCS
				s[i, j] = s[i-1, j]
			else 
				//往左，繼承LCS
				s[i, j] = s[i, j-1]
	return s
}
複製<br>(m= |X|, n = |Y|)<br>
Time complexity: 𝝷(mn)<br>圖表法<br>
<img alt="../img/截圖 2022-09-21 下午5.29.04.jpg" src="/lib/media/截圖-2022-09-21-下午5.29.04.jpg" style="width: 450px; max-width: 100%;"><br><br>找出Ａ中的最大遞增子序列<br>LCIS(A, B){
	Sort A and store the result in B
	return LCS(A, B)
}
複製<br>Time complexity: 𝝷(n log n) + 𝝷(n²) = 𝝷(n²)<br><br>找出最長的共同子字串<br>
key: 和LCS差在，判斷X[i] 和Y[j]關係時，若 != s[i, j] =0
<br>LCSubstring(X, Y){
	m = X.length
	n = Y.length
	length = 0
	new s[0..m, 0..n]

	for j = 0 to n:
		s[0, j] = 0
	for i = 0 to m
		s[i, 0] = 0
		for j = 0 to m:
			if X[i] == Y[j]
				s[i, j] = s[i-1, j-1]
				length = max{length, s[i, j]}
			else
				s[i, j] = 0
	return length	
}
複製<br>Time: 𝝷(mn) ?<br><br>最長回文子序列<br>QuoteL(i, j)代表s[i..j]的最長回文子序列的長度，n = X.length<br>
L(i, j)<br>
= max{ L(i,  j-1), L(i+1,  j) }, if i&gt;0 &amp; j&gt; 0<br>
= 0, if i = j+1<br>
= 1, if i = j<br>
= L(i+1, j-1)+2, if i &lt; j &amp; s[i] == s[j]

對角線 = 1<br>
左下半 = 0<br>
其餘：注意

<br>if s[i] == s[j] ，左下+2 (L(i+1, j-1)+2)
<br>if s[i] != s[j] ，左 V.S 下 取大者

<br><img alt="../img/截圖 2022-09-25 下午5.55.24.jpg" src="/lib/media/截圖-2022-09-25-下午5.55.24.jpg" style="width: 500px; max-width: 100%;"><br>
Time: 𝝷(n²)<br><br>最短改動距離(cost)<br>
假設有兩個字串A, B（長不為m, n），求如何用下列三個運算變成一樣的字串<br>
Deletion: 刪除一元素，cost = 1<br>
Insertion:加入一個元素，cost =2<br>
Substitution: 更改一個元素，cost = 3<br>Tipc[i, j] = A[1..i]和B[1..j]的M.E.D<br>
遞迴關係：

<br>if A[i] == B[j] =&gt; c[i, j] = c[i-1, j-1]
<br>if A[i] != B[j]

<br>if 


<br><br>Knuth-Morris-Pratt<br>
給定T[1..n]為一篇文章，P[1...m]為一段字串，m&lt;= n，找出所有的P在T中之<a class="internal-link" data-href="valid shift.md" href="/考研筆記/演算法/ch3-dynamic-programming/valid-shift.html" target="_self" rel="noopener">valid shift</a><br>若以暴力法求解，Time: O(mn)<br>
有別於暴力法每次將pattern右移一個位子再做比對。KMP可以利用已比對的資料一次位移多個位置<br>Pk = P[1..k]<br>
PrefixFunction<br>
首先定義𝝅[k] = "Pk之suffix(後面開始的子字串)與P之prefix 可配對的最大長度"也就是P[1~k-1]和P[2~k]的重疊程度。<br>
用於決定遇到T[i]!= P[k]時需要shift到哪
failure function: 𝝅[k]的值-1 而且index從 0 開始
<br><img src="/lib/media/截圖-2022-09-30-上午10.46.38.jpg"><br>PrefixFunction(P){
	m = P.length;
	new(𝝅[1..m])
	𝝅[1] = 0;
	k = 0;
	for i = 2 to m:
		while k &gt;0 and P[k+1]!= P[i]: //若P[k+1]與P[i]不同，則代表在Pi這段與Pk只能match到這
			k = 𝝅[k];	
		if P[k+1] = P[i]:
			k = k+1;
		𝝅[i] = k;
}
複製<br>KMP(T, P){
	n = T.length
	m = P.length;
	𝝅 = PrefixFunction(P);
	k = 0;
	for i = 2 to m:
		while k &gt;0 and P[k+1]!= T[i]: //直到shift後的下一位數相等（P[k+1] == T[i]）或是k = 0（完全shift）
			k = 𝝅[k];	
		if P[k+1] = T[i]://相同長度加一
			k = k+1;
		if k == m:
			print "valid shift", i-m;
			k = 𝝅[k];
}
複製<br><img src="/lib/media/截圖-2022-09-30-上午11.06.56.jpg"><br>分析<br>
Time: O(m+n)<br>
有while看次花很久時間，但根據Amortized analysis，定多O(n)，PrefixFunction同理O(m)<br>應用問題使用KMP辨認string S is cyclic rotation of another string?<br>
(ex: tea and eat is cyclic of each other)

令T = S strcat S ，用KMP的pattern mathing，若存在match &lt;=&gt; 是cyclic]]></description><link>考研筆記/演算法/ch3-dynamic-programming/ch3-dynamic-programming.html</link><guid isPermaLink="false">考研筆記/演算法/CH3 Dynamic Programming/CH3 Dynamic Programming.md</guid><pubDate>Wed, 13 Mar 2024 09:17:43 GMT</pubDate><enclosure url="lib/media/截圖-2022-09-21-下午1.25.29.jpg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib/media/截圖-2022-09-21-下午1.25.29.jpg&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[cut-and-paste]]></title><description><![CDATA[ 
 <br><br>以求shortest path 問題為例。<br>shortest path若具有cut-and-paste性質，設P為shortest path，則P中的所有從a-&gt;b點的shortest subpath。
矛盾證明<br>
若p為一條shortest path<br>
若存在一條subpath p1(a -&gt; b, 不為shortestpath)<br>
令p2為一條a-&gt;b的shortest path，則p2 &lt; p1<br>
令P'為換成經過p2的路徑，p' &lt; p<br>
發現更短的路徑<br>
=&gt;矛盾]]></description><link>考研筆記/演算法/ch3-dynamic-programming/cut-and-paste.html</link><guid isPermaLink="false">考研筆記/演算法/CH3 Dynamic Programming/cut-and-paste.md</guid><pubDate>Wed, 13 Mar 2024 09:22:42 GMT</pubDate></item><item><title><![CDATA[Fibonacci number]]></title><description><![CDATA[ 
 ]]></description><link>考研筆記/演算法/ch3-dynamic-programming/fibonacci-number.html</link><guid isPermaLink="false">考研筆記/演算法/CH3 Dynamic Programming/Fibonacci number.md</guid><pubDate>Wed, 13 Mar 2024 09:21:22 GMT</pubDate></item><item><title><![CDATA[Greedy Algorithm]]></title><description><![CDATA[ 
 <br>Greedy Algorithm策略：在每個階段選擇當下的最佳解<br>
若問題可以以Greedy Algo.解之，則具有下列兩性質

<br><a class="internal-link" data-href="Optimal structure.md" href="/考研筆記/演算法/ch3-dynamic-programming/optimal-structure.html" target="_self" rel="noopener">Optimal structure</a>
<br><a class="internal-link" data-href="Greedy-choice property.md" href="/考研筆記/演算法/ch3-dynamic-programming/greedy-choice-property.html" target="_self" rel="noopener">Greedy-choice property</a>
]]></description><link>考研筆記/演算法/ch3-dynamic-programming/greedy-algorithm.html</link><guid isPermaLink="false">考研筆記/演算法/CH3 Dynamic Programming/Greedy Algorithm.md</guid><pubDate>Wed, 13 Mar 2024 09:21:28 GMT</pubDate></item><item><title><![CDATA[Greedy-choice property]]></title><description><![CDATA[ 
 <br>Greedy-choice property在每個階段選擇當現階段之最佳解，最終可得全域之最佳解]]></description><link>考研筆記/演算法/ch3-dynamic-programming/greedy-choice-property.html</link><guid isPermaLink="false">考研筆記/演算法/CH3 Dynamic Programming/Greedy-choice property.md</guid><pubDate>Mon, 04 Mar 2024 08:07:57 GMT</pubDate></item><item><title><![CDATA[Optimal structure]]></title><description><![CDATA[ 
 <br>Optimal substructure當一個問題最佳解是由子問題之最佳解所構成，稱之。<br>
欲證一個問題有optimal substructure 可以利用<a class="internal-link" data-href="cut-and-paste.md" href="/考研筆記/演算法/ch3-dynamic-programming/cut-and-paste.html" target="_self" rel="noopener">cut-and-paste</a>的方法論述
若有此性質時，該問題之遞迴解時容易產生多個overlapping subproblem。所以須以bottom-up的方式計算所有子問題之解恰一次並儲存下來以供後續使用]]></description><link>考研筆記/演算法/ch3-dynamic-programming/optimal-structure.html</link><guid isPermaLink="false">考研筆記/演算法/CH3 Dynamic Programming/Optimal structure.md</guid><pubDate>Wed, 13 Mar 2024 09:20:41 GMT</pubDate></item><item><title><![CDATA[valid shift]]></title><description><![CDATA[ 
 <br><br>即所有字串P在文中T中出現的所有位置。<br>
若T[s+1...s+m] = P[1..m], 0&lt;= s &lt;= n-m，s即為valid shift。]]></description><link>考研筆記/演算法/ch3-dynamic-programming/valid-shift.html</link><guid isPermaLink="false">考研筆記/演算法/CH3 Dynamic Programming/valid shift.md</guid><pubDate>Wed, 13 Mar 2024 09:23:41 GMT</pubDate></item><item><title><![CDATA[Bellman-Ford algorithm]]></title><description><![CDATA[<a class="tag" href="?query=tag:⭐️⭐️⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️⭐️⭐️</a> 
 <br>全部一起更新拉！<br>
<a href=".?query=tag:⭐️⭐️⭐️⭐️⭐️" class="tag" target="_blank" rel="noopener">#⭐️⭐️⭐️⭐️⭐️</a> <br>
核心概念為每一輪對圖上的每一條邊做 relaxationn-1次，則最終必可依序relax的圖上所有s到ui之最點路徑中的邊<br>
!!由於s到任一點的最短距離所經過的邊數必 &lt;= n-1
<br>Attention
<br>允許有負邊
<br>當然不能有負環
<br>BellmanFord(G, w, s){
	InitializationSingleSource(G, s);
	n = |G.V|;
	for i = 1 to n-1 // 做n-1次
		for each (u, v) ∈ G.E //對每一個邊relax
			Relax(u, v, w);
	//判斷負cycle
	for each (u, v) ∈ G.E
		if v.d &gt; u.d + w(u, v)
			return false;
	return true;
}
複製<br><img alt="../img/截圖 2022-10-27 下午10.00.43.jpg" src="/lib/media/截圖-2022-10-27-下午10.00.43.jpg" style="width: 400px; max-width: 100%;"><br>
<img alt="../img/截圖 2022-10-27 下午10.00.27.jpg" src="/lib/media/截圖-2022-10-27-下午10.00.27.jpg" style="width: 400px; max-width: 100%;"><br>分析<br>
可用於檢查有無負cycle:多跑一次Bellman-Ford，若有任何一點變短-&gt;有負cycle<br><br>(使用<a class="internal-link" data-href="../../資料結構/CH6 Graph/Adjacency List.md" href="/考研筆記/資料結構/ch6-graph/adjacency-list.html" target="_self" rel="noopener">Adjacency List</a>的情況)<br><br>
定義：<br>
Distᴷ[1..n] of int;<br>
其中Distᴷ[i]:代表起點且經過的邊數需&lt;=k
<br>step:<br>
<br>Dist¹[1..n]即為Cost Matrix中 起點那一列元素值
<br>依序求出 Distᴷ[1..n]
<br><a class="internal-link" data-href="DP Bellman-Ford algorithm.md" href="/考研筆記/演算法/ch4-graph-algorithms/dp-bellman-ford-algorithm.html" target="_self" rel="noopener">DP Bellman-Ford algorithm</a><br>
distᴷ[j]<br>
= w[0, j], if k =1<br>
= min{distᴷ⁻¹[j], min{distᴷ⁻¹[i]+w[i, j]}}, if k &gt; 1]]></description><link>考研筆記/演算法/ch4-graph-algorithms/bellman-ford-algorithm.html</link><guid isPermaLink="false">考研筆記/演算法/CH4 Graph Algorithms/Bellman-Ford algorithm.md</guid><pubDate>Wed, 13 Mar 2024 09:19:52 GMT</pubDate><enclosure url="lib/media/截圖-2022-10-27-下午10.00.43.jpg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib/media/截圖-2022-10-27-下午10.00.43.jpg&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[BFS]]></title><description><![CDATA[<a class="tag" href="?query=tag:ch6" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#ch6</a> 
 <br><img alt="../img/截圖 2022-10-15 下午4.59.16.jpg" src="/lib/media/截圖-2022-10-15-下午4.59.16.jpg" style="width: 500px; max-width: 100%;"><br>演算法<br>Enqueue(Q, s)
while(Q != Nil){
	u = Dequeue(Q)
	for v in adj[u]:
		if v.color == while
			//塗成灰色
			v.d = u.d+1
			v.𝝅 = u
			Enqueue(Q, s)
	u.color = black
}
複製<br>Time 分析：<br>
<br>利用adjacency list 來儲存G，每個點進到Queue一次，每個邊進到演算法一次（有向圖2次）=&gt; O(|V|+|E|)
<br>利用adjacency matrix儲存G，時間為 =&gt; O(|V|²)
<br>可用來檢查G是否為connected<br><br>
<br>s到各點的最短距離 ( = 𝛿(s, v))
<br>是否為connected
<br>Diameter:求出u, v（G中距離最遠的兩點），以及u, v的最短距離。<br>
<img alt="../img/截圖 2022-10-15 下午5.15.53.jpg" src="/lib/media/截圖-2022-10-15-下午5.15.53.jpg" style="width: 400px; max-width: 100%;">
<br>可在O(V時間內解決)，是 #<a class="internal-link" data-href="../CH6 NP-completeness/NP-complete.md" href="/考研筆記/演算法/ch6-np-completeness/np-complete.html" target="_self" rel="noopener">NP-complete</a> <a href=".?query=tag:ch6" class="tag" target="_blank" rel="noopener">#ch6</a><br><br>BFS(v){
	visited[v] = True;//algo: 塗灰
	create Q(Q);
	Enqueue(Q, v);
	while(!IsEmpty(Q)){
		v = Dequeue(Q);
		for each u in W[v]{//加入u下面的Node
			if(!visited[u]){
				visited[u] = True;//algo: 塗灰
				Enqueue(Q, u);//存下下一層
			}
		}
		//v點的children都拜訪完了
	}
}
複製<br>Note<a class="internal-link" data-href="../CH5 Tree and Binary Tree/CH5 Tree and Binary Tree.md#Binary traversal" href="/CH5 Tree and Binary Tree/CH5 Tree and Binary Tree.md#Binary traversal" target="_self" rel="noopener">B.T之Level order Traversal</a>即是圖形的BFS<br>Time:O(V+E) (使用adjacency list)]]></description><link>考研筆記/演算法/ch4-graph-algorithms/bfs.html</link><guid isPermaLink="false">考研筆記/演算法/CH4 Graph Algorithms/BFS.md</guid><pubDate>Wed, 13 Mar 2024 09:46:31 GMT</pubDate><enclosure url="lib/media/截圖-2022-10-15-下午4.59.16.jpg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib/media/截圖-2022-10-15-下午4.59.16.jpg&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[CH4 Graph Algorithms]]></title><description><![CDATA[<a class="tag" href="?query=tag:⭐️⭐️⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️⭐️⭐️</a> <a class="tag" href="?query=tag:⭐️⭐️⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️⭐️⭐️</a> <a class="tag" href="?query=tag:⭐️⭐️⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️⭐️⭐️</a> <a class="tag" href="?query=tag:離散數學" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#離散數學</a> <a class="tag" href="?query=tag:⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️</a> 
 <br>在這章節基本上都用adjecency list儲存G<br><a class="internal-link" data-href="../../資料結構/CH6 Graph/CH6 Graph.md" href="/考研筆記/資料結構/ch6-graph/ch6-graph.html" target="_self" rel="noopener">資料結構CH6 Graph</a><br><br><br><br><br>
定義：G=(V, E)為一個directed weighted graph，function w(P)為路徑P上的所有邊的權重合<br>
𝛿(u, v)= u~ v的路徑中的最小權重和<br>
若P為u ~ v，且滿足w(P) = 𝛿(u, v)，則稱P為最短路徑<br>
給定一點s，求s到個點的最短路徑即為The single-source shortest paths problem
<br>
<br>T為以s 為Root的Tree，s到tree中的node皆為最短路徑，則稱T為shortest-path tree
<br>v.d為s到v的最短路徑估算值
<br><br><br><br><br><br><a class="internal-link" data-href="../CH3 Dynamic Programming/CH3 Dynamic Programming.md" href="/考研筆記/演算法/ch3-dynamic-programming/ch3-dynamic-programming.html" target="_self" rel="noopener">CH3 Dynamic Programming</a><br>
在G=(V, E)的directed weighted graph中，求出u~v的最短路徑
<br>利用（對每個點(n次)都做一次single source shortest path）<br>
<br><a class="internal-link" data-href="Dijkstra's algorithm.md" href="/考研筆記/演算法/ch4-graph-algorithms/dijkstra's-algorithm.html" target="_self" rel="noopener">Dijkstra's algorithm</a>花費：O(|V|³)
<br><a class="internal-link" data-href="Bellman-Ford algorithm.md" href="/考研筆記/演算法/ch4-graph-algorithms/bellman-ford-algorithm.html" target="_self" rel="noopener">Bellman-Ford algorithm</a>花費:O(|V|⁴)
<br><br><br><br><a href=".?query=tag:離散數學" class="tag" target="_blank" rel="noopener">#離散數學</a><br><br><br>
給定一個directed weighted graph，具有s(source), t(sink)兩點，且滿足任意v ∈ V，s-&gt;v-&gt;t皆存在任意點皆可到t＆被s連到<br>
令：

<br>c(u, v)：u-&gt;v的容量
<br>f(u, v)：u-&gt;v的流量
<br>augmenting path: 一s-&gt;v的路徑，滿足路徑上所有邊的flow &lt; capacity，並將流量充滿

capacity constraint : 0 ≤ f(u, v) ≤ c(u, v)<br>
每一點的流入=流出<br>
求最大value之flow為何？∑ᵥf(s, v)
<br>Cut<br>
<br>若(S, T)是V之partition，即S∪T = V &amp; S∩T = ∅ 又s ∈ S, t∈T，則稱(S, T)是G之一cut<br>
令c(S, T) = ∑ᵤ∑ᵥc(u, v)，稱c(u, v)為cut(S, T)之capacity
<br>Time 分析:<br>
設𝒇* 為maximum flow (整數)，每一輪flow至少加一，所以while最多執行  O(|𝒇*|)<br>
另外利用 BFS or DFS 可求出一條augmenting path<br>
-&gt;O(|𝒇*|(|V|+|E|)) = O(|𝒇*||E|)<br><br>minimum-cut 可以找出Max-flow<br>
下列敘述等價：<br>
<br>𝒇 為G之maximum flow
<br>G𝙛中不含augmenting path 反向為空
<br>存在一個cut(S', T')使得 |𝒇| = cut(S', T') 可以切出最大流量
<br><br>有往回指的流向<br><img alt="../../資料結構/img/截圖 2022-11-02 下午3.35.47.jpg" src="/lib/media/截圖-2022-11-02-下午3.35.47.jpg" style="width: 500px; max-width: 100%;"><br><br><a class="internal-link" data-href="BFS.md" href="/考研筆記/演算法/ch4-graph-algorithms/bfs.html" target="_self" rel="noopener">BFS</a>  -&gt; Ford-Fullkerson ，改變走流向的次序<br>
Ford-Fulkerson 的特例<br>
每回合皆以BFS選取augmenting path-&gt;每次選取邊數最少的path，此法保證while至多執行O(|V||E|)<br>
-&gt; O(|V||E|(|V|+|E|)) = O(|V||E|²)
<br><br>三種轉換方法：<br>
<img alt="../../資料結構/img/截圖 2022-11-02 下午3.55.32.jpg" src="/lib/media/截圖-2022-11-02-下午3.55.32.jpg" style="width: 400px; max-width: 100%;">]]></description><link>考研筆記/演算法/ch4-graph-algorithms/ch4-graph-algorithms.html</link><guid isPermaLink="false">考研筆記/演算法/CH4 Graph Algorithms/CH4 Graph Algorithms.md</guid><pubDate>Wed, 13 Mar 2024 09:20:39 GMT</pubDate><enclosure url="lib/media/截圖-2022-11-02-下午3.35.47.jpg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib/media/截圖-2022-11-02-下午3.35.47.jpg&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[DAG-Shortest-path]]></title><description><![CDATA[ 
 <br>安排順序，更新答案<br>
主要想法是依照<a class="internal-link" data-href="Topological Sort.md" href="/考研筆記/演算法/ch4-graph-algorithms/topological-sort.html" target="_self" rel="noopener">Topological Sort</a>的順序對圖上每一點連出去的邊作relaxation<br>
則<a class="internal-link" data-href="Bellman-Ford algorithm.md" href="/考研筆記/演算法/ch4-graph-algorithms/bellman-ford-algorithm.html" target="_self" rel="noopener">Bellman-Ford algorithm</a>中的迴圈只需執行一次<br>
-&gt;求<a class="internal-link" data-href="Topological Sort.md" href="/考研筆記/演算法/ch4-graph-algorithms/topological-sort.html" target="_self" rel="noopener">Topological Sort</a>&amp;對每邊作relaxation 皆可在𝝷(|V|+|E|)
<br>Tip
<br>Topological Sort（排序）
<br>對排完順序的點依序Relax
<br>DAGShortestPath(G, w, s){
	v = TopologicalSort(G, s);
	InitializaeSingleSource(G, s);
	for i = 1 to n
		for each v in adj[v[i]]
			Relax(v[i], v, w);
}
複製]]></description><link>考研筆記/演算法/ch4-graph-algorithms/dag-shortest-path.html</link><guid isPermaLink="false">考研筆記/演算法/CH4 Graph Algorithms/DAG-Shortest-path.md</guid><pubDate>Wed, 13 Mar 2024 09:22:03 GMT</pubDate></item><item><title><![CDATA[DFS]]></title><description><![CDATA[ 
 <br>
discovery time u.d<br>
finishing time u.f<br>
u.color

<br>white: undiscovered
<br>gray: discovered but 有子點is undiscovered(while)
<br>black:子點皆finished

<br>DFSVisit(G, u){
	t = t+1;
	u.d = t;
	u.color = gray;
	for each v ∈ G.adj[u]{
		if v.color = white{
			v.𝝅 = u;
			DFSVisit(G, v);
		}
	}
	u.color = black;
	t = t+1;
	u.f = t;
}
DFS(G){
	for each u ∈ G.V{
		u.color = white;
		u.𝝅 = ♾;
	}
	t = 0;
	for each u ∈ G.V{
		if u.color = white{
			DFSVisit(G, u);
		}
	}
}
複製<br>Time:𝝷(|V|+|E|)**<br><br>在執行DFS的過程中將每個edge分類：<br>
<br>Tree edge: if v.𝝅 = u (u到v的邊)parent關係
<br>Back edge: 在forest中，v是u的上輩（含loop）
<br>Forward edge:在forest中，v是u的孫子。(遇到黑色，u的discover比v小)
<br>Cross edge: 其他（跨越不同 樹/樹枝 的）(遇到黑色，u的discover比v大)
<br>
在undirected graph中，G只有tree edge&amp;back edge<br>
沒有cycle &lt;=&gt; 沒有back edge
<br><br>
<br>判斷是否connected
<br>判斷是否為acyclic(下一個檢查的點是灰色/Back-edge的就是cycle)。但是無向圖中可能誤判（必須要判斷v.𝝅）
<br>在 directed acyclic graph(DAG)上找出一個<a class="internal-link" data-href="Topological Sort.md" href="/考研筆記/演算法/ch4-graph-algorithms/topological-sort.html" target="_self" rel="noopener">Topological Sort</a>
<br>directed graph 中找出所有<a class="internal-link" data-href="strongly connected component.md" href="/考研筆記/演算法/ch4-graph-algorithms/strongly-connected-component.html" target="_self" rel="noopener">strongly connected component(SCC)</a>
<br>undirected graph中找出<a class="internal-link" data-href="../../資料結構/CH6 Graph/Biconnected component.md" href="/考研筆記/資料結構/ch6-graph/biconnected-component.html" target="_self" rel="noopener">biconnected component</a> 與 <a class="internal-link" data-href="../../資料結構/CH6 Graph/Articulation point.md" href="/考研筆記/資料結構/ch6-graph/articulation-point.html" target="_self" rel="noopener">articulation point</a>
<br><br><a class="internal-link" data-href="../../資料結構/CH6 Graph/CH6 Graph.md" href="/考研筆記/資料結構/ch6-graph/ch6-graph.html" target="_self" rel="noopener">CH6 Graph</a><br>
皆為無向圖<br>
visited[1..n] of Boolean
<br>DFS(v:strat vertex){
	visited[v] = True;//algov塗呈灰色
	for each vertex w adjancent to v do{
		if (not visited[w])//algo: w如果是白色
			DFS(w);
	}
	//algo: 塗成黑色
}
複製<br>Note
<br>DFS order並不唯一
<br>通常會規定頂點編號小者優先
]]></description><link>考研筆記/演算法/ch4-graph-algorithms/dfs.html</link><guid isPermaLink="false">考研筆記/演算法/CH4 Graph Algorithms/DFS.md</guid><pubDate>Wed, 13 Mar 2024 09:46:33 GMT</pubDate></item><item><title><![CDATA[Dijkstra's algorithm]]></title><description><![CDATA[<a class="tag" href="?query=tag:⭐️⭐️⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️⭐️⭐️</a> 
 <br><a href=".?query=tag:⭐️⭐️⭐️⭐️⭐️" class="tag" target="_blank" rel="noopener">#⭐️⭐️⭐️⭐️⭐️</a><br>
一邊往當下最短外圍連，一邊更新最短距離<br><a class="internal-link" data-href="../CH3 Dynamic Programming/Greedy Algorithm.md" href="/考研筆記/演算法/ch3-dynamic-programming/greedy-algorithm.html" target="_self" rel="noopener">Greedy Algorithm</a><br>Attention
<br>不允許有負邊
<br>當然不能有負環
<br>InitializeSingleSource(G, s){
	for each v in G.V{
		v.d = 無限;
		v.𝝅 = nil;
	}
	s.d = 0;
}
Relax(u, v, w){
//用於更新v.d
	if(v.d &gt; u.d+w(u, v)){
		v.d = u.d+w(u, v);
		v.𝝅 = u;//更新parent
	}
}
Dijkstra(G, s){
	InitializeSingleSource(G, s);
	S = {s};//搜集已確認的點
	let Ｑ= 紀錄所有點的Queue，key為v.d
	while(Q非空){
		u = ExtractMin(Q);//最小的v.d 拿出來
		//不用擔心會有cycle，因為v拜訪過後就不再Q裡面，不會再取出
		S = S 𝖴 {u};
		for each v ∈ G.adj[u]{//更新周圍的點
			Relax(u, v, w);
		}
	}
}
複製<br>Tip
<br>找目前(已經連到的）最小v.d的點儲存在u
<br>把u設為已確定（不會再檢查u)
<br>更新u周圍的點
<br><br>(迴圈*每一次Extract-Min + Relax次數*Relax時間)<br>
Relax次數：O(|E|)。（發現每個邊剛好被檢查1次)<br>
<br>使用array: O(|V|²+|E|) = O(|V|²)
<br>使用<a class="internal-link" data-href="../../資料結構/CH5 Tree and Binary Tree/CH5 Tree and Binary Tree.md#Heap ⭐️⭐️⭐️⭐️⭐️" href="/考研筆記/資料結構/ch5-tree-and-binary-tree/ch5-tree-and-binary-tree.html#Heap_⭐️⭐️⭐️⭐️⭐️" target="_self" rel="noopener">binary heap</a>: O(|V|lg|V|+|E|lg|V|) = O(|E| lg |V|)
<br>使用<a class="internal-link" data-href="../../資料結構/CH9 Advanced Tree/Fibonacci Heap.md" href="/考研筆記/資料結構/ch9-advanced-tree/fibonacci-heap.html" target="_self" rel="noopener">Fibonacci Heap</a>: O(|V|*lg|V|+|E|)
<br>使用Binomial Heap: O(|E|log|V|
<br><br>Example“../img/截圖 2022-10-27 下午8.58.44.jpg” could not be found.<br><br>
<br>relax順序不影響結果（可用數歸法證明）
<br>s到任一點的最短距離所經過的邊數必 &lt;= n-1 !!重要
]]></description><link>考研筆記/演算法/ch4-graph-algorithms/dijkstra&apos;s-algorithm.html</link><guid isPermaLink="false">考研筆記/演算法/CH4 Graph Algorithms/Dijkstra&apos;s algorithm.md</guid><pubDate>Wed, 13 Mar 2024 09:20:47 GMT</pubDate></item><item><title><![CDATA[DP Bellman-Ford algorithm]]></title><description><![CDATA[ 
 <br>DP Bellman-Ford algorithm<br>k: 走到第幾的邊（前面迴圈的次數）<br>distᴷ[j]<br>
= w[0, j], if k =1<br>
= min{distᴷ⁻¹[j], min{distᴷ⁻¹[i]+w[i, j]}}, if k &gt; 1<br>
(min{ {上一輪紀錄的shortest path length}, {中間經過點 i 的path })<br>Tip
<br>可畫出w的表方便運算
<br>min{之前（上一層）的自己, 上一層的其他點連到自己}
<br><img alt="../img/截圖 2022-10-27 下午10.06.49.jpg" src="/lib/media/截圖-2022-10-27-下午10.06.49.jpg" style="width: 500px; max-width: 100%;">]]></description><link>考研筆記/演算法/ch4-graph-algorithms/dp-bellman-ford-algorithm.html</link><guid isPermaLink="false">考研筆記/演算法/CH4 Graph Algorithms/DP Bellman-Ford algorithm.md</guid><pubDate>Wed, 13 Mar 2024 09:16:41 GMT</pubDate><enclosure url="lib/media/截圖-2022-10-27-下午10.06.49.jpg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib/media/截圖-2022-10-27-下午10.06.49.jpg&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Floyd-Warshall algorithm]]></title><description><![CDATA[<a class="tag" href="?query=tag:⭐️⭐️⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️⭐️⭐️</a> 
 <br><a href=".?query=tag:⭐️⭐️⭐️⭐️⭐️" class="tag" target="_blank" rel="noopener">#⭐️⭐️⭐️⭐️⭐️</a> <br>
求All pairs of vertix
<br>有向圖<br>
可以有cycle<br>
可有負邊<br><br>
相臨矩陣w[i, j]<br>
D = [d[i, j]] (d[i, j] = 𝛿(i, j))<br>
𝛿(u, v)= u~v的路徑中的最小權重和<br>
∏ = 𝝅[i, j] :從i到j的倒數第二個點
<br>Tip所有的邊同時一起跑。計算i-&gt;j時，比較i-&gt;k-&gt;j, k=1 ~ n。即可求出所有解<br>
Dᴷ[i, j] = min{Dᴷ⁻¹[i, j], Dᴷ⁻¹[i, k]+Dᴷ⁻¹[k, j]}<br><img alt="../../資料結構/img/截圖 2022-11-02 上午10.09.36.jpg" src="/lib/media/截圖-2022-11-02-上午10.09.36.jpg" style="width: 550px; max-width: 100%;"><br>
Time<br>
O(|V|³)<br>可用來求<a class="internal-link" data-href="transitive closure" href="/考研筆記/演算法/ch4-graph-algorithms/transitive-closure.html" target="_self" rel="noopener">transitive closure</a><br><br>
Aᴷ: nxn matrix, n = |V|, v = {1, 2, 3, ..., n}，A⁰是成本矩陣<br>
其中Aᴷ[i, j] = i-&gt; j的shortest path length，途中經過的頂點編號&lt;= k<br>
同演算法版本
]]></description><link>考研筆記/演算法/ch4-graph-algorithms/floyd-warshall-algorithm.html</link><guid isPermaLink="false">考研筆記/演算法/CH4 Graph Algorithms/Floyd-Warshall algorithm.md</guid><pubDate>Mon, 04 Mar 2024 08:08:36 GMT</pubDate><enclosure url="lib/media/截圖-2022-11-02-上午10.09.36.jpg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib/media/截圖-2022-11-02-上午10.09.36.jpg&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Johnson's algorithm]]></title><description><![CDATA[ 
 <br>彌補Dijkstra的「不能有負邊」缺點<br>
使用reweighting，調整權重皆為非負，再利用<a class="internal-link" data-href="Dijkstra's algorithm.md" href="/考研筆記/演算法/ch4-graph-algorithms/dijkstra's-algorithm.html" target="_self" rel="noopener">Dijkstra's algorithm</a>計算(n次)
<br>Time:O(|V|²lg|V| +|V||E|)<br>
當G為sparse時，此方法比<a class="internal-link" data-href="Floyd-Warshall algorithm.md" href="/考研筆記/演算法/ch4-graph-algorithms/floyd-warshall-algorithm.html" target="_self" rel="noopener">Floyd-Warshall algorithm</a>有效率<br><br>保證成立：<br>
<br>reweight後的最短路徑 = 原圖的最短路徑
<br>原圖沒有負環 -&gt; reweight後應沒有負環
<br>reweight後的所有邊的權重皆非負
<br>
新的w(u-&gt;v) = 原本的w(u-&gt;v) + {s到起點 s-&gt;u} - {s到終點 s-&gt;v}<br>
ŵ(u, v) = w(u, v) + 𝛿(s, u) - 𝛿(s, v)
]]></description><link>考研筆記/演算法/ch4-graph-algorithms/johnson&apos;s-algorithm.html</link><guid isPermaLink="false">考研筆記/演算法/CH4 Graph Algorithms/Johnson&apos;s algorithm.md</guid><pubDate>Wed, 13 Mar 2024 09:21:31 GMT</pubDate></item><item><title><![CDATA[strongly connected component]]></title><description><![CDATA[ 
 <br><br>Tip觀察＆假設

<br>component graph G'=(V', E')，任意Vi ∈V', Vi = Ci,且Ci和Cj之間必有一路徑
<br>觀察到G'必為DAG，因為if G'有cycle，此cycle經過的點應屬於同一個component


ALGO.

<br>對G做DFS(起點不重要)
<br>觀察到：G'中，(Vi, Vj)∈E'(Ｃi-&gt;Ｃj，Cj先結束)，則finish_time(Ci) &gt; finish_time(Cj)(後代要先結束，才會跑到parent)
<br>若反過來跑，DFS(Gᵀ)，會先走完Ci，且發現Ci走不到Cj
<br>
給定一G=(V, E)為一個有向圖，若C ⊆ V為maxiaml 滿足⦡u, v ∈C，存在路徑可從v-&gt;u &amp;u-&gt;v，即為strongly connected component
<br><img alt="../img/截圖 2022-10-15 下午10.57.30.jpg" src="/lib/media/截圖-2022-10-15-下午10.57.30.jpg" style="width: 400px; max-width: 100%;"><br>
可以發現component graph(圖中Ｇ‘) 必為DAG（因為弱G'具有cycle，則該cycle經過的點對應回G，應再組合成一個component）。<br>
<img alt="../img/截圖 2022-10-15 下午11.04.33.jpg" src="/lib/media/截圖-2022-10-15-下午11.04.33.jpg" style="width: 500px; max-width: 100%;"><br><br>SCC(G){
	執行DFS(G)求出v.f（最後一個結束的點）
	執行DFS(Gᵀ)，以DFS(G)求出的finish time從大道小依序選點
	return DFS(Gᵀ)的depth-first forest，其中每一個forest是一個SCC
}
複製]]></description><link>考研筆記/演算法/ch4-graph-algorithms/strongly-connected-component.html</link><guid isPermaLink="false">考研筆記/演算法/CH4 Graph Algorithms/strongly connected component.md</guid><pubDate>Wed, 13 Mar 2024 09:15:57 GMT</pubDate><enclosure url="lib/media/截圖-2022-10-15-下午10.57.30.jpg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib/media/截圖-2022-10-15-下午10.57.30.jpg&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Topological Sort]]></title><description><![CDATA[ 
 <br><br>可用於安排工作順序<br>只有<a class="internal-link" data-href="DAG-Shortest-path.md" href="/考研筆記/演算法/ch4-graph-algorithms/dag-shortest-path.html" target="_self" rel="noopener">DAG-Shortest-path</a>的Topological Sort(拓撲排序)才有意義。因為根據定義，再有cycle 的情況下，前後順序會變得沒有意義<br>Topological-Sort(G){
	//宣告一個linked list L
	//執行DFS，在v塗黑時，將v插到linked list 前端。
	return L
}
複製<br>Time: O(V+E)]]></description><link>考研筆記/演算法/ch4-graph-algorithms/topological-sort.html</link><guid isPermaLink="false">考研筆記/演算法/CH4 Graph Algorithms/Topological Sort.md</guid><pubDate>Wed, 13 Mar 2024 09:22:37 GMT</pubDate></item><item><title><![CDATA[transitive closure]]></title><description><![CDATA[ 
 <br>
有無存在i-&gt;j的路徑，i, j ∈E
<br>作法類似<a class="internal-link" data-href="Floyd-Warshall algorithm.md" href="/考研筆記/演算法/ch4-graph-algorithms/floyd-warshall-algorithm.html" target="_self" rel="noopener">Floyd-Warshall algorithm</a><br><img src="/lib/media/截圖-2022-11-02-上午10.08.57.jpg">]]></description><link>考研筆記/演算法/ch4-graph-algorithms/transitive-closure.html</link><guid isPermaLink="false">考研筆記/演算法/CH4 Graph Algorithms/transitive closure.md</guid><pubDate>Wed, 13 Mar 2024 09:21:49 GMT</pubDate><enclosure url="lib/media/截圖-2022-11-02-上午10.08.57.jpg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib/media/截圖-2022-11-02-上午10.08.57.jpg&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[3-CNF-SAT]]></title><description><![CDATA[ 
 <br>3-CNF-SAT<br>The 3-CNF satisfiability problem]]></description><link>考研筆記/演算法/ch6-np-completeness/3-cnf-sat.html</link><guid isPermaLink="false">考研筆記/演算法/CH6 NP-completeness/3-CNF-SAT.md</guid><pubDate>Wed, 13 Mar 2024 09:28:52 GMT</pubDate></item><item><title><![CDATA[6.1 Complexity class]]></title><description><![CDATA[ 
 <br>一般猜測<br><br><br>探討哪些是‘容易解的’(tractable)，而哪些是‘不容易解的’(intractable)<br>
分類的好處：針對那些不易解的問題，我們可以退而求其次，在有效時間內求出近似解。<br>問題模式先分為兩種（以 <a class="internal-link" data-href="clique.md" href="/考研筆記/演算法/ch6-np-completeness/clique.html" target="_self" rel="noopener">clique</a> 為例）：<br>
<br>optimization problem:當尋求問題為解一個最佳值時，稱之。
<br>decision problem:欲解的問題為一個是非題時，稱之
<br>Tip如果求得optimization version之解，則decision version問題便很好回答<br>
-&gt;decision version 不會比optimization versions難解

不同問題之decision version之間轉換比較容易<br><br>對decision problem 做難度分類<br><br>引理：若A ≤𝑝 B，則B為polynomial-time solvable =&gt; A 為polynomial-time solvable<br>定理：若存在一個NP-complete的問題為polynomial-time solvable，則P = NP假設N != NP 則所有NP-complete都無法在poly.-time之內解決<br>
換言之，如果可以證明一個NP-complete的問題具有poly.-time的解法，相當於證明 P = NP<br><br>首先了解<a class="internal-link" data-href="CNF.md" href="/考研筆記/演算法/ch6-np-completeness/cnf.html" target="_self" rel="noopener">CNF</a><br><br><br><br><br><br><br><br>針對NP-complete問題找出近似演算法<br>條件與定義<br>
假設V*為一個最佳解做對應之最佳值，任給一個大小為n之instance，若V為在使用A（用來解此問題的演算法）解此問題的最佳值<br>
max{V/V, V/V}≤𝛒(n)<br>
則稱𝛒(n)為approximation ratio，且稱A為Q(問題)之𝛒(n)-approximation algorithm
<br><br>]]></description><link>考研筆記/演算法/ch6-np-completeness/ch6-np-completeness.html</link><guid isPermaLink="false">考研筆記/演算法/CH6 NP-completeness/CH6 NP-completeness.md</guid><pubDate>Wed, 13 Mar 2024 09:21:47 GMT</pubDate></item><item><title><![CDATA[clique]]></title><description><![CDATA[ 
 <br>
clique: G中最大的complete subgraph
<br>給定一個圖G=(V, E)<br>
<br>optimization version:<br>
給定一個圖G=(V, E)，求G中最大clique
<br>decision version:<br>
給定一個圖G=(V, E)與一個正整數 k，G中是否具有大小為k的clique
<br>是一個<a class="internal-link" data-href="NP-complete.md" href="/考研筆記/演算法/ch6-np-completeness/np-complete.html" target="_self" rel="noopener">NP-complete</a>問題<br>
證明<br>
<br>CLIQUE ∈<a class="internal-link" data-href="NP.md" href="/考研筆記/演算法/ch6-np-completeness/np.html" target="_self" rel="noopener">NP</a>
<br><a class="internal-link" data-href="3-CNF-SAT.md" href="/考研筆記/演算法/ch6-np-completeness/3-cnf-sat.html" target="_self" rel="noopener">3-CNF-SAT</a> ≤𝑝 CLIQUE
]]></description><link>考研筆記/演算法/ch6-np-completeness/clique.html</link><guid isPermaLink="false">考研筆記/演算法/CH6 NP-completeness/clique.md</guid><pubDate>Wed, 13 Mar 2024 09:36:36 GMT</pubDate></item><item><title><![CDATA[CNF]]></title><description><![CDATA[ 
 <br>conjunction nermal form (𝜙)<br>
<img src="/lib/media/截圖-2022-11-09-下午12.55.13.jpg">]]></description><link>考研筆記/演算法/ch6-np-completeness/cnf.html</link><guid isPermaLink="false">考研筆記/演算法/CH6 NP-completeness/CNF.md</guid><pubDate>Wed, 13 Mar 2024 09:47:17 GMT</pubDate><enclosure url="lib/media/截圖-2022-11-09-下午12.55.13.jpg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib/media/截圖-2022-11-09-下午12.55.13.jpg&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[NP]]></title><description><![CDATA[ 
 <br><br>
所有可被nondeteministic 演算法在多項式時間內解決之decision problem
<br>nondeteministic 演算法包含兩步奏：<br>
<br>Gussing:演算法會先猜出一個可能的解(certificate or witness)，若有解，certification必為原問題的解
<br>Verification:演算法利用certificate驗證是否有解
<br>猜出一個解，驗證猜測是否正確]]></description><link>考研筆記/演算法/ch6-np-completeness/np.html</link><guid isPermaLink="false">考研筆記/演算法/CH6 NP-completeness/NP.md</guid><pubDate>Wed, 13 Mar 2024 09:47:53 GMT</pubDate></item><item><title><![CDATA[NP-complete]]></title><description><![CDATA[ 
 <br><br>
若A ∈ NP且A為<a class="internal-link" data-href="NP-hard.md" href="/考研筆記/演算法/ch6-np-completeness/np-hard.html" target="_self" rel="noopener">NP-hard</a>，則A為NP-complete
<br>證明B為NP-complete問題，需滿足兩性質<br>
<br>B ∈ NP
<br>存在A∈NP-complete問題使得A ≤𝑝 B
]]></description><link>考研筆記/演算法/ch6-np-completeness/np-complete.html</link><guid isPermaLink="false">考研筆記/演算法/CH6 NP-completeness/NP-complete.md</guid><pubDate>Wed, 13 Mar 2024 09:25:36 GMT</pubDate></item><item><title><![CDATA[NP-hard]]></title><description><![CDATA[ 
 <br><br>∀A∈<a class="internal-link" data-href="NP.md" href="/考研筆記/演算法/ch6-np-completeness/np.html" target="_self" rel="noopener">NP</a>, A ≤𝑝 B ，則B為NP-hard]]></description><link>考研筆記/演算法/ch6-np-completeness/np-hard.html</link><guid isPermaLink="false">考研筆記/演算法/CH6 NP-completeness/NP-hard.md</guid><pubDate>Wed, 13 Mar 2024 09:36:17 GMT</pubDate></item><item><title><![CDATA[P]]></title><description><![CDATA[ 
 <br><br>
所有可被(deteministic)演算法在多項式時間內解決的decision problem
]]></description><link>考研筆記/演算法/ch6-np-completeness/p.html</link><guid isPermaLink="false">考研筆記/演算法/CH6 NP-completeness/P.md</guid><pubDate>Wed, 13 Mar 2024 09:48:14 GMT</pubDate></item><item><title><![CDATA[VERTEX-COVER]]></title><description><![CDATA[ 
 ]]></description><link>考研筆記/演算法/ch6-np-completeness/vertex-cover.html</link><guid isPermaLink="false">考研筆記/演算法/CH6 NP-completeness/VERTEX-COVER.md</guid><pubDate>Wed, 13 Mar 2024 09:25:11 GMT</pubDate></item><item><title><![CDATA[演算法]]></title><description><![CDATA[ 
 <br><br><br><br><br><br><br><img src="/lib/media/image-4.jpg"><br>
<img src="/考研筆記/演算法/img/image.jpg">]]></description><link>考研筆記/演算法/⭐️演算法.html</link><guid isPermaLink="false">考研筆記/演算法/⭐️演算法.md</guid><pubDate>Wed, 13 Mar 2024 09:52:44 GMT</pubDate><enclosure url="lib/media/image-4.jpg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib/media/image-4.jpg&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[分數紀錄]]></title><description><![CDATA[ 
 <br><br><br>ㄑㄧㄑㄧ]]></description><link>考研筆記/分數紀錄.html</link><guid isPermaLink="false">考研筆記/分數紀錄.md</guid><pubDate>Wed, 13 Mar 2024 09:53:45 GMT</pubDate></item><item><title><![CDATA[前言]]></title><description><![CDATA[<a class="tag" href="?query=tag:數學" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#數學</a> <a class="tag" href="?query=tag:數學" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#數學</a> <a class="tag" href="?query=tag:軟體" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#軟體</a> <a class="tag" href="?query=tag:軟體" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#軟體</a> <a class="tag" href="?query=tag:硬體" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#硬體</a> <a class="tag" href="?query=tag:硬體" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#硬體</a> <a class="tag" href="?query=tag:數學" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#數學</a> <a class="tag" href="?query=tag:數學" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#數學</a> <a class="tag" href="?query=tag:軟體" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#軟體</a> <a class="tag" href="?query=tag:軟體" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#軟體</a> <a class="tag" href="?query=tag:硬體" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#硬體</a> <a class="tag" href="?query=tag:硬體" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#硬體</a> <a class="tag" href="?query=tag:數學" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#數學</a> <a class="tag" href="?query=tag:數學" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#數學</a> <a class="tag" href="?query=tag:軟體" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#軟體</a> <a class="tag" href="?query=tag:軟體" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#軟體</a> <a class="tag" href="?query=tag:硬體" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#硬體</a> <a class="tag" href="?query=tag:硬體" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#硬體</a> <a class="tag" href="?query=tag:⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️</a> <a class="tag" href="?query=tag:✅✅✅✅✅" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#✅✅✅✅✅</a> <a class="tag" href="?query=tag:⭐️⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️⭐️</a> <a class="tag" href="?query=tag:✅✅✅✅✅" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#✅✅✅✅✅</a> <a class="tag" href="?query=tag:⭐️⭐️⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️⭐️⭐️</a> <a class="tag" href="?query=tag:✅✅✅✅✅" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#✅✅✅✅✅</a> <a class="tag" href="?query=tag:⭐️⭐️⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️⭐️⭐️</a> <a class="tag" href="?query=tag:✅✅✅✅" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#✅✅✅✅</a> <a class="tag" href="?query=tag:⭐️⭐️⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️⭐️⭐️</a> <a class="tag" href="?query=tag:✅✅✅✅" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#✅✅✅✅</a> <a class="tag" href="?query=tag:⭐️⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️⭐️</a> <a class="tag" href="?query=tag:✅✅✅" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#✅✅✅</a> <a class="tag" href="?query=tag:⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️</a> <a class="tag" href="?query=tag:✅" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#✅</a> <a class="tag" href="?query=tag:⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️</a> <a class="tag" href="?query=tag:✅✅✅" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#✅✅✅</a> <a class="tag" href="?query=tag:⭐️⭐" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐</a> <a class="tag" href="?query=tag:⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️</a> <a class="tag" href="?query=tag:✅✅✅✅✅" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#✅✅✅✅✅</a> <a class="tag" href="?query=tag:⭐️⭐" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐</a> <a class="tag" href="?query=tag:✅✅✅" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#✅✅✅</a> <a class="tag" href="?query=tag:⭐️⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️⭐️</a> <a class="tag" href="?query=tag:✅✅✅" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#✅✅✅</a> <a class="tag" href="?query=tag:⭐️⭐️⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️⭐️⭐️</a> <a class="tag" href="?query=tag:✅✅✅" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#✅✅✅</a> <a class="tag" href="?query=tag:⭐️⭐️⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️⭐️⭐️</a> <a class="tag" href="?query=tag:✅✅✅" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#✅✅✅</a> <a class="tag" href="?query=tag:⭐️⭐️⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️⭐️⭐️</a> <a class="tag" href="?query=tag:✅✅" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#✅✅</a> <a class="tag" href="?query=tag:⭐️⭐️⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️⭐️⭐️</a> <a class="tag" href="?query=tag:✅✅" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#✅✅</a> <a class="tag" href="?query=tag:⭐️⭐️⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️⭐️⭐️</a> <a class="tag" href="?query=tag:✅✅" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#✅✅</a> <a class="tag" href="?query=tag:⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️</a> <a class="tag" href="?query=tag:✅✅✅" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#✅✅✅</a> <a class="tag" href="?query=tag:⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️</a> <a class="tag" href="?query=tag:⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️</a> <a class="tag" href="?query=tag:✅✅✅" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#✅✅✅</a> <a class="tag" href="?query=tag:✅" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#✅</a> <a class="tag" href="?query=tag:⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️</a> <a class="tag" href="?query=tag:✅" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#✅</a> <a class="tag" href="?query=tag:⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️</a> <a class="tag" href="?query=tag:✅✅✅" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#✅✅✅</a> <a class="tag" href="?query=tag:⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️</a> <a class="tag" href="?query=tag:✅✅✅" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#✅✅✅</a> <a class="tag" href="?query=tag:⭐️⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️⭐️</a> <a class="tag" href="?query=tag:✅✅✅✅" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#✅✅✅✅</a> <a class="tag" href="?query=tag:⭐️⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️⭐️</a> <a class="tag" href="?query=tag:✅✅✅✅✅" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#✅✅✅✅✅</a> <a class="tag" href="?query=tag:⭐️⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️⭐️</a> <a class="tag" href="?query=tag:✅✅✅✅" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#✅✅✅✅</a> <a class="tag" href="?query=tag:⭐️⭐️⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️⭐️⭐️</a> <a class="tag" href="?query=tag:✅✅✅✅✅" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#✅✅✅✅✅</a> <a class="tag" href="?query=tag:⭐️⭐️⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️⭐️⭐️</a> <a class="tag" href="?query=tag:✅✅✅✅" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#✅✅✅✅</a> <a class="tag" href="?query=tag:⭐️⭐️⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️⭐️⭐️</a> <a class="tag" href="?query=tag:✅✅✅" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#✅✅✅</a> <a class="tag" href="?query=tag:⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️</a> <a class="tag" href="?query=tag:⭐️⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️⭐️</a> <a class="tag" href="?query=tag:演算法" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#演算法</a> <a class="tag" href="?query=tag:⭐️⭐" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐</a> <a class="tag" href="?query=tag:✅✅✅✅" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#✅✅✅✅</a> <a class="tag" href="?query=tag:⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️</a> <a class="tag" href="?query=tag:⭐️⭐️⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️⭐️⭐️</a> <a class="tag" href="?query=tag:⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️</a> <a class="tag" href="?query=tag:⭐️⭐️⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️⭐️⭐️</a> <a class="tag" href="?query=tag:⭐️⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️⭐️</a> <a class="tag" href="?query=tag:✅✅✅" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#✅✅✅</a> <a class="tag" href="?query=tag:⭐️⭐️⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️⭐️⭐️</a> <a class="tag" href="?query=tag:⭐️⭐️⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️⭐️⭐️</a> <a class="tag" href="?query=tag:⭐️⭐️⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️⭐️⭐️</a> <a class="tag" href="?query=tag:⭐️⭐️⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️⭐️⭐️</a> <a class="tag" href="?query=tag:⭐️⭐️⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️⭐️⭐️</a> <a class="tag" href="?query=tag:⭐️⭐️⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️⭐️⭐️</a> <a class="tag" href="?query=tag:⭐️⭐️" style="background-color: rgb(4, 108, 116); color: white; font-weight: 700; border: none; border-radius: 1em; padding: 0.2em 0.5em;">#⭐️⭐️</a> 
 <br><br>
<br>軟體: 資料結構、演算法
<br>硬體: 計算機組織、作業系統
<br>數學: 離散數學、線性代數
<br>
數學分數決定排名、硬體分數要把握好、軟體多背
<br><br>
<br>考古先寫中央在寫交大的題目，這兩所比較考基本工
<br>數學類：有時間把所有是非題和easy的題目刷（看）過一遍
<br><br><a rel="noopener" class="external-link" href="https://www.dcard.tw/f/graduate_school/p/235503759" target="_blank">https://www.dcard.tw/f/graduate_school/p/235503759</a><br>
<a rel="noopener" class="external-link" href="https://www.csie.ntu.edu.tw/~f92087/master.pdf" target="_blank">https://www.csie.ntu.edu.tw/~f92087/master.pdf</a><br>
<a rel="noopener" class="external-link" href="https://hackmd.io/@kangchunhung/things_of_getting_admitted_by_CSIE_Department" target="_blank">https://hackmd.io/@kangchunhung/things_of_getting_admitted_by_CSIE_Department</a><br>線性代數基本上用黃子嘉的書(五版)就夠了，我放掉第六章(Jordan Form)跟所有打星號的章節(5-8 Markov鏈除外)。<br>
上冊超級重要，尤其是三、四兩章，如果這兩章讀不懂不建議往下，高機率浪費自己的時間。<br>
下冊重點在五、七兩章跟八的SVD，八的有些小節投資報酬率很低，但一開始還是建議全看，之後再斟酌要放掉哪些內容。<br>
每章讀完我會去寫是非題把觀念矯正一波，錯的標起來下次再寫一次。<br>
easy難度的練習題，因為書的編排會把相同題型的題目擺一起，所以只要確定對一種題型的觀念熟了就能跳過重複的題目來增加效率。<br>
Middle難度不會寫很正常，尤其又是統計系或數學系出的題目，蠻靠北的，資工的題目通常不會那麼刁鑽，但還是要把詳解熟讀抓出沒那麼熟的觀念反覆多看，會慢慢有感覺。<br>
Hard難度我只看資工的題目，並用娛樂的心態來練習，有時會藏一些意想不到的觀念，但如果題目太難一樣直接放生。<br>離散數學容易讀A忘B，需要固定回去複習<br>
上冊幾乎都是重點，尤其是三到五章。下冊就第十章的1、6、7小節。<br>
離散要記的定理很多，一定要隔一段時間就回來翻一下才能強化短期記憶。<br>
練習題我一樣採同題型觀念熟了就跳下一題型的寫法，但題目實在是太多，所以我只寫奇數題，偶數題有時間再回來寫。<br>
時間不夠寫的時候主要以資工題目為優先，然後太難的放生。<br>
這科真的很容易發生讀B忘A的情況，建議不要衝太快，撥一點時間固定複習讀過的章節，才不會跟我一樣很沒效率的一直在全部重讀。<br>資料結構算簡單（？）<br>
前期主要用洪逸的書(錯很多)配網路上神人的筆記，考前兩三個月換成王致強的書，內容齊全很多，有基礎再看比較適合。Horowitz的原文書一直都有在用，主要是看code跟一些講義不太清楚的部分。<br>
資結的考題通常都蠻簡單的，重點要放在樹(含高等樹)、圖論、排序，程式碼建議讀通並要能幾乎寫出來。<br>演算法設計題型、基本<br>
主要用林立宇2018年的書跟CLRS原文書(3rd edition)。我放掉計算幾何跟NP approximation的部分。這科我真的完全不行QQ，只要考我沒看過的一定GG，我的策略就是只要把基本或我看過的寫出來就很好了。<br>
除了林立宇的書有提到的內容跟題目，我還「背」了一些CLRS的習題。我基本上都挑設計題，就是題目請你設計一個演算法，因為考試容易考這些，甚至像中央之類的學校很可能會把題目原封不動的抄上去，只要賭中一題就發了。<br>計組與計概標準重點章節在

<br>五、六兩章(pipeline、memory)
<br>考題趨勢是第七章(I/O)跟附錄(multicycle)近幾年都沒考
<br>第八章(multiprocessor)則是越來越重要，建議斟酌一下這些章節要花的時間。

計組的基本題型大概就是書裡看到的那些，我都是參考神人筆記上有出現的題目再去書裡做練習，沒寫到的題目下次讀的時候再補寫。我自己是把整本書的考古題都寫完，同樣採取基本題練爆的策略。因為跟演算法一樣被考倒根本輕輕鬆鬆，所以只要能把握基本我就算對得起自己了<br>作業系統考題重點會在process跟memory這兩大板塊，不過你會發現其它章雖然出題機率較低但也根本放不得。<br>
我自己是讀了原文ppt的第1~13和15章。<br>
再次強調這科最好直接讀原文!尤其對要考交大的考生會特別有幫助。 練習題的部份把洪逸那本的題目全部寫完再加上恐龍本的習題就夠了。<br><br><img src="/考研筆記/img/截圖-2023-01-23-下午11.48.39.jpg"><br>統計：<br>
台大4<br>
清大2+8<br>
中央2+7<br>
台科5<br><br><br>8:10 ~ 9:50 (100min)資料結構與演算法<br>
休息(40min)<br>
10:30 ~ 12:10(100min)計算機結構與作業系統<br>
休息(100min)<br>
1:40 ~ 3:20(100min) 英文<br>
休息(40min)<br>
4:00 ~ 5:40數學<br><br>10:30 ~ 12:10 基礎計算機科學<br>
13:40 ~ 15:20 計算機系統<br><br>9:30 ~ 11:10(100min)資料結構與演算法<br>
12:35 ~ 14:15(100min)離散數學與線性代數<br>
15:00 ~ 16:40(100min)作業系統與計算機組織<br><br>8:20 ~ 10:00(100min): 資訊工程概論(含資料結構、 作業系統、計算機組織)<br>
10:40 ~ 12:20(100min)計算機數學 (含離散數學、線性代數)<br><br>
聽完教材
<br>
<br>線性代數 <a href=".?query=tag:數學" class="tag" target="_blank" rel="noopener">#數學</a>
<br>離散數學 <a href=".?query=tag:數學" class="tag" target="_blank" rel="noopener">#數學</a>
<br>資料結構 <a href=".?query=tag:軟體" class="tag" target="_blank" rel="noopener">#軟體</a>
<br>演算法 <a href=".?query=tag:軟體" class="tag" target="_blank" rel="noopener">#軟體</a>
<br>計組與計概 <a href=".?query=tag:硬體" class="tag" target="_blank" rel="noopener">#硬體</a>
<br>作業系統 <a href=".?query=tag:硬體" class="tag" target="_blank" rel="noopener">#硬體</a>
<br><br>
自己run完教材＆整理完筆記
<br>
<br>線性代數 <a href=".?query=tag:數學" class="tag" target="_blank" rel="noopener">#數學</a>
<br>離散數學 <a href=".?query=tag:數學" class="tag" target="_blank" rel="noopener">#數學</a>
<br>資料結構 <a href=".?query=tag:軟體" class="tag" target="_blank" rel="noopener">#軟體</a>
<br>演算法 <a href=".?query=tag:軟體" class="tag" target="_blank" rel="noopener">#軟體</a>
<br>計組與計概 <a href=".?query=tag:硬體" class="tag" target="_blank" rel="noopener">#硬體</a> 沒上完課
<br>作業系統 <a href=".?query=tag:硬體" class="tag" target="_blank" rel="noopener">#硬體</a>
<br><br><br>
寫一些考古題後，把不熟的地方在寫一遍，練習題刷一遍（看）
<br>
<br>線性代數 <a href=".?query=tag:數學" class="tag" target="_blank" rel="noopener">#數學</a>
<br>離散數學 <a href=".?query=tag:數學" class="tag" target="_blank" rel="noopener">#數學</a>
<br>資料結構 <a href=".?query=tag:軟體" class="tag" target="_blank" rel="noopener">#軟體</a>
<br>演算法 <a href=".?query=tag:軟體" class="tag" target="_blank" rel="noopener">#軟體</a>
<br>計組與計概 <a href=".?query=tag:硬體" class="tag" target="_blank" rel="noopener">#硬體</a>
<br>作業系統 <a href=".?query=tag:硬體" class="tag" target="_blank" rel="noopener">#硬體</a>
<br><br>因為時間不夠只能這樣安排的我ＱＱ<br><br><a data-tooltip-position="top" aria-label="https://hackmd.io/@kangchunhung/things_of_getting_admitted_by_CSIE_Department" rel="noopener" class="external-link" href="https://hackmd.io/@kangchunhung/things_of_getting_admitted_by_CSIE_Department" target="_blank">版型參考</a><br><br><br><br>基本上，一直到線性映射都要熟讀<br>矩陣與線性方程組<br>
最基本的不能忘（高中層級）
<br>向量空間<br>
定義不能忘（子空間），
<br>對角化及其應用<br>

<br>有很多性質要再看一遍（冪零、冪等），做中央考古時，很多觀念題都沒把握。
<br>可對角化&lt;=&gt;n個linear indep.的eigenvector
<br>可逆與可對角化無關
<br>微分方程系統通解

<br>Jordan 型及其應用 <br>
Cayley-Hamilton定理！！！雖然目前沒有練習到<br>
痾...希望不考Jordan型ＸＤ，但畫點點還是要會，這也牽扯到對角化（gm &lt;= am）。有時間練個題目背一下就好
<br>內積空間<br>
感覺目前只是會算，遇到觀念會有點吃力。<br>
性質要更熟悉
<br><br><br><br>
三種性質(reflective, symmetric, transitive)應用
<br>排列、組合、排容<br>
各種公式與其推導觀念<br>
清大會考C(n+r-1, r)怎麼來的，也很長考x1+x2+x3= r這種題目的變化型
<br>生成函數<br>
生成函數公式、一般生成函數、指數生成函數
<br>遞迴關係<br>
特徵方程式3個case&amp;齊次非齊次解、生成函數解遞迴
<br>圖論<br>
在e, v, r, k, M之間的關係<br>
還有planar的相關計算<br>
Ealur, hamilton
<br>絡與布林代數<br>

<br>1, 6, 7小節。
<br>偏序、全序（lub, glb,hasse圖）。要背好定義
<br>命題、tautology、contradiction。要背好定義
<br>lattice: 存在lub &amp; glb

<br>代數系統<br>
台大似乎必考，但超難，應該做考古看到才會稍微記一下，看運氣答題
<br><br><br>最簡單的一科
如果你的目標是交大，資結任何一個章節都不能放
複製<br><br>Introductio<br>
permutation。跟哪邊swap？end-- 還是start++去做遞迴？<br>
時間複雜度比較 <a href=".?query=tag:演算法" class="tag" target="_blank" rel="noopener">#演算法</a>
<br>Array&amp;Linked list<br>
可能要補看一下不同種類的linked list（輕鬆看過）<br>
row major, column major注意一下，要不要i-1, j-1這些要看清楚
<br>Stack &amp; Queue<br>
有很多類型、方法，後續在看一次，怕忘記<br>
尤其是Queue的full, empty判斷、哪種結構在什麼情況下比較方便（像是linked list結構比較方便插入）
<br>Tree &amp; Heap<br>
都會，看到題目應該可以回想起來，只要熟悉就好<br>
Tree, B Tree的遞迴式、計算
<br>Graph<br>
清大會考「表示法」
<br>Sort &amp; Search<br>
有時間再「熟」讀<br>
worst case, avg. case, best case要記熟，有時會兩種sort合在一起用（ex: merge sort &amp; quick sort）<br>
實作演算法<br>
基本排序、進階排序、線性排序<br>
Comparison sort bound要知道是Ω(nlgn)（解釋出原因decision tree）
<br>Hashing<br>
為了交大，讀吧！
<br>Advance Tree<br>
讀過一次了，基本的insert, delete都會
<br><br><br><br>I/O, HW, Interrupt 介紹<br>
I/O流程要背、Dual mode、各種protection
<br>OS structure<br>
有好幾種OS，可能考前要稍微翻一下，交大可能會出一題來考，micro kernel之類的，有哪些有kernel概念哪些沒有，可能都要搞清楚
<br>Process &amp; Thread Management<br>

<br>Job Sceduling
<br>Context Switching
<br>Starvation
<br>Convoy Effect (護衛效應)
<br>Aging Technique
<br>(Non-)Peemptive
<br>process和thread的定義、比較不熟
<br>I/O bounded, CPU bounded

<br>Deadlock<br>

<br>4項Deadlock必要條件
<br>Banker algo
<br>prevent, avoid, recovery, detect

<br><br><br><br><br><br><br>pipeline<br>Disk &amp; I/O<br>

<br>RAID各種類
<br>Dependability, Reliability, Availability
<br>MTTF = MTTR + MTBF

<br>記憶體<br>

<br>TLB與page table與cache之間的轉換關係與各自的miss, hit時間計算
<br>計算effective memory access time

(注意：若TLB hit time=1 mem. access &amp; 1 TLB access; TLB miss time = 2 mem. access &amp; 1 TLB access)
]]></description><link>考研筆記/考研規劃＆進度.html</link><guid isPermaLink="false">考研筆記/考研規劃＆進度.md</guid><pubDate>Wed, 13 Mar 2024 09:53:00 GMT</pubDate><enclosure url="考研筆記/img/截圖-2023-01-23-下午11.48.39.jpg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;考研筆記/img/截圖-2023-01-23-下午11.48.39.jpg&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[首頁]]></title><description><![CDATA[ 
 <br><br><br><br><br><a class="internal-link" data-href="考研規劃＆進度.md" href="/考研筆記/考研規劃＆進度.html" target="_self" rel="noopener">考研規劃＆進度</a><br>
<a class="internal-link" data-href="分數紀錄.md" href="/考研筆記/分數紀錄.html" target="_self" rel="noopener">分數紀錄</a><a data-tooltip-position="top" aria-label="https://docs.google.com/spreadsheets/u/0/d/10-7_Jfo62omI24h_iJPiaqbpeaw6nU2YEcUP99j3fvs/htmlview#gid=1426544798" rel="noopener" class="external-link" href="https://docs.google.com/spreadsheets/u/0/d/10-7_Jfo62omI24h_iJPiaqbpeaw6nU2YEcUP99j3fvs/htmlview#gid=1426544798" target="_blank"></a>]]></description><link>考研筆記/首頁.html</link><guid isPermaLink="false">考研筆記/首頁.md</guid><pubDate>Wed, 13 Mar 2024 09:54:02 GMT</pubDate></item></channel></rss>